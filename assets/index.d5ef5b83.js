var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __restKey = (key) => typeof key === "symbol" ? key : key + "";
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
import { r as react, M as MenuItem$2, S as SubMenu, c as css, w as withRouter, j as jsxs, a as jsx, F as FaBars, E as ExportMenu, b as Switch, R as Route, d as jsx$1, e as jsxs$1, x as xGetFromToIndex, f as analyseMultiplet, g as debounce_1, m as map_1, h as reimAbsolute, i as reimAutoPhaseCorrection, k as equallySpaced$1, l as baselineCorrectionRegression, n as airPLS, o as array, p as xySetYValue, z as zonesNormalize, q as reimFFT, s as reimPhaseCorrection, t as xParetoNormalization, u as merge_1, v as xyIntegration, y as rangesToXY, A as resurrect, B as xFindClosestIndex, C as gsd, D as mean, G as median, H as xyAutoPeaksPicking, I as max, J as xyMinYPoint, K as xyMaxYPoint, L as xyAutoRangesPicking, N as zoneToX, O as Conrec, P as xyzAutoZonesPicking, Q as full, T as fromBruker$2, U as fromJCAMP, V as fromJEOL, W as predictAll, X as signalsToXY, Y as signals2DToZ, Z as getFrequency, _ as Zip, $ as NmrRecord, a0 as parseSDF, a1 as linear, a2 as extent, a3 as e, a4 as cloneDeep_1, a5 as setPathLength, a6 as buildCorrelationData, a7 as setCorrelation, a8 as identity, a9 as D, aa as max$1, ab as get_1, ac as fn, ad as ContainerTransition, ae as reactDom, af as TransitionGroup, ag as FaTimes, ah as BsArrowsMove, ai as OCLnmr, aj as set_1, ak as xyReduce, al as axisBottom, am as format, an as select, ao as Fragment, ap as axisRight, aq as EventEmitter, ar as Numeral, as as MF, at as ResponsiveChart, au as Fragment$1, av as useSize, aw as Rnd, ax as Plot, ay as LineSeries, az as xyToXYObject, aA as Axis, aB as xyIntegral, aC as useLinearPrimaryTicks, aD as BsCursor, aE as IoPulseSharp, aF as useFormikContext, aG as Formik, aH as Field, aI as FileSaver_min, aJ as getShortestPaths, aK as getGroupedDiastereotopicAtomIDs, aL as FaRegTrashAlt, aM as FaFilter, aN as FaCog, aO as SvgRangePicking, aP as reactTable, aQ as useMeasure, aR as SvgAssignment, aS as getAssignments, aT as SvgAssignment2, aU as FaBolt, aV as FaAngleLeft, aW as MolfileSvgRenderer, aX as _default, aY as create, aZ as create$1, a_ as FaCheck, a$ as lib, b0 as SvgSum, b1 as ImLink, b2 as SvgAddFilter, b3 as SvgExportAsMatrix, b4 as StructureEditor, b5 as create$2, b6 as create$3, b7 as FaFileExport, b8 as FaPaste, b9 as FaPlus, ba as SvgFt, bb as IoOpenOutline, bc as FaCopy, bd as FaFileImage, be as FaDownload, bf as FaEllipsisH, bg as SvgOverlay, bh as IoPulseOutline, bi as rangesToACS, bj as FaUnlink, bk as FaSitemap, bl as FaChartBar, bm as SvgIntegrate, bn as FieldArray, bo as create$4, bp as create$5, bq as FaSearchPlus, br as FaEdit, bs as FaMinusCircle, bt as FaLink, bu as FaEyeSlash, bv as FaEye, bw as FaCreativeCommonsSamplingPlus, bx as SvgResetScale, by as SvgSameTop, bz as SvgPeaks, bA as SvgFid, bB as Svg2D, bC as Heading, bD as Legend, bE as xNoiseSanPlot, bF as u, bG as getLinkDim, bH as buildCorrelation, bI as buildLink, bJ as getLinkDelta, bK as addLink, bL as removeLink, bM as getCorrelationDelta, bN as getLabel, bO as getAtomCounts, bP as FaFlask, bQ as FaSlidersH, bR as protonImpurities, bS as carbonImpurities, bT as filter, bU as IdcodeSvgRenderer, bV as SmilesSvgRenderer, bW as FaICursor, bX as IoSearchOutline, bY as ObjectInspector$1, bZ as Accordion, b_ as useToggleAccordion, b$ as SplitPane, c0 as create$6, c1 as ValidationError, c2 as Header, c3 as Toolbar, c4 as SvgNmrium, c5 as FaQuestionCircle, c6 as FaWrench, c7 as FaRegWindowMaximize, c8 as useDropzone, c9 as FaUpload, ca as FaFileImport, cb as SvgOverlay3Aligned, cc as SvgOverlay3, cd as SvgRealImag, ce as SvgAlignCenter, cf as SvgAlignBottom, cg as FaFile, ch as FaFileDownload, ci as FaExpand, cj as SvgPeakPicking, ck as FaDiceFour, cl as SvgMultipleAnalysis, cm as SvgZeroFilling, cn as SvgPhaseCorrection, co as SvgBaselineCorrection, cp as SvgFourierTransform, cq as ErrorBoundary, cr as RootLayout, cs as useToggle, ct as useFullscreen, cu as DropZone$1, cv as profiling, cw as HashRouter } from "./vendor.1a8b6e6b.js";
const p = function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
};
p();
var routes = [
  {
    title: "Empty"
  },
  {
    groupName: "General",
    children: [
      {
        file: "./data/cytisine/1H.json",
        title: "1H spectrum test"
      },
      {
        file: "./data/ethylbenzene/1h.json",
        title: "1H ethylbenzene"
      },
      {
        file: "./data/ethylbenzene/cosy.json",
        title: "COSY ethylbenzene"
      },
      {
        file: "./data/ethylbenzene/full.json",
        title: "FULL ethylbenzene"
      },
      {
        file: "./data/cytisine/2d/hsqc.json",
        title: "HSQC cytisine"
      },
      {
        file: "./data/cytisine/2d/hmbc-only.json",
        title: "HMBC only cytisine"
      },
      {
        file: "./data/cytisine/2d/hsqc_hmbc.json",
        title: "HSQC / HMBC cytisine"
      },
      {
        file: "./data/cytisine/2d/all.json",
        title: "Full cytisine"
      },
      {
        file: "./data/cytisine/2d/HMBC_HN_Cytisin.json",
        title: "1H, 15N HMQC cytisine"
      },
      {
        file: "./data/50-78-2/linked-jcamp.json",
        title: "Linked jcamp"
      },
      {
        file: "./data/cytisine/1Honly.json",
        title: "1H only jcamp"
      },
      {
        file: "./data/cytisine/2d/cosy.json",
        title: "2D cosy"
      },
      {
        file: "./data/cytisine/1D.json",
        title: "1D spectra test"
      },
      {
        file: "./data/ethylvinylether/1h.json",
        title: "1H ethylvinylether"
      },
      {
        file: "./data/cytisine/13CFID.json",
        title: "13C Spectrum"
      },
      {
        file: "./data/cytisine/processed13C.json",
        title: "Processed 13C Spectrum"
      },
      {
        file: "./data/cytisine/Big13C.json",
        title: "Big 13C"
      },
      {
        file: "./data/xtc/XTC.json",
        title: "XTC"
      },
      {
        file: "./data/xtc/XTClight.json",
        title: "XTC just links"
      },
      {
        file: "./data/coffee/Coffee.json",
        title: "Coffee"
      },
      {
        file: "./data/108-21-4/CoupledDecoupled13C.json",
        title: "13C Coupled / Decoupled"
      },
      {
        file: "./data/cytisine/Dept.json",
        title: "DEPT"
      },
      {
        file: "./data/19f/19f.json",
        title: "19F with baseline problems"
      },
      {
        file: "./data/t1/t1.json",
        title: "T1 samples (1H + 13C)"
      },
      {
        file: "./data/t2/t2.json",
        title: "T2 samples (1H + 13C)"
      },
      {
        file: "",
        title: "Two instances",
        view: "TwoInstances"
      }
    ]
  },
  {
    groupName: "Simulate",
    children: [
      {
        file: "./data/tests/simulated/d1-2-3-4-5-6-7-8.json",
        title: "\u03B4=1,2,3,4,5,6,7,8"
      },
      {
        file: "./data/tests/simulated/d1-2-3-4-5-6-7-8HR.json",
        title: "\u03B4=1,2,3,4,5,6,7,8 HR"
      },
      {
        file: "./data/tests/simulated/d1-1.2_j7.json",
        title: "\u03B4=1,1.2 J=7"
      },
      {
        file: "./data/tests/simulated/d1-2_j7.json",
        title: "\u03B4=1,2 J=7"
      },
      {
        file: "./data/tests/simulated/d1-2-3_j16-10-2.json",
        title: "\u03B4=1,2,3 J=2,10,16"
      },
      {
        file: "./data/tests/simulated/d1-7_j7.json",
        title: "\u03B4=1,7 J=7"
      },
      {
        file: "./data/tests/simulated/d1-2-3-4-5-6-7-8_baseline.json",
        title: "Tests with baseline"
      },
      {
        file: "./data/tests/triangle/low-res.json",
        title: "Test low resolution"
      },
      {
        file: "./data/tests/triangle/high-res.json",
        title: "Test high resolution"
      }
    ]
  },
  {
    groupName: "Workspaces",
    children: [
      {
        file: "./exercises/ethylvinylether/1h.json",
        title: "Exercise 1",
        view: "Exercise"
      },
      {
        file: "./exercises/ethylbenzene/1h.json",
        title: "Exercise 2",
        view: "Exercise"
      },
      {
        file: "./exercises/cytisine/hsqc_hmbc.json",
        title: "Exercise 3",
        view: "Exercise"
      },
      {
        file: "./exercises/ethylvinylether/1h.json",
        title: "Exam 1",
        view: "Exam"
      },
      {
        title: "Prediction",
        view: "Prediction"
      }
    ]
  },
  {
    title: "Test",
    view: "Test"
  }
];
var index$1 = "";
function buildMenu(array2 = []) {
  let menu = [];
  for (const item of array2) {
    if (item.children && Array.isArray(item.children)) {
      menu.push(getMenu(item.groupName, [item], []));
    } else {
      menu.push(react.exports.createElement(MenuItem$2, __spreadValues({ key: item.title }, item), item.title));
    }
  }
  return menu;
}
function getMenu(key, array2 = [], nodes = [], parentIndex = 0) {
  let _nodes = nodes;
  let children = [];
  if (parentIndex !== -1 && _nodes[parentIndex]) {
    _nodes[parentIndex] = react.exports.cloneElement(_nodes[parentIndex], {}, children);
  }
  for (const index2 in array2) {
    if (array2[index2].children && Array.isArray(array2[index2].children)) {
      const node = react.exports.createElement(SubMenu, {
        key: index2 + key,
        title: array2[index2].groupName
      });
      _nodes.push(node);
      return getMenu(index2 + key, array2[index2].children, _nodes, 0);
    } else {
      children.push(react.exports.createElement(MenuItem$2, __spreadValues({ key: index2 + key }, array2[index2]), array2[index2].title));
    }
  }
  return _nodes;
}
function mapTreeToFlatArray(array2 = []) {
  let routes2 = [];
  for (const item of array2) {
    if (item.children && Array.isArray(item.children)) {
      routes2 = routes2.concat(getFlatArray([item], []));
    } else {
      routes2.push(item);
    }
  }
  return routes2;
}
function getFlatArray(inputArray = [], children = []) {
  let _children = children;
  for (const item of inputArray) {
    if (item.children && Array.isArray(item.children)) {
      return getFlatArray(item.children, _children);
    } else {
      children.push(item);
    }
  }
  return _children;
}
function getKey(filePath = "") {
  const match = new RegExp(/^(?<path>.*)\/(?<file>[^/]*)$/g).exec(filePath);
  let parentFolderName = "";
  if (match) {
    const parentPath = match[1].split("/");
    parentFolderName = parentPath.length > 2 ? parentPath[parentPath.length - 2] + parentPath[parentPath.length - 1] : parentPath[parentPath.length - 1];
  }
  return parentFolderName + filePath.replace(/\.|\s|\//g, "");
}
const sidebarCss = css`
  background: #2ca8ff;
  position: fixed;
  top: 0;
  height: 100%;
  bottom: 0;
  left: 0;
  z-index: 1031;
`;
const sidebarOpenCss = css`
  width: 260px;
`;
const sidebarClosedCss = css`
  width: 3%;
`;
const menuBtCss = css`
  margin-left: 4px;
  margin-top: 2px;
  margin-bottom: 2px;
  margin-right: 4px;
  z-index: 7;
  font-size: 18px;
  background-color: transparent;
  border: none !important;
  height: 30px;
  width: 30px;
  padding: 1px 6px;

  & svg {
    fill: white;
  }

  &:focus {
    outline: none;
  }

  &:active {
    background-color: rgba(0, 0, 0, 0.5);
    border-radius: 50%;
  }
  &:hover {
    background-color: rgba(0, 0, 0, 0.2);
    border-radius: 50%;
  }
`;
const logoCss = css`
  display: flex;
  justify-content: space-between;
  align-items: center;
  z-index: 4;
  border-bottom: 1px solid #eee;
`;
const simpleTextCss = css`
  text-transform: uppercase;
  padding: 0.5rem 0;
  display: block;
  white-space: nowrap;
  font-size: 1em;
  color: #fff;
  text-decoration: none;
  font-weight: 400;
  line-height: 30px;
  overflow: hidden;
`;
const logoNormalCss = css`
  display: block;
  opacity: 1;
  transform: translateZ(0);
`;
const sidebarWrapperCss = css`
  position: relative;
  height: calc(100vh - 75px);
  overflow-y: auto;
  overflow-x: hidden;
  width: 260px;
  z-index: 4;
  padding-bottom: 100px;
`;
function Sidebar(props) {
  const routes2 = react.exports.useMemo(() => {
    return buildMenu(props.routes);
  }, [props.routes]);
  const subDisplay = props.menuIsClosed ? "none" : "block";
  return /* @__PURE__ */ jsxs("div", {
    css: css(sidebarCss, props.menuIsClosed ? sidebarClosedCss : sidebarOpenCss),
    children: [/* @__PURE__ */ jsxs("div", {
      css: logoCss,
      children: [/* @__PURE__ */ jsx("div", {
        style: {
          display: subDisplay,
          padding: "0.5rem 0.7rem"
        },
        children: /* @__PURE__ */ jsx("a", {
          css: css(simpleTextCss, logoNormalCss),
          children: "NMRium"
        })
      }), /* @__PURE__ */ jsx("button", {
        type: "button",
        css: menuBtCss,
        onClick: props.onMenuToggle,
        children: /* @__PURE__ */ jsx(FaBars, {})
      })]
    }), /* @__PURE__ */ jsx("div", {
      css: sidebarWrapperCss,
      style: {
        display: subDisplay
      },
      children: /* @__PURE__ */ jsx(ExportMenu, {
        onClick: (e2) => {
          props.history.push(`/SamplesDashboard/${Math.random().toString(36).replace("0.", "")}/${(e2.item.props.view || "View") + getKey(e2.item.props.file)}`);
        },
        mode: "inline",
        children: routes2
      })
    })]
  });
}
var Sidebar$1 = withRouter(react.exports.memo(Sidebar));
const scriptRel = "modulepreload";
const seen = {};
const base = "./";
const __vitePreload = function preload(baseModule, deps) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  return Promise.all(deps.map((dep) => {
    dep = `${base}${dep}`;
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule());
};
const possibleViews = {
  Exam: react.exports.memo(react.exports.lazy(() => __vitePreload(() => import("./Exam.bdb99ba5.js"), true ? ["assets/Exam.bdb99ba5.js","assets/vendor.1a8b6e6b.js"] : void 0))),
  Exercise: react.exports.memo(react.exports.lazy(() => __vitePreload(() => import("./Exercise.04e04f7b.js"), true ? ["assets/Exercise.04e04f7b.js","assets/vendor.1a8b6e6b.js"] : void 0))),
  SingleView: react.exports.memo(react.exports.lazy(() => __vitePreload(() => import("./SingleView.a63cecca.js"), true ? ["assets/SingleView.a63cecca.js","assets/vendor.1a8b6e6b.js"] : void 0))),
  Test: react.exports.memo(react.exports.lazy(() => __vitePreload(() => Promise.resolve().then(function() {
    return Test$1;
  }), true ? void 0 : void 0))),
  View: react.exports.memo(react.exports.lazy(() => __vitePreload(() => import("./View.53c2115e.js"), true ? ["assets/View.53c2115e.js","assets/vendor.1a8b6e6b.js"] : void 0))),
  TwoInstances: react.exports.memo(react.exports.lazy(() => __vitePreload(() => import("./TwoInstances.c2112ed5.js"), true ? ["assets/TwoInstances.c2112ed5.js","assets/vendor.1a8b6e6b.js"] : void 0))),
  Teaching: react.exports.memo(react.exports.lazy(() => __vitePreload(() => import("./Teaching.59f7dbc8.js"), true ? ["assets/Teaching.59f7dbc8.js","assets/vendor.1a8b6e6b.js"] : void 0))),
  Prediction: react.exports.memo(react.exports.lazy(() => __vitePreload(() => import("./Prediction.c29f5593.js"), true ? ["assets/Prediction.c29f5593.js","assets/View.53c2115e.js","assets/vendor.1a8b6e6b.js"] : void 0)))
};
const mainPanelCss = css`
  position: relative;
  float: right;
  height: 100%;
  background-color: #ebecf1;
`;
const mainPanelOpenCss = css`
  width: calc(100% - 260px);
`;
const mainPanelClosedCss = css`
  width: 98%;
  margin-left: 20px !important;
`;
function Dashboard(props) {
  const {
    routes: routes2 = [],
    baseURL: baseURL2
  } = props;
  const routesList = react.exports.useMemo(() => mapTreeToFlatArray(routes2), [routes2]);
  const [menuIsClosed, setMenuIsClosed] = react.exports.useState(false);
  const toggleMenu = react.exports.useCallback(() => setMenuIsClosed(!menuIsClosed), [menuIsClosed]);
  return /* @__PURE__ */ jsxs("div", {
    style: {
      position: "relative",
      top: 0,
      height: "100vh"
    },
    children: [/* @__PURE__ */ jsx(Sidebar$1, __spreadProps(__spreadValues({}, props), {
      routes: routes2,
      menuIsClosed,
      onMenuToggle: toggleMenu
    })), /* @__PURE__ */ jsx("div", {
      css: css(mainPanelCss, menuIsClosed ? mainPanelClosedCss : mainPanelOpenCss),
      children: /* @__PURE__ */ jsx(react.exports.Suspense, {
        fallback: /* @__PURE__ */ jsx("div", {
          children: "Loading..."
        }),
        children: /* @__PURE__ */ jsxs(Switch, {
          children: [routesList.map((prop) => {
            return /* @__PURE__ */ jsx(Route, {
              path: `/SamplesDashboard/:id/${(prop.view || "View") + getKey(prop.file)}`,
              render: (props2) => /* @__PURE__ */ jsx(RenderView, __spreadProps(__spreadValues({}, props2), {
                prop,
                baseURL: baseURL2
              }))
            }, getKey(prop.file));
          }), routesList.length > 0 && /* @__PURE__ */ jsx(Route, {
            path: "/",
            render: () => {
              const routeProp = routesList[0];
              const viewName = routeProp.view ? routeProp.view : "View";
              const RenderedView = possibleViews[viewName];
              return /* @__PURE__ */ jsx(RenderedView, __spreadValues({}, routeProp[0]));
            }
          }, getKey(routesList[0].file))]
        })
      })
    })]
  });
}
function RenderView(props) {
  const {
    match: {
      params: {
        id: id2
      }
    },
    prop,
    baseURL: baseURL2
  } = props;
  const viewName = prop.view ? prop.view : "View";
  const RenderedView = possibleViews[viewName];
  return /* @__PURE__ */ jsx(RenderedView, __spreadProps(__spreadValues({}, prop), {
    id: getKey(prop.file),
    baseURL: baseURL2
  }), id2);
}
function SingleDisplayerLayout(props) {
  return /* @__PURE__ */ jsx$1("div", {
    style: {
      position: "relative",
      top: 0,
      height: "100vh"
    },
    children: /* @__PURE__ */ jsx$1("div", {
      style: {
        position: "absolute",
        display: "block",
        width: "99%",
        marginLeft: "auto",
        marginRight: "auto",
        height: "100%",
        backgroundColor: "ebecf1"
      },
      children: /* @__PURE__ */ jsx$1(react.exports.Suspense, {
        fallback: /* @__PURE__ */ jsx$1("div", {
          children: "Loading..."
        }),
        children: /* @__PURE__ */ jsx$1(Switch, {
          children: /* @__PURE__ */ jsx$1(Route, {
            path: "/",
            render: (routeProps) => {
              const {
                match: {
                  params: {
                    id: id2
                  }
                }
              } = routeProps;
              const viewName = props.view ? props.view : "SingleView";
              const RenderedView = possibleViews[viewName];
              return /* @__PURE__ */ jsx$1(RenderedView, __spreadProps(__spreadValues({}, props), {
                id: getKey(props.patrh)
              }), id2);
            }
          }, getKey(props.path))
        })
      })
    })
  });
}
const styles$1h = {
  bodyContainer: {
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    height: "100vh",
    width: "100vw",
    backgroundColor: "#e3e3e3"
  },
  container: {
    width: "30%",
    height: "40%",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    borderRadius: "10px",
    fontSize: "20px",
    textAlign: "center"
  },
  normal: {
    backgroundColor: "white",
    color: "black"
  },
  error: {
    backgroundColor: "red",
    color: "white"
  },
  errorHeader: {
    fontSize: "100px"
  },
  normalHeader: {
    fontSize: "24px"
  },
  loadButton: {
    fontSize: "12px",
    padding: "12px 40px",
    borderRadius: "10px",
    border: "1px solid #c70000",
    fontWeight: "bold",
    cursor: "pointer"
  }
};
async function loadData(url) {
  const response = await fetch(url);
  try {
    checkStatus$1(response);
    const data = await response.json();
    return data;
  } catch (e2) {
    console.error(e2);
    return null;
  }
}
function checkStatus$1(response) {
  if (!response.ok) {
    throw new Error(`HTTP ${response.status} - ${response.statusText}`);
  }
  return response;
}
const Main = (props) => {
  const [data, setRoutes] = react.exports.useState({
    isLoaded: false,
    status: 200,
    routes: []
  });
  const [dashBoardType, setDashBoardType] = react.exports.useState("");
  const loadHandler = react.exports.useCallback(() => {
    setRoutes({
      isLoaded: true,
      status: 200,
      routes
    });
  }, []);
  const getFileExtension2 = (url = "") => {
    return url.substring(url.lastIndexOf(".") + 1);
  };
  const href = window.location.href;
  react.exports.useEffect(() => {
    const qs = new URL(href).searchParams;
    if (qs.has("sampleURL")) {
      const sampleURL = qs.get("sampleURL");
      if (!sampleURL)
        return;
      const extention = getFileExtension2(sampleURL).toLowerCase();
      switch (extention) {
        case "json": {
          setDashBoardType("multi");
          void loadData(sampleURL).then((remoteRoutes) => {
            if (remoteRoutes) {
              const baseURL2 = sampleURL.replace(/^(?<url>.*[\\/])?(?<filename>.*?\.[^.]*?|)$/g, "$1");
              const _remoteRoutes = JSON.parse(JSON.stringify(remoteRoutes).replace(/\.\/+?/g, baseURL2));
              setRoutes({
                isLoaded: true,
                status: 200,
                routes: _remoteRoutes,
                baseURL: baseURL2
              });
            } else {
              setRoutes({
                isLoaded: false,
                status: 404,
                routes: []
              });
            }
          });
          break;
        }
        case "dx":
        case "jdx": {
          setDashBoardType("single");
          setRoutes({
            isLoaded: true,
            status: 200,
            path: sampleURL
          });
          break;
        }
      }
    } else {
      setDashBoardType("multi");
      setRoutes({
        isLoaded: true,
        status: 200,
        routes,
        baseURL: "./"
      });
    }
  }, [href]);
  return !data.isLoaded ? /* @__PURE__ */ jsx$1("div", {
    style: styles$1h.bodyContainer,
    children: /* @__PURE__ */ jsx$1("div", {
      style: __spreadValues(__spreadValues({}, styles$1h.container), data.status === 200 ? styles$1h.normal : styles$1h.error),
      children: data.status === 200 ? /* @__PURE__ */ jsxs$1("div", {
        children: [/* @__PURE__ */ jsx$1("p", {
          style: styles$1h.normalHeader,
          children: "Please wait"
        }), /* @__PURE__ */ jsx$1("p", {
          children: "We will redirect you in a minute"
        })]
      }) : /* @__PURE__ */ jsxs$1("div", {
        children: [/* @__PURE__ */ jsx$1("p", {
          style: styles$1h.errorHeader,
          children: "404"
        }), /* @__PURE__ */ jsx$1("p", {
          children: "Resource not found."
        }), /* @__PURE__ */ jsx$1("button", {
          style: styles$1h.loadButton,
          type: "button",
          onClick: loadHandler,
          children: "Load local samples"
        })]
      })
    })
  }) : dashBoardType && dashBoardType === "single" ? /* @__PURE__ */ jsx$1(SingleDisplayerLayout, __spreadProps(__spreadValues({}, props), {
    path: data.path
  })) : /* @__PURE__ */ jsx$1(Dashboard, __spreadProps(__spreadValues({}, props), {
    routes: data.routes,
    baseURL: data.baseURL
  }));
};
function checkModifierKeyActivated(event) {
  const modifiersKeys = [
    "Alt",
    "AltGraph",
    "CapsLock",
    "Control",
    "Meta",
    "NumLocK",
    "ScrollLock",
    "Shift",
    "OS"
  ];
  for (const key of modifiersKeys) {
    if (event.getModifierState(key)) {
      return true;
    }
  }
  return false;
}
const MAX_LENGTH = 2048;
function detectSignal(x, re, from, to, frequency) {
  const { fromIndex, toIndex } = xGetFromToIndex(x, {
    from,
    to
  });
  if (toIndex - fromIndex <= MAX_LENGTH) {
    const data = {
      x: x.subarray(fromIndex, toIndex),
      y: re.subarray(fromIndex, toIndex)
    };
    const result = analyseMultiplet(data, {
      frequency,
      takeBestPartMultiplet: true,
      symmetrizeEachStep: true
    });
    if (result && result.chemShift === void 0)
      return;
    return {
      multiplicity: result.js.map((j) => j.multiplicity).join(""),
      kind: "signal",
      delta: result.chemShift,
      js: result.js
    };
  } else {
    throw new Error(`length of signal should not exceed ${MAX_LENGTH} points`);
  }
}
const initialState$1 = {
  step: "initial",
  brush: {
    start: null,
    end: null
  },
  startX: 0,
  endX: 0,
  startY: 0,
  endY: 0
};
const BrushContext = react.exports.createContext(initialState$1);
function BrushTracker({
  children,
  className,
  style: style2,
  onBrush = () => null,
  onZoom = () => null,
  onDoubleClick = () => null,
  onClick = () => null,
  noPropagation
}) {
  const [state, dispatch] = react.exports.useReducer(reducer$1, initialState$1);
  const [mouseDownTime, setMouseDownTime] = react.exports.useState(0);
  const debounceClickEventsRef = react.exports.useRef([]);
  const mouseDownHandler = react.exports.useCallback((event) => {
    if (event.button === 0) {
      if (noPropagation) {
        event.stopPropagation();
      }
      dispatch({
        type: "DOWN",
        shiftKey: event.shiftKey,
        altKey: event.altKey,
        screenX: event.screenX,
        screenY: event.screenY,
        clientX: event.clientX,
        clientY: event.clientY,
        boundingRect: event.currentTarget.getBoundingClientRect()
      });
      setMouseDownTime(event.timeStamp);
    }
    return false;
  }, [noPropagation]);
  const clickHandler = react.exports.useCallback((e2) => {
    e2.persist();
    const timeStamp = e2.timeStamp;
    const boundingRect = e2.currentTarget.getBoundingClientRect();
    const x = e2.clientX - boundingRect.x;
    const y = e2.clientY - boundingRect.y;
    const callback = debounce_1(() => {
      if (timeStamp - mouseDownTime <= 150 && debounceClickEventsRef.current.length === 1) {
        onClick(__spreadProps(__spreadValues({}, e2), {
          x,
          y
        }));
      }
      debounceClickEventsRef.current = [];
    }, 200);
    debounceClickEventsRef.current.push(callback);
    callback();
    if (debounceClickEventsRef.current.length > 1) {
      map_1(debounceClickEventsRef.current, (debounce) => debounce.cancel());
      debounceClickEventsRef.current = [];
      onDoubleClick(__spreadProps(__spreadValues({}, e2), {
        x,
        y
      }));
    }
  }, [mouseDownTime, onClick, onDoubleClick]);
  const handleMouseWheel = react.exports.useCallback((event) => {
    const boundingRect = event.currentTarget.getBoundingClientRect();
    const x = event.clientX - boundingRect.x;
    const y = event.clientY - boundingRect.y;
    const {
      deltaY,
      deltaX,
      shiftKey,
      deltaMode
    } = event;
    onZoom({
      deltaY: deltaY || deltaX,
      shiftKey,
      deltaMode,
      x,
      y
    });
  }, [onZoom]);
  react.exports.useEffect(() => {
    const {
      step,
      startX,
      endX,
      startY,
      endY
    } = state;
    if (step === "end" && Math.hypot(endX - startX, endY - startY) > 5) {
      onBrush(state);
      dispatch({
        type: "DONE"
      });
    }
  }, [onBrush, state]);
  const moveCallback = react.exports.useCallback((event) => {
    dispatch({
      type: "MOVE",
      screenX: event.screenX,
      screenY: event.screenY,
      clientX: event.clientX,
      clientY: event.clientY
    });
  }, []);
  const upCallback = react.exports.useCallback((event) => {
    dispatch({
      type: "UP",
      clientX: event.clientX,
      clientY: event.clientY
    });
    return false;
  }, []);
  return /* @__PURE__ */ jsx$1(BrushContext.Provider, {
    value: state,
    children: /* @__PURE__ */ jsx$1("div", {
      className,
      style: style2,
      onMouseDown: mouseDownHandler,
      onMouseUp: upCallback,
      onMouseMove: moveCallback,
      onClick: clickHandler,
      onWheel: handleMouseWheel,
      children
    })
  });
}
function reducer$1(state, action) {
  switch (action.type) {
    case "UP":
      if (state.step === "brushing" || state.step === "start") {
        const {
          clientX,
          clientY
        } = action;
        return __spreadProps(__spreadValues({}, state), {
          endX: clientX - state.boundingRect.x,
          endY: clientY - state.boundingRect.y,
          step: state.step === "start" ? "initial" : "end"
        });
      }
      return state;
    case "DOWN":
      if (state.step === "initial" || state.step === "end") {
        const {
          screenX,
          screenY,
          clientX,
          clientY,
          boundingRect,
          shiftKey,
          altKey
        } = action;
        const x = clientX - boundingRect.x;
        const y = clientY - boundingRect.y;
        return __spreadProps(__spreadValues({}, state), {
          shiftKey,
          altKey,
          startX: x,
          startY: y,
          startScreenX: screenX,
          startScreenY: screenY,
          startClientX: clientX,
          startClientY: clientY,
          boundingRect,
          step: "start"
        });
      }
      return state;
    case "MOVE":
      if (state.step === "start" || state.step === "brushing") {
        const {
          clientX,
          clientY
        } = action;
        return __spreadProps(__spreadValues({}, state), {
          step: "brushing",
          endX: clientX - state.boundingRect.x,
          endY: clientY - state.boundingRect.y
        });
      }
      return state;
    case "DONE":
      if (state.step === "end") {
        return __spreadProps(__spreadValues({}, state), {
          step: "initial"
        });
      }
      break;
    default:
      return state;
  }
}
const MouseContext = react.exports.createContext({});
const MouseaProvider = MouseContext.Provider;
function useMouseTracker() {
  return react.exports.useContext(MouseContext);
}
function MouseTracker({
  children,
  className,
  style: style2,
  noPropagation
}) {
  const [mouseTrackerState, setMouseTrackerState] = react.exports.useState(null);
  const mouseMoveHandler = react.exports.useCallback((e2) => {
    const boundingRect = e2.currentTarget.getBoundingClientRect();
    const x = e2.clientX - boundingRect.x;
    const y = e2.clientY - boundingRect.y;
    setMouseTrackerState({
      x,
      y
    });
    if (noPropagation) {
      e2.stopPropagation();
    }
  }, [noPropagation]);
  const mouseLeaveHandler = react.exports.useCallback((e2) => {
    setMouseTrackerState(null);
    if (noPropagation) {
      e2.stopPropagation();
    }
  }, [noPropagation]);
  return /* @__PURE__ */ jsx$1(MouseaProvider, {
    value: mouseTrackerState,
    children: /* @__PURE__ */ jsx$1("div", {
      className,
      style: style2,
      onMouseMove: mouseMoveHandler,
      onMouseLeave: mouseLeaveHandler,
      children
    })
  });
}
const SignalKinds = [
  {
    key: "signal",
    label: "Signal",
    value: "signal"
  },
  {
    key: "reference",
    label: "Reference",
    value: "reference"
  },
  {
    key: "solvent",
    label: "Solvent",
    value: "solvent"
  },
  {
    key: "impurity",
    label: "Impurity",
    value: "impurity"
  },
  {
    key: "standard",
    label: "Standard",
    value: "standard"
  },
  {
    key: "p1",
    label: "P1",
    value: "p1"
  },
  {
    key: "p2",
    label: "P2",
    value: "p2"
  },
  {
    key: "p3",
    label: "P3",
    value: "p3"
  }
];
const SignalKindsToInclude = ["signal"];
const DatumKind = { signal: "signal", mixed: "mixed" };
const id$g = "absolute";
const name$g = "Absolute";
function apply$g(datum1D) {
  if (!isApplicable$g(datum1D)) {
    throw new Error("absolute not applicable on this data");
  }
  datum1D.data.re = reimAbsolute(datum1D.data);
  datum1D.data.im = new Float64Array(0);
  datum1D.info = __spreadProps(__spreadValues({}, datum1D.info), { isComplex: false });
}
function isApplicable$g(datum1D) {
  if (datum1D.info.isComplex && !datum1D.info.isFid)
    return true;
  return false;
}
function reduce$g() {
  return {
    once: false,
    reduce: null
  };
}
var absolute = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  id: id$g,
  name: name$g,
  apply: apply$g,
  isApplicable: isApplicable$g,
  reduce: reduce$g
}, Symbol.toStringTag, { value: "Module" }));
const id$f = "autoPhaseCorrection";
const name$f = "Automatic phase correction";
const defaultOptions = {
  minRegSize: 5,
  maxDistanceToJoin: 128,
  magnitudeMode: true,
  factorNoise: 5
};
function apply$f(datum1D, options2 = {}) {
  if (!isApplicable$f(datum1D)) {
    throw new Error("phaseCorrection not applicable on this data");
  }
  return reimAutoPhaseCorrection(datum1D.data, __spreadValues(__spreadValues({}, defaultOptions), options2));
}
function isApplicable$f(datum1D) {
  if (datum1D.info.isComplex && !datum1D.info.isFid)
    return true;
  return false;
}
function reduce$f(previousValue, newValue) {
  let reduced = Object.assign({}, previousValue);
  for (const k in reduced) {
    reduced[k] += newValue[k];
  }
  return {
    once: true,
    reduce: reduced
  };
}
var autoPhaseCorrection = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  id: id$f,
  name: name$f,
  apply: apply$f,
  isApplicable: isApplicable$f,
  reduce: reduce$f
}, Symbol.toStringTag, { value: "Module" }));
const id$e = "baselineCorrection";
const name$e = "Baseline correction";
const baselineAlgorithms = {
  airpls: "airPLS",
  polynomial: "Polynomial"
};
function apply$e(datum1D, options2 = {}) {
  if (!isApplicable$e(datum1D)) {
    throw new Error("baselineCorrection not applicable on this data");
  }
  const { algorithm, zones = [] } = options2;
  let { x, re } = datum1D.data;
  let corrected;
  switch (algorithm) {
    case "airpls":
      corrected = airPLS(x, re, options2).corrected;
      break;
    case "polynomial":
      {
        const baselineOptions = {
          regressionOptions: options2.degree
        };
        let reduced = equallySpaced$1({ x, y: re }, { numberOfPoints: 4096, zones });
        let result = baselineCorrectionRegression(reduced.x, reduced.y, baselineOptions);
        let { regression } = result;
        corrected = new Float64Array(x.length);
        for (let i = 0; i < re.length; i++) {
          corrected[i] = re[i] - regression.predict(x[i]);
        }
      }
      break;
    default:
      throw new Error(`baselineCorrection: algorithm unknown: ${algorithm}`);
  }
  Object.assign(datum1D.data, { re: corrected });
}
function isApplicable$e(datum1D) {
  if (!datum1D.info.isFid)
    return true;
  return false;
}
function reduce$e() {
  return {
    once: false,
    reduce: null
  };
}
var baselineCorrection = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  id: id$e,
  name: name$e,
  baselineAlgorithms,
  apply: apply$e,
  isApplicable: isApplicable$e,
  reduce: reduce$e
}, Symbol.toStringTag, { value: "Module" }));
const id$d = "centerMean";
const name$d = "Center Mean";
function apply$d(datum1D) {
  var _a;
  if (!isApplicable$d(datum1D)) {
    throw new Error("Center Mean is not applicable on this data");
  }
  const re = datum1D.data.re.slice(0);
  const im = (_a = datum1D.data.im) == null ? void 0 : _a.slice(0);
  const reMean = array.mean(re);
  const imMean = array.mean(im || []);
  for (let i = 0; i < re.length; i++) {
    re[i] -= reMean;
    if (im) {
      im[i] -= imMean;
    }
  }
  datum1D.data.re = re;
  if (im) {
    datum1D.data.im = im;
  }
}
function isApplicable$d(datum1D) {
  if (datum1D.info.isComplex && !datum1D.info.isFid)
    return true;
  return false;
}
function reduce$d() {
  return {
    once: false,
    reduce: null
  };
}
var centerMean = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  id: id$d,
  name: name$d,
  apply: apply$d,
  isApplicable: isApplicable$d,
  reduce: reduce$d
}, Symbol.toStringTag, { value: "Module" }));
const id$c = "digitalFilter";
const name$c = "Digital Filter";
function apply$c(datum1D, options2 = {}) {
  if (!isApplicable$c(datum1D)) {
    throw new Error("Digital Filter is not applicable on this data");
  }
  let { digitalFilterValue = 0 } = options2;
  let re = new Float64Array(datum1D.data.re);
  let im = new Float64Array(datum1D.data.im);
  let pointsToShift = Math.floor(digitalFilterValue);
  const skip = 0;
  pointsToShift += 0;
  const newRe = new Float64Array(re.length);
  const newIm = new Float64Array(im.length);
  newRe.set(re.slice(pointsToShift));
  newRe.set(re.slice(skip, pointsToShift), re.length - pointsToShift);
  newIm.set(im.slice(pointsToShift));
  newIm.set(im.slice(skip, pointsToShift), im.length - pointsToShift);
  datum1D.data.re = newRe;
  datum1D.data.im = newIm;
}
function isApplicable$c(datum1D) {
  if (datum1D.info.isComplex && datum1D.info.isFid)
    return true;
  return false;
}
function reduce$c() {
  return {
    once: true,
    reduce: void 0
  };
}
var digitalFilter = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  id: id$c,
  name: name$c,
  apply: apply$c,
  isApplicable: isApplicable$c,
  reduce: reduce$c
}, Symbol.toStringTag, { value: "Module" }));
const id$b = "equallySpaced";
const name$b = "Equally Spaced";
function apply$b(datum1D, options2 = {}) {
  if (!isApplicable$b(datum1D)) {
    throw new Error("Equally Spaced is not applicable on this data");
  }
  const { from, to, numberOfPoints, exclusions } = options2;
  const { x, re, im } = datum1D.data;
  const XREdata = equallySpaced$1({ x, y: re }, { from, to, numberOfPoints, exclusions });
  datum1D.data.x = XREdata.x;
  datum1D.data.re = XREdata.y;
  if (im) {
    const XIMdata = equallySpaced$1({ x, y: re }, { from, to, numberOfPoints, exclusions });
    datum1D.data.im = XIMdata.y;
  }
}
function isApplicable$b(datum1D) {
  if (datum1D.info.isComplex && !datum1D.info.isFid)
    return true;
  return false;
}
function reduce$b() {
  return {
    once: false,
    reduce: null
  };
}
var equallySpaced = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  id: id$b,
  name: name$b,
  apply: apply$b,
  isApplicable: isApplicable$b,
  reduce: reduce$b
}, Symbol.toStringTag, { value: "Module" }));
const id$a = "exclusionZones";
const name$a = "Exclusion Zones";
function apply$a(datum1D, zones = []) {
  if (!isApplicable$a(datum1D)) {
    throw new Error("Exclusion Zones filter not applicable on this data");
  }
  const { x, re, im } = datum1D.data;
  datum1D.data.re = xySetYValue({ x, y: re }, { zones }).y;
  datum1D.data.im = im ? xySetYValue({ x, y: re }, { zones }) : im;
}
function isApplicable$a(datum1D) {
  if (datum1D.info.isComplex && datum1D.info.isFt)
    return true;
  return false;
}
function reduce$a(previousValue, newValue) {
  return {
    once: true,
    reduce: zonesNormalize(previousValue.concat(newValue))
  };
}
var exclusionZones = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  id: id$a,
  name: name$a,
  apply: apply$a,
  isApplicable: isApplicable$a,
  reduce: reduce$a
}, Symbol.toStringTag, { value: "Module" }));
const id$9 = "fft";
const name$9 = "FFT";
function apply$9(datum1D) {
  if (!isApplicable$9(datum1D)) {
    throw new Error("fft not applicable on this data");
  }
  let digitalFilterApplied = datum1D.filters.some((e2) => e2.name === "digitalFilter" && e2.flag);
  Object.assign(datum1D.data, reimFFT(datum1D.data, { applyZeroShift: true }));
  if (digitalFilterApplied) {
    let { digitalFilter: digitalFilter2 } = datum1D.info;
    let ph1 = (digitalFilter2 - Math.floor(digitalFilter2)) * Math.PI * 2;
    Object.assign(datum1D.data, reimPhaseCorrection(datum1D.data, 0, ph1));
  }
  datum1D.data.x = generateXAxis(datum1D);
  datum1D.info = __spreadProps(__spreadValues({}, datum1D.info), { isFid: false, isFt: true });
}
function isApplicable$9(datum1D) {
  if (datum1D.info.isComplex && datum1D.info.isFid)
    return true;
  return false;
}
function reduce$9() {
  return {
    once: true,
    reduce: void 0
  };
}
function generateXAxis(datum1D) {
  const info = datum1D.info;
  const baseFrequency = parseFloat(info.baseFrequency);
  const frequencyOffset = parseFloat(info.frequencyOffset);
  const spectralWidth = parseFloat(info.spectralWidth);
  const offset = frequencyOffset / baseFrequency;
  let spectralHalfWidth = 0.5 * spectralWidth;
  let nbPoints = datum1D.data.x.length;
  let firstPoint = offset - spectralHalfWidth;
  let dx = spectralWidth / (nbPoints - 1);
  const xAxis = new Float32Array(nbPoints);
  for (let i = 0; i < nbPoints; i++) {
    xAxis[i] = firstPoint;
    firstPoint += dx;
  }
  return xAxis;
}
var fft = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  id: id$9,
  name: name$9,
  apply: apply$9,
  isApplicable: isApplicable$9,
  reduce: reduce$9
}, Symbol.toStringTag, { value: "Module" }));
const id$8 = "fromTo";
const name$8 = "From/To";
function apply$8(datum1D, options2 = {}) {
  if (!isApplicable$8(datum1D)) {
    throw new Error("From/To filter not applicable on this data");
  }
  const { x, re, im } = datum1D.data;
  const { from, to } = options2;
  const { fromIndex, toIndex } = xGetFromToIndex(x, { from, to });
  datum1D.data.x = x.slice(fromIndex, toIndex);
  datum1D.data.re = re.slice(fromIndex, toIndex);
  if (im) {
    datum1D.data.im = im.slice(fromIndex, toIndex);
  }
}
function isApplicable$8(datum1D) {
  if (datum1D.info.isComplex && !datum1D.info.isFid)
    return true;
  return false;
}
function reduce$8(previousValue, newValue) {
  return {
    once: true,
    reduce: newValue
  };
}
var fromTo = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  id: id$8,
  name: name$8,
  apply: apply$8,
  isApplicable: isApplicable$8,
  reduce: reduce$8
}, Symbol.toStringTag, { value: "Module" }));
const id$7 = "lineBroadening";
const name$7 = "Line broadening";
function apply$7(datum1D, value) {
  if (!isApplicable$7(datum1D)) {
    throw new Error("lineBroadening not applicable on this data");
  }
  let grpdly = datum1D.info.digitalFilter;
  let pointsToShift;
  if (grpdly > 0) {
    pointsToShift = Math.floor(grpdly);
  } else {
    pointsToShift = 0;
  }
  const re = datum1D.data.re;
  const im = datum1D.data.im;
  const t = datum1D.data.x;
  const length = re.length;
  const newRE = new Float64Array(length);
  const newIM = new Float64Array(length);
  const dw = (t[length - 1] - t[0]) / (length - 1);
  const em = -value * Math.exp(1);
  const coefExp = Math.exp(em * dw);
  let curFactor = Math.exp(em * t[0]);
  for (let i = 0; i < length - pointsToShift; i++) {
    newRE[i] = re[i] * curFactor;
    newIM[i] = im[i] * curFactor;
    curFactor = curFactor * coefExp;
  }
  curFactor = Math.exp(em * t[0]);
  for (let i = length; i > length - pointsToShift; i--) {
    newRE[i] = re[i] * curFactor;
    newIM[i] = im[i] * curFactor;
    curFactor = curFactor * coefExp;
  }
  datum1D.data = __spreadValues(__spreadValues({}, datum1D.data), { re: newRE, im: newIM });
}
function isApplicable$7(datum1D) {
  if (datum1D.info.isComplex && datum1D.info.isFid)
    return true;
  return false;
}
function reduce$7(previousValue, newValue) {
  return {
    once: true,
    reduce: previousValue + newValue
  };
}
var lineBroadening = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  id: id$7,
  name: name$7,
  apply: apply$7,
  isApplicable: isApplicable$7,
  reduce: reduce$7
}, Symbol.toStringTag, { value: "Module" }));
const id$6 = "pareto";
const name$6 = "Pareto";
function apply$6(datum1D) {
  var _a;
  if (!isApplicable$6(datum1D)) {
    throw new Error("Pareto is not applicable on this data");
  }
  const re = datum1D.data.re.slice(0);
  const im = (_a = datum1D.data.im) == null ? void 0 : _a.slice(0);
  datum1D.data.re = xParetoNormalization(re);
  if (im) {
    datum1D.data.im = xParetoNormalization(im);
  }
}
function isApplicable$6(datum1D) {
  if (datum1D.info.isComplex && !datum1D.info.isFid)
    return true;
  return false;
}
function reduce$6() {
  return {
    once: false,
    reduce: null
  };
}
var pareto = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  id: id$6,
  name: name$6,
  apply: apply$6,
  isApplicable: isApplicable$6,
  reduce: reduce$6
}, Symbol.toStringTag, { value: "Module" }));
const id$5 = "phaseCorrection";
const name$5 = "Phase correction";
function apply$5(datum1D, options2 = {}) {
  if (!isApplicable$5(datum1D)) {
    throw new Error("phaseCorrection not applicable on this data");
  }
  let { ph0, ph1 } = options2;
  ph0 *= Math.PI / 180;
  ph1 *= Math.PI / 180;
  Object.assign(datum1D.data, reimPhaseCorrection(datum1D.data, ph0, ph1));
}
function isApplicable$5(datum1D) {
  if (datum1D.info.isComplex && !datum1D.info.isFid)
    return true;
  return false;
}
function reduce$5(previousValue, newValue) {
  return {
    once: true,
    reduce: newValue
  };
}
var phaseCorrection = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  id: id$5,
  name: name$5,
  apply: apply$5,
  isApplicable: isApplicable$5,
  reduce: reduce$5
}, Symbol.toStringTag, { value: "Module" }));
const id$4 = "shiftX";
const name$4 = "Shift X";
function apply$4(datum1D, shiftValue = 0) {
  datum1D.data.x = datum1D.data.x.map((val) => val + shiftValue);
}
function isApplicable$4() {
  return true;
}
function reduce$4(previousValue, newValue) {
  return {
    once: true,
    reduce: previousValue + newValue
  };
}
var shiftX$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  id: id$4,
  name: name$4,
  apply: apply$4,
  isApplicable: isApplicable$4,
  reduce: reduce$4
}, Symbol.toStringTag, { value: "Module" }));
const id$3 = "standardDeviation";
const name$3 = "Standard Deviation";
function apply$3(datum1D) {
  var _a;
  if (!isApplicable$3(datum1D)) {
    throw new Error("Standard Deviation is not applicable on this data");
  }
  const re = datum1D.data.re.slice(0);
  const im = (_a = datum1D.data.im) == null ? void 0 : _a.slice(0);
  const reStd = array.standardDeviation(re);
  const imStd = array.standardDeviation(im || []);
  for (let i = 0; i < re.length; i++) {
    re[i] /= reStd;
    if (im) {
      im[i] /= imStd;
    }
  }
  datum1D.data.re = re;
  if (im) {
    datum1D.data.im = im;
  }
}
function isApplicable$3(datum1D) {
  if (datum1D.info.isComplex && !datum1D.info.isFid)
    return true;
  return false;
}
function reduce$3() {
  return {
    once: false,
    reduce: null
  };
}
var standardDeviation = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  id: id$3,
  name: name$3,
  apply: apply$3,
  isApplicable: isApplicable$3,
  reduce: reduce$3
}, Symbol.toStringTag, { value: "Module" }));
const id$2 = "zeroFilling";
const name$2 = "Zero Filling";
function apply$2(datum1D, size) {
  if (!isApplicable$2(datum1D)) {
    throw new Error("zeroFilling not applicable on this data");
  }
  let digitalFilterApplied = datum1D.filters.some((e2) => e2.name === "digitalFilter" && e2.flag);
  let grpdly = datum1D.info.digitalFilter;
  let pointsToShift;
  if (grpdly > 0 && digitalFilterApplied) {
    pointsToShift = Math.floor(grpdly);
  } else {
    pointsToShift = 0;
  }
  const { re, im, x } = datum1D.data;
  let newRE = new Float64Array(size);
  let newIM = new Float64Array(size);
  let newX = new Float64Array(size);
  const length = Math.min(size, re.length);
  newRE.set(re.slice(0, length - pointsToShift));
  newIM.set(im.slice(0, length - pointsToShift));
  newX.set(x.slice(0, length - pointsToShift));
  let diff = x[1] - x[0];
  let currentX = x[length - pointsToShift - 1];
  for (let i = length - pointsToShift; i < size; i++) {
    currentX += diff;
    newX[i] = currentX;
  }
  if (pointsToShift > 0 && pointsToShift < size) {
    newRE.set(re.slice(re.length - pointsToShift), size - pointsToShift);
    newIM.set(im.slice(re.length - pointsToShift), size - pointsToShift);
  }
  datum1D.data = __spreadValues(__spreadValues({}, datum1D.data), { re: newRE, im: newIM, x: newX });
}
function isApplicable$2(datum1D) {
  if (datum1D.info.isComplex && datum1D.info.isFid)
    return true;
  return false;
}
function reduce$2(_previousValue, newValue) {
  return {
    once: true,
    reduce: newValue
  };
}
var zeroFilling = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  id: id$2,
  name: name$2,
  apply: apply$2,
  isApplicable: isApplicable$2,
  reduce: reduce$2
}, Symbol.toStringTag, { value: "Module" }));
const id$1 = "shift2DX";
const name$1 = "Shift 2D X";
function apply$1(datum2D, shiftValue = 0) {
  datum2D.data.minX += shiftValue;
  datum2D.data.maxX += shiftValue;
}
function isApplicable$1() {
  return true;
}
function reduce$1(previousValue, newValue) {
  return {
    once: true,
    reduce: previousValue + newValue
  };
}
var shiftX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  id: id$1,
  name: name$1,
  apply: apply$1,
  isApplicable: isApplicable$1,
  reduce: reduce$1
}, Symbol.toStringTag, { value: "Module" }));
const id = "shift2DY";
const name = "Shift 2D Y";
function apply(datum2D, shiftValue = 0) {
  datum2D.data.minY += shiftValue;
  datum2D.data.maxY += shiftValue;
}
function isApplicable() {
  return true;
}
function reduce(previousValue, newValue) {
  return {
    once: true,
    reduce: previousValue + newValue
  };
}
var shiftY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  id,
  name,
  apply,
  isApplicable,
  reduce
}, Symbol.toStringTag, { value: "Module" }));
var Filters = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  absolute,
  baselineCorrection,
  lineBroadening,
  fft,
  phaseCorrection,
  autoPhaseCorrection,
  shiftX: shiftX$1,
  zeroFilling,
  digitalFilter,
  fromTo,
  equallySpaced,
  standardDeviation,
  centerMean,
  pareto,
  exclusionZones,
  shift2DX: shiftX,
  shift2DY: shiftY
}, Symbol.toStringTag, { value: "Module" }));
const BASE62 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
const LENGTH = 8;
function generateID() {
  let id2 = "";
  for (let i = 0; i < LENGTH; i++) {
    id2 += BASE62.charAt(Math.floor(Math.random() * 62));
  }
  return id2;
}
function applyFilter(datum, filters = []) {
  let isReduced = false;
  for (let filter2 of filters) {
    const filterOption = {
      name: filter2.name,
      label: Filters[filter2.name].name,
      value: filter2.options
    };
    const previousFilter = lookupForFilter(datum, filter2.name);
    if (previousFilter) {
      const reduceResult = Filters[filter2.name].reduce(previousFilter.value, filterOption.value);
      if (reduceResult.once) {
        if (!isReduced) {
          isReduced = true;
        }
        if (reduceResult.reduce != null && reduceResult.reduce !== void 0) {
          replaceFilter(datum, previousFilter.id, reduceResult.reduce);
        }
      } else {
        addFilter(datum, filterOption, Object.prototype.hasOwnProperty.call(filter2, "isDeleteAllow") ? filter2.isDeleteAllow : true);
      }
    } else {
      addFilter(datum, filterOption, Object.prototype.hasOwnProperty.call(filter2, "isDeleteAllow") ? filter2.isDeleteAllow : true);
    }
  }
  if (isReduced) {
    if (filters.length === 1 && isLastFilter(datum, filters[0].name)) {
      Filters[filters[0].name].apply(datum, filters[0].options);
    } else {
      reapplyFilters(datum);
    }
  } else {
    for (let filter2 of filters) {
      Filters[filter2.name].apply(datum, filter2.options);
    }
  }
}
function isLastFilter(datum, id2) {
  const index2 = datum.filters.findIndex((f) => f.name === id2);
  if (datum.filters.length === index2 + 1) {
    return true;
  }
  return false;
}
function lookupForFilter(datum, filterName) {
  return datum.filters.find((f) => f.name === filterName);
}
function reapplyFilters(datum, filters = null) {
  const _filters = filters ? filters : datum.filters;
  enableFilter$1(datum, null, null, _filters);
}
function enableFilter$1(datum, id2, checked, filters = null) {
  datum.filters = datum.filters.slice(0);
  if (id2) {
    datum.filters = datum.filters.map((filter2) => {
      return __spreadProps(__spreadValues({}, filter2), { flag: filter2.id === id2 ? checked : filter2.flag });
    }, []);
  }
  datum.data = __spreadValues(__spreadValues({}, datum.data), datum.originalData);
  datum.info = __spreadValues(__spreadValues({}, datum.info), datum.originalInfo);
  const _filters = filters ? filters : datum.filters;
  for (let filterIndex in _filters) {
    const filter2 = datum.filters[filterIndex];
    datum.filters[filterIndex] = __spreadProps(__spreadValues({}, datum.filters[filterIndex]), {
      error: null
    });
    if (filter2.flag) {
      try {
        Filters[filter2.name].apply(datum, filter2.value);
      } catch (error) {
        datum.filters[filterIndex] = __spreadProps(__spreadValues({}, datum.filters[filterIndex]), {
          error: error.message
        });
      }
    }
  }
}
function deleteFilter$1(datum, id2) {
  datum.filters = datum.filters.slice(0);
  datum.filters = datum.filters.filter((filter2) => filter2.id !== id2);
  datum.data = __spreadValues(__spreadValues({}, datum.data), datum.originalData);
  datum.info = __spreadValues(__spreadValues({}, datum.info), datum.originalInfo);
  for (let filterIndex in datum.filters) {
    const filter2 = datum.filters[filterIndex];
    datum.filters[filterIndex] = __spreadProps(__spreadValues({}, datum.filters[filterIndex]), {
      error: null
    });
    if (filter2.flag) {
      try {
        Filters[filter2.name].apply(datum, filter2.value);
      } catch (error) {
        datum.filters[filterIndex] = __spreadProps(__spreadValues({}, datum.filters[filterIndex]), {
          error: error.message
        });
      }
    }
  }
}
function addFilter(datum, filter2, isDeleteAllow = true) {
  const id2 = generateID();
  datum.filters = datum.filters.slice(0);
  delete filter2.isSnapshot;
  datum.filters.push(__spreadProps(__spreadValues({}, filter2), {
    id: id2,
    flag: true,
    isDeleteAllow
  }));
}
function replaceFilter(datum, filterID, value) {
  datum.filters = datum.filters.slice(0);
  const index2 = datum.filters.findIndex((f) => f.id === filterID);
  delete datum.filters[index2].isSnapshot;
  datum.filters[index2] = __spreadProps(__spreadValues({}, datum.filters[index2]), {
    value
  });
}
const COLORS = [
  "#C10020",
  "#007D34",
  "#803E75",
  "#FF6800",
  "#B32851",
  "#7F180D",
  "#232C16",
  "#A6BDD7",
  "#CEA262",
  "#817066",
  "#FF8E00",
  "#F6768E",
  "#00538A",
  "#FF7A5C",
  "#53377A",
  "#FFB300",
  "#F4C800",
  "#93AA00",
  "#593315",
  "#F13A13"
];
const color2D = {
  cosy: { positiveColor: "darkblue", negativeColor: "blue" },
  roesy: { positiveColor: "#e75480", negativeColor: "yellow" },
  noesy: { positiveColor: "#e75480", negativeColor: "yellow" },
  tocsy: { positiveColor: "green", negativeColor: "yellow" },
  hsqc: { positiveColor: "black", negativeColor: "yellow" },
  hmbc: { positiveColor: "darkviolet", negativeColor: "yellow" }
};
function get2DColor(experiment, colors = []) {
  if (!color2D[experiment]) {
    const positiveColor = getColor$2(false, colors);
    const negativeColor = adjustAlpha(positiveColor, 50);
    return { positiveColor, negativeColor };
  }
  return color2D[experiment];
}
function percentToHex(p2) {
  const percent = Math.max(0, Math.min(100, p2));
  const intValue = Math.round(percent / 100 * 255);
  const hexValue = intValue.toString(16);
  return percent === 100 ? "" : hexValue.padStart(2, "0");
}
function adjustAlpha(color, factor) {
  return color + percentToHex(factor);
}
function getColor$2(isRandom = false, usedColors = [], opacity = 100) {
  const resetColors = COLORS.filter((c) => !usedColors.includes(c));
  if (resetColors.length > 0 && !isRandom) {
    return resetColors[0] + percentToHex(opacity);
  } else {
    const lum = -0.25;
    let hex = String(`#${Math.random().toString(16).slice(2, 8).toUpperCase()}`).replace(/[^0-9a-f]/gi, "");
    if (hex.length < 6) {
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    let rgb = "#";
    let c;
    for (let i = 0; i < 3; i++) {
      c = parseInt(hex.substr(i * 2, 2), 16);
      c = Math.round(Math.min(Math.max(0, c + c * lum), 255)).toString(16);
      rgb += `00${c}`.substr(c.length);
    }
    return rgb + percentToHex(opacity);
  }
}
function initiateIntegrals(options2) {
  return merge_1({
    values: [],
    options: {
      sum: void 0,
      isSumConstant: true,
      sumAuto: true
    }
  }, options2.integrals);
}
function getSpectrumErrorValue(datum) {
  const { x } = datum.data;
  return (x[x.length - 1] - x[0]) / 1e4;
}
function getShiftX(datum) {
  const filter2 = (datum == null ? void 0 : datum.filters) && (datum == null ? void 0 : datum.filters.find((filter22) => filter22.name === id$4));
  return (filter2 == null ? void 0 : filter2.flag) ? filter2.value : 0;
}
function checkPeak(peak, datum, error) {
  var _a;
  for (const { x } of ((_a = datum.peaks) == null ? void 0 : _a.values) || []) {
    if (Math.abs(peak.x - x) < error) {
      return true;
    }
  }
  return false;
}
function mapPeaks(peaks, datum) {
  const shiftX2 = getShiftX(datum);
  const error = getSpectrumErrorValue(datum);
  return peaks.reduce((acc, newPeak) => {
    if (checkPeak(newPeak, datum, error))
      return acc;
    acc.push({
      id: (newPeak == null ? void 0 : newPeak.id) || generateID(),
      originalX: newPeak.x - shiftX2,
      x: newPeak.x,
      y: newPeak.y,
      width: newPeak.width
    });
    return acc;
  }, []);
}
function initiatePeaks(options2, datum) {
  var _a;
  return merge_1({ values: [], options: {} }, options2.peaks, {
    values: mapPeaks(((_a = options2 == null ? void 0 : options2.peaks) == null ? void 0 : _a.values) || [], datum)
  });
}
function checkRange(range2, datum, error) {
  var _a;
  for (const { from, to } of ((_a = datum.ranges) == null ? void 0 : _a.values) || []) {
    if (Math.abs(range2.from - from) < error && Math.abs(range2.to - to) < error) {
      return true;
    }
  }
}
function mapRanges(ranges, datum) {
  const { x, re } = datum.data;
  const shiftX2 = getShiftX(datum);
  const error = getSpectrumErrorValue(datum);
  return ranges.reduce((acc, newRange) => {
    if (checkRange(newRange, datum, error))
      return acc;
    const absolute2 = xyIntegration({ x, y: re }, { from: newRange.from, to: newRange.to, reverse: true });
    const signals = newRange.signals.map((signal) => {
      const _a = signal, { kind = null, id: id2 } = _a, resSignal = __objRest(_a, ["kind", "id"]);
      return __spreadValues({
        kind: kind || "signal",
        id: id2 || generateID(),
        originDelta: signal.delta - shiftX2
      }, resSignal);
    });
    acc.push(__spreadProps(__spreadValues({}, newRange), {
      kind: (signals == null ? void 0 : signals[0].kind) || DatumKind.signal,
      originFrom: newRange.from - shiftX2,
      originTo: newRange.to - shiftX2,
      id: newRange.id || generateID(),
      absolute: absolute2,
      signals
    }));
    return acc;
  }, []);
}
function initiateRanges(options2, datum) {
  var _a;
  return merge_1({
    values: [],
    options: {
      sum: void 0,
      isSumConstant: true,
      sumAuto: true
    }
  }, options2.ranges, {
    values: mapRanges(((_a = options2 == null ? void 0 : options2.ranges) == null ? void 0 : _a.values) || [], datum)
  });
}
function initiateDatum1D(options2, usedColors = {}) {
  var _a;
  const datum = {};
  datum.id = options2.id || generateID();
  datum.source = Object.assign({
    jcampURL: null,
    file: {
      binary: null,
      name: "",
      extension: ""
    }
  }, options2.source);
  datum.display = Object.assign(__spreadProps(__spreadValues({
    name: ((_a = options2.display) == null ? void 0 : _a.name) ? options2.display.name : generateID()
  }, getColor$1(options2, usedColors)), {
    isVisible: true,
    isPeaksMarkersVisible: true,
    isRealSpectrumVisible: true
  }), options2.display);
  datum.info = Object.assign({
    nucleus: "1H",
    isFid: false,
    isComplex: false,
    dimension: 1
  }, options2.info);
  datum.originalInfo = datum.info;
  datum.meta = Object.assign({}, options2.meta);
  datum.data = Object.assign({
    x: [],
    re: [],
    im: []
  }, options2.data);
  datum.originalData = datum.data;
  datum.filters = Object.assign([], options2.filters);
  datum.peaks = initiatePeaks(options2, datum);
  datum.integrals = initiateIntegrals(options2);
  datum.ranges = initiateRanges(options2, datum);
  reapplyFilters(datum);
  preprocessing(datum);
  return datum;
}
function getColor$1(options2, usedColors) {
  var _a;
  let color = "black";
  if (((_a = options2 == null ? void 0 : options2.display) == null ? void 0 : _a.color) === void 0) {
    color = getColor$2(false, usedColors["1d"] || []);
  } else {
    color = options2.display.color;
  }
  if (usedColors["1d"]) {
    usedColors["1d"].push(color);
  }
  return { color };
}
function preprocessing(datum) {
  if (datum.info.isFid && datum.filters.findIndex((f) => f.name === id$c) === -1 && datum.info.digitalFilter) {
    applyFilter(datum, [
      {
        name: id$c,
        options: {
          digitalFilterValue: datum.info.digitalFilter
        },
        isDeleteAllow: false
      }
    ]);
  }
}
function generateSpectrumFromRanges(ranges, info, usedColors) {
  const { nucleus, solvent, name: name2 = null, frequency = 400 } = info;
  const { x, y } = rangesToXY(ranges, {
    frequency,
    nbPoints: 524288
  });
  const datum = initiateDatum1D({
    data: { x, im: null, re: y },
    display: { name: name2 },
    info: {
      nucleus,
      originFrequency: frequency,
      baseFrequency: frequency,
      pulseSequence: "",
      solvent,
      isFt: true
    }
  }, usedColors);
  datum.ranges.values = mapRanges(ranges, datum);
  return datum;
}
function generateSpectrumFromPublicationString(publicationString, usedColors) {
  const {
    ranges,
    experiment: { nucleus, solvent },
    parts
  } = resurrect(publicationString);
  return generateSpectrumFromRanges(ranges, { nucleus, solvent, name: parts[0] }, usedColors);
}
function get1DDataXY(spectrum) {
  const {
    display: { isRealSpectrumVisible },
    data: { x, re, im }
  } = spectrum;
  return { x, y: isRealSpectrumVisible ? re : im };
}
const REFERENCES = {
  "1H": {
    tms: {
      from: -0.1,
      to: 0.1,
      nbPeaks: 1,
      delta: 0
    },
    tsp: {
      from: -0.1,
      to: 0.1,
      nbPeaks: 1,
      delta: 0
    },
    glucose: {
      from: 5.18,
      to: 5.28,
      nbPeaks: 2,
      delta: 5.23
    }
  },
  "13C": {}
};
function getRange$2(options2 = {}) {
  const { nucleus = "1H", reference = "tms" } = options2;
  if (!REFERENCES[nucleus]) {
    throw new Error(`Nucleus not found: ${nucleus}`);
  }
  const info = REFERENCES[nucleus][reference.toLowerCase()];
  if (!info) {
    throw new Error(`Reference not found: ${reference}`);
  }
  return {
    from: info.delta - 0.05,
    to: info.delta + 0.05,
    delta: info.delta,
    nbPeaks: info.nbPeaks
  };
}
function getReferenceShift(datum1D, options2) {
  let { from, to, nbPeaks, targetX, reference } = options2;
  if (reference) {
    let data = getRange$2({ reference, nucleus: datum1D.nucleus });
    from = data.from;
    to = data.to;
    nbPeaks = data.nbPeaks;
    targetX = data.delta;
  }
  const { re, x } = datum1D.data;
  return xyCalibrate({ x, y: re }, { from, to }, { nbPeaks, targetX });
}
function xyCalibrate(data, range2 = {}, options2 = {}) {
  const {
    targetX = 0,
    nbPeaks = 1,
    gsd: gsdOptions = {
      minMaxRatio: 0.1,
      realTopDetection: true,
      smoothY: true,
      sgOptions: {
        windowSize: 7,
        polynomial: 3
      }
    }
  } = options2;
  let { from, to } = range2;
  if (from === void 0 || to === void 0)
    return 0;
  const fromIndex = xFindClosestIndex(data.x, from);
  const toIndex = xFindClosestIndex(data.x, to);
  const sliceddata = {
    x: data.x.slice(fromIndex, toIndex),
    y: data.y.slice(fromIndex, toIndex)
  };
  let peaks = gsd(sliceddata, gsdOptions).sort((a, b) => b.y - a.y).slice(0, nbPeaks);
  if (peaks.length === 0)
    return 0;
  const middle = mean(peaks.map((peak) => peak.x));
  return targetX - middle;
}
function changeIntegralsRelative(datum, newIntegral) {
  const index2 = datum.integrals.values.findIndex((integral) => integral.id === newIntegral.id);
  if (index2 !== -1) {
    const ratio = datum.integrals.values[index2].absolute / newIntegral.value;
    const { values, sum } = datum.integrals.values.reduce((acc, integral, index22) => {
      const newIntegralValue = integral.absolute / ratio;
      acc.sum += newIntegralValue;
      acc.values[index22] = __spreadProps(__spreadValues({}, integral), {
        integral: newIntegralValue
      });
      return acc;
    }, { values: [], sum: 0 });
    datum.integrals.values = values;
    datum.integrals.options = __spreadProps(__spreadValues({}, datum.integrals.options), {
      mf: void 0,
      moleculeKey: void 0,
      sumAuto: false,
      sum
    });
  }
}
function checkIntegralKind(integral) {
  return SignalKindsToInclude.includes(integral.kind);
}
function getSum$1(values, key, check = null) {
  return values.reduce((sum, current) => {
    return check && check(current) === true ? sum += Math.abs(current[key]) : sum;
  }, 0);
}
function updateRelatives(data, key, check, forceCalculateIntegral = false) {
  var _a;
  const { values, options: options2 } = data;
  const currentSum = getSum$1(values, "absolute", check);
  let factor = 0;
  if (options2.sum) {
    if (data.options.isSumConstant || forceCalculateIntegral) {
      factor = currentSum > 0 ? options2.sum / currentSum : 0;
    } else {
      if ((_a = data.values) == null ? void 0 : _a[0]) {
        const item = data.values[0];
        factor = (item[key] ? item[key] : options2.sum) / item.absolute;
      }
    }
  }
  data.values = data.values.map((value) => {
    return __spreadValues(__spreadValues({}, value), check(value) && {
      [key]: value.absolute * factor
    });
  });
  if (!data.options.isSumConstant && !forceCalculateIntegral) {
    data.options.sum = getSum$1(data.values, key, check);
  }
}
function updateIntegralsRelativeValues(datum, forceCalculateIntegral = false) {
  updateRelatives(datum.integrals, "integral", checkIntegralKind, forceCalculateIntegral);
}
function isSpectrum1D(spectrum) {
  return spectrum.info.dimension === 1;
}
function autoPeakPicking(datum1D, options2) {
  const {
    minMaxRatio,
    maxNumberOfPeaks,
    noiseFactor,
    lookNegative,
    windowFromIndex,
    windowToIndex
  } = options2;
  const noise = median(datum1D.data.re.map((y) => Math.abs(y)));
  let { re, x } = datum1D.data;
  if (windowFromIndex !== void 0 && windowToIndex !== void 0) {
    x = x.slice(windowFromIndex, windowToIndex);
    re = re.slice(windowFromIndex, windowToIndex);
  }
  let peaks = xyAutoPeaksPicking({ x, y: re }, {
    lookNegative,
    noiseLevel: noise * noiseFactor,
    minMaxRatio,
    realTopDetection: true,
    smoothY: false,
    sgOptions: { windowSize: 15, polynomial: 3 }
  });
  peaks.sort((a, b) => b.y - a.y);
  if (maxNumberOfPeaks < peaks.length)
    peaks = peaks.slice(0, maxNumberOfPeaks);
  return mapPeaks(peaks, datum1D);
}
function lookupPeak(data, options2) {
  const { from, to } = options2;
  let minIndex = data.x.findIndex((number) => number >= from);
  let maxIndex = data.x.findIndex((number) => number >= to) - 1;
  if (minIndex > maxIndex) {
    minIndex = maxIndex;
    maxIndex = minIndex;
  }
  const dataRange = data.re.slice(minIndex, maxIndex);
  if (dataRange && dataRange.length > 0) {
    const yValue = max(dataRange);
    const xIndex = dataRange.findIndex((value) => value === yValue);
    const xValue = data.x[minIndex + xIndex];
    return { x: xValue, y: yValue, xIndex: minIndex + xIndex };
  }
  return null;
}
function getAtom(nucleus) {
  return (nucleus == null ? void 0 : nucleus.replace(/[0-9]/g, "")) || "";
}
function initSumOptions(options2, params) {
  let newOptions = __spreadValues({}, options2);
  const { molecules, nucleus } = params;
  if (options2.sumAuto && Array.isArray(molecules) && molecules.length > 0) {
    const { mf, key } = molecules[0];
    newOptions = __spreadProps(__spreadValues({}, newOptions), { sumAuto: true, mf, moleculeKey: key });
  } else {
    const _a = newOptions, { mf, moleculeKey } = _a, resOptions = __objRest(_a, ["mf", "moleculeKey"]);
    newOptions = __spreadProps(__spreadValues({}, resOptions), { sumAuto: false });
  }
  if (!newOptions.sum) {
    newOptions.sum = getSum(newOptions.mf || null, nucleus);
  }
  return newOptions;
}
function getSum(mf, nucleus) {
  const defaultSum = 100;
  if (!mf || !nucleus)
    return defaultSum;
  const atom = getAtom(nucleus);
  const atoms = getAtoms(mf);
  return atoms[atom] ? atoms[atom] : defaultSum;
}
function setSumOptions(data, params) {
  const { nucleus, options: options2 } = params;
  if (options2.sumAuto) {
    const { mf, moleculeKey } = options2;
    const sum = getSum(mf, nucleus);
    data.options = __spreadProps(__spreadValues({}, data.options), { sumAuto: true, moleculeKey, mf, sum });
  } else {
    const _a = data.options, { mf, moleculeKey } = _a, resOptions = __objRest(_a, ["mf", "moleculeKey"]);
    data.options = __spreadProps(__spreadValues({}, resOptions), { sumAuto: false, sum: options2.sum });
  }
}
function getAtoms(mf) {
  const result = {};
  const data = mf.split(/(\d+)/);
  for (let i = 0; i < data.length - 1; i = i + 2) {
    result[data[i]] = Number(data[i + 1]);
  }
  return result;
}
function changeSpectraRelativeSum(draft, molKey, molecule) {
  const keys = ["ranges", "integrals"];
  for (const spectrum of draft.data) {
    if (isSpectrum1D(spectrum)) {
      for (const key of keys) {
        const { moleculeKey, mf, sumAuto } = spectrum[key].options;
        if ((molKey === moleculeKey || !moleculeKey && !mf) && sumAuto) {
          const options2 = molecule ? {
            mf: molecule.mf,
            moleculeKey: molecule.key
          } : {
            mf: void 0,
            moleculeKey: void 0
          };
          setSumOptions(spectrum[key], {
            nucleus: spectrum.info.nucleus,
            options: __spreadProps(__spreadValues({}, options2), { sumAuto: true, sum: void 0 })
          });
          updateRangesRelativeValues(spectrum, true);
          updateIntegralsRelativeValues(spectrum, true);
        }
      }
    }
  }
}
function getNbAtoms$1(range2, signalIndex) {
  if (signalIndex === void 0) {
    return range2.signals ? range2.signals.reduce((sum, signal) => signal.nbAtoms ? signal.nbAtoms + sum : sum, 0) : 0;
  }
  return range2.signals[signalIndex].nbAtoms || 0;
}
function setNbAtoms$1(range2, signalIndex) {
  range2.nbAtoms = getNbAtoms$1(range2, signalIndex);
  if (range2.nbAtoms === 0) {
    delete range2.nbAtoms;
  }
}
function resetDiaIDs$1(range2) {
  delete range2.diaIDs;
  delete range2.nbAtoms;
  range2.signals.forEach((_signal) => {
    delete _signal.diaIDs;
    delete _signal.nbAtoms;
  });
  delete range2.nbAtoms;
}
function unlink$1(range2, unlinkType = "both", options2 = {}) {
  switch (unlinkType) {
    case "both":
      resetDiaIDs$1(range2);
      break;
    case "range":
      delete range2.diaIDs;
      delete range2.nbAtoms;
      break;
    case "signal":
      delete range2.signals[options2.signalIndex].diaIDs;
      delete range2.signals[options2.signalIndex].nbAtoms;
      break;
  }
  setNbAtoms$1(range2);
  return range2;
}
function checkRangeKind$1(range2) {
  return range2.kind === DatumKind.signal;
}
function checkSignalKinds(range2, kinds) {
  return !range2.signals.some((_signal) => _signal.kind === void 0 || !kinds.includes(_signal.kind));
}
function unlinkInAssignmentData$1(assignmentData, ranges) {
  const ids = ranges.reduce((acc, range2) => {
    if (range2.id) {
      acc.push(range2.id);
    }
    if (range2.signals) {
      acc = acc.concat(range2.signals.map((signal) => signal.id, []));
    }
    return acc;
  }, []);
  assignmentData.dispatch({
    type: "REMOVE_ALL",
    payload: { id: ids, axis: "x" }
  });
}
function checkRangeKind(range2) {
  return range2.signals && checkSignalKinds(range2, SignalKindsToInclude);
}
function updateRangesRelativeValues(datum, forceCalculateIntegral = false) {
  updateRelatives(datum.ranges, "integration", checkRangeKind, forceCalculateIntegral);
}
function addRange(datum, options2) {
  const { from, to, molecules, nucleus } = options2;
  const { x, re } = datum.data;
  const absolute2 = xyIntegration({ x, y: re }, { from, to, reverse: true });
  const signal = detectSignal(x, re, from, to, datum.info.originFrequency);
  if (!signal)
    return;
  try {
    const range2 = {
      id: generateID(),
      from,
      to,
      absolute: absolute2,
      signals: [__spreadValues({ id: generateID() }, signal)],
      kind: DatumKind.signal,
      integration: 0
    };
    datum.ranges.options = initSumOptions(datum.ranges.options, {
      molecules,
      nucleus
    });
    datum.ranges.values = datum.ranges.values.concat(mapRanges([range2], datum));
    updateRangesRelativeValues(datum);
  } catch (e2) {
    throw new Error("Could not calculate the multiplicity");
  }
}
function changeRange(datum, range2) {
  const { from, to } = range2;
  const { x, re } = datum.data;
  const index2 = datum.ranges.values.findIndex((i) => i.id === range2.id);
  const absolute2 = xyIntegration({ x, y: re }, { from, to, reverse: true });
  if (index2 !== -1) {
    datum.ranges.values[index2] = __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, datum.ranges.values[index2]), {
      originFrom: from,
      originTo: to
    }), range2), {
      absolute: absolute2
    });
    updateRangesRelativeValues(datum);
  }
}
function changeRangeRelativeValue(datum, newRange) {
  const index2 = datum.ranges.values.findIndex((range2) => range2.id === newRange.id);
  if (index2 !== -1 && datum.ranges.options.sum) {
    const { absolute: absolute2, integration } = datum.ranges.values[index2];
    const ratio = absolute2 / newRange.value;
    const sum = newRange.value / integration * datum.ranges.options.sum;
    datum.ranges.options = __spreadProps(__spreadValues({}, datum.ranges.options), {
      mf: void 0,
      moleculeKey: void 0,
      sumAuto: false,
      sum
    });
    datum.ranges.values = datum.ranges.values.map((range2) => {
      return __spreadProps(__spreadValues({}, range2), {
        integration: range2.absolute / ratio
      });
    });
  }
}
function changeRangeSignal(datum, options2) {
  const { rangeID, signalID, newSignalValue } = options2;
  let shiftValue = 0;
  const rangeIndex = datum.ranges.values.findIndex((range2) => range2.id === rangeID);
  if (rangeIndex !== -1) {
    const signalIndex = datum.ranges.values[rangeIndex].signals.findIndex((signal) => signal.id === signalID);
    shiftValue = newSignalValue - datum.ranges.values[rangeIndex].signals[signalIndex].delta;
    datum.ranges.values[rangeIndex].signals[signalIndex].delta = newSignalValue;
  }
  return shiftValue;
}
function detectRange(datum, options2) {
  const { from, to } = options2;
  const { x, re: y } = datum.data;
  const absolute2 = xyIntegration({ x, y }, { from, to, reverse: true });
  const min = xyMinYPoint({ x, y }, { from, to }).y;
  const max2 = xyMaxYPoint({ x, y }, { from, to }).y;
  const shiftX2 = getShiftX(datum);
  return {
    id: generateID(),
    originFrom: from - shiftX2,
    originTo: to - shiftX2,
    from,
    to,
    absolute: absolute2,
    min,
    max: max2
  };
}
const defaultPeakPickingOptions = {
  minMaxRatio: 1,
  realTopDetection: true,
  maxCriteria: true,
  smoothY: false,
  integrationSum: 100,
  factorStd: 5,
  clean: true,
  sgOptions: { windowSize: 7, polynomial: 3 }
};
function autoRangesDetection(datum1D, options2 = {}) {
  let { re, x } = datum1D.data;
  const { originFrequency, nucleus } = datum1D.info;
  const { windowFromIndex, windowToIndex, peakPicking } = options2;
  const peakPickingOptions = __spreadValues(__spreadValues({}, defaultPeakPickingOptions), peakPicking);
  const rangesOptions = {
    frequency: originFrequency,
    nucleus,
    compile: true,
    frequencyCluster: 13,
    keepPeaks: true
  };
  if (windowFromIndex !== void 0 && windowToIndex !== void 0) {
    x = x.slice(windowFromIndex, windowToIndex);
    re = re.slice(windowFromIndex, windowToIndex);
  }
  if (originFrequency) {
    let pointsPerHz = 1 / originFrequency / (x[1] - x[0]);
    let ws = Math.max(Math.round(pointsPerHz / 2), 5);
    peakPickingOptions.sgOptions = {
      windowSize: ws - ws % 2 + 1,
      polynomial: 3
    };
  }
  peakPickingOptions.smoothY = void 0;
  peakPickingOptions.sgOptions = void 0;
  const ranges = xyAutoRangesPicking({ x, y: re }, {
    peakPicking: peakPickingOptions,
    ranges: rangesOptions
  });
  return ranges;
}
function detectRanges(datum, options2) {
  const _a = options2, { molecules, nucleus } = _a, detectOptions = __objRest(_a, ["molecules", "nucleus"]);
  detectOptions.impurities = { solvent: datum.info.solvent || "" };
  const ranges = autoRangesDetection(datum, detectOptions);
  datum.ranges.options = initSumOptions(datum.ranges.options, {
    molecules,
    nucleus
  });
  datum.ranges.values = datum.ranges.values.concat(mapRanges(ranges, datum));
  updateRangesRelativeValues(datum);
}
function updateIntegralXShift(datum, shiftValue) {
  datum.integrals.values = datum.integrals.values.map((integral) => __spreadProps(__spreadValues({}, integral), {
    from: integral.originFrom + shiftValue,
    to: integral.originTo + shiftValue
  }));
}
function updatePeaksXShift(datum, shiftValue) {
  datum.peaks.values = datum.peaks.values.map((peak) => {
    const delta = peak.originalX + shiftValue;
    const xIndex = xFindClosestIndex(datum.data.x, delta);
    return __spreadProps(__spreadValues({}, peak), {
      y: datum.data.re[xIndex],
      x: peak.originalX + shiftValue
    });
  });
}
function updateRangesXShift(datum, shiftValue) {
  datum.ranges.values = datum.ranges.values.map((range2) => __spreadProps(__spreadValues({}, range2), {
    from: (range2.originFrom || 0) + shiftValue,
    to: (range2.originTo || 0) + shiftValue,
    signals: (range2 == null ? void 0 : range2.signals) && range2.signals.map((s) => __spreadProps(__spreadValues({}, s), {
      delta: (s.originDelta || 0) + shiftValue
    }))
  }));
}
function updateXShift(datum) {
  const shiftX2 = getShiftX(datum);
  updatePeaksXShift(datum, shiftX2);
  updateRangesXShift(datum, shiftX2);
  updateIntegralXShift(datum, shiftX2);
}
const DEFAULT_YAXIS_SHIFT_VALUE = 20;
var DISPLAYER_MODE = /* @__PURE__ */ ((DISPLAYER_MODE2) => {
  DISPLAYER_MODE2["DM_1D"] = "1D";
  DISPLAYER_MODE2["DM_2D"] = "2D";
  return DISPLAYER_MODE2;
})(DISPLAYER_MODE || {});
const MARGIN = {
  "2D": { top: 100, right: 50, bottom: 70, left: 100 },
  "1D": {
    top: 10,
    right: 10,
    bottom: 70,
    left: 10
  }
};
function fromBruker$1(result, options2 = {}, usedColors = {}) {
  const { dependentVariables, info, meta, source } = result;
  let data = getData(dependentVariables[0].components);
  if (data.im)
    info.isComplex = true;
  if (Array.isArray(info.nucleus))
    info.nucleus = info.nucleus[0];
  const datum1D = initiateDatum1D(__spreadProps(__spreadValues({}, options2), {
    source,
    info,
    meta,
    data
  }), usedColors);
  return datum1D;
}
function fromCSD$1(result, options2 = {}, usedColors = {}) {
  let dimension = result.dimensions[0];
  let dependentVariables = result.dependentVariables;
  let quantityName = dimension.quantityName;
  let n = dimension.count;
  let incr = dimension.increment.magnitude;
  let origin = dimension.originOffset.magnitude;
  let offset = dimension.coordinatesOffset.magnitude;
  let buffer = dependentVariables[0].components[0];
  let re = [];
  let im = [];
  for (let i2 = buffer.length - 1; i2 > 0; i2 -= 2) {
    re.push(buffer[i2 - 1]);
    im.push(buffer[i2]);
  }
  let data = {};
  let i, x0;
  switch (quantityName) {
    case "frequency":
      x0 = 0 + offset / origin * 1e6;
      i = incr / origin * 1e6;
      data.re = re;
      data.im = im;
      break;
    case "time":
      x0 = origin;
      i = incr;
      data.re = re.reverse();
      data.im = im.reverse().map((z) => -z);
      break;
  }
  let scale = [];
  for (let x = 0; x < n; x++) {
    scale.push(x0 + x * i);
  }
  data.x = scale;
  const datum1D = initiateDatum1D(__spreadProps(__spreadValues({}, options2), {
    data
  }), usedColors);
  return datum1D;
}
function fromParsedJcamp$1(parsedJcamp, options2, usedColors, jcampSpectrumIndex) {
  var _a;
  const { dependentVariables, info, meta } = parsedJcamp;
  let data = getData(dependentVariables[0].components);
  if (Array.isArray(info.nucleus))
    info.nucleus = info.nucleus[0];
  const datum1D = initiateDatum1D(__spreadProps(__spreadValues({}, options2), {
    source: __spreadProps(__spreadValues({}, options2.source), { jcampSpectrumIndex }),
    display: __spreadProps(__spreadValues({}, options2.display), {
      name: ((_a = options2 == null ? void 0 : options2.display) == null ? void 0 : _a.name) ? options2.display.name : info == null ? void 0 : info.title
    }),
    info,
    meta,
    data
  }), usedColors);
  return datum1D;
}
function getData(spectra) {
  var _a, _b, _c, _d, _e, _f;
  let x = ((_b = (_a = spectra[0]) == null ? void 0 : _a.data) == null ? void 0 : _b.x) ? spectra[0].data.x : [];
  let re = ((_d = (_c = spectra[0]) == null ? void 0 : _c.data) == null ? void 0 : _d.y) ? spectra[0].data.y : [];
  let im = ((_f = (_e = spectra[1]) == null ? void 0 : _e.data) == null ? void 0 : _f.y) ? spectra[1].data.y : null;
  if (x[0] > x[1]) {
    x.reverse();
    re.reverse();
    if (im)
      im.reverse();
  }
  return { x, re, im };
}
function getMissingProjection(datum, nucleus, usedColors) {
  let index2 = datum.info.nucleus.indexOf(nucleus);
  if (index2 === -1)
    index2 = 0;
  let info = {
    nucleus: datum.info.nucleus[index2],
    isFid: false,
    isComplex: false,
    dimension: 1
  };
  let from = index2 === 0 ? datum.data.minX : datum.data.minY;
  let to = index2 === 0 ? datum.data.maxX : datum.data.maxY;
  let nbPoints = index2 === 0 ? datum.data.z[0].length : datum.data.z.length;
  let projection = new Float64Array(nbPoints);
  if (index2 === 1) {
    for (let i = 0; i < datum.data.z.length; i++) {
      for (let j = 0; j < datum.data.z[0].length; j++) {
        projection[i] += datum.data.z[i][j];
      }
    }
  } else {
    for (let i = 0; i < datum.data.z[0].length; i++) {
      for (const z of datum.data.z) {
        projection[i] += z[i];
      }
    }
  }
  let data = {
    x: zoneToX({ from, to }, nbPoints),
    re: projection
  };
  return initiateDatum1D({ info, data }, usedColors);
}
function getSlice(spectrum, position) {
  const data = spectrum.data;
  const xStep = (data.maxX - data.minX) / (data.z[0].length - 1);
  const yStep = (data.maxY - data.minY) / (data.z.length - 1);
  const xIndex = Math.floor((position.x - data.minX) / xStep);
  const yIndex = Math.floor((position.y - data.minY) / yStep);
  if (xIndex < 0 || xIndex >= data.z[0].length)
    return;
  if (yIndex < 0 || yIndex >= data.z.length)
    return;
  let infoX = {
    nucleus: spectrum.info.nucleus[0],
    isFid: false,
    isComplex: false,
    dimension: 1
  };
  let dataX = {
    x: zoneToX({ from: spectrum.data.minX, to: spectrum.data.maxX }, spectrum.data.z[0].length),
    re: new Float64Array(spectrum.data.z[0].length)
  };
  for (let i = 0; i < spectrum.data.z[0].length; i++) {
    dataX.re[i] += spectrum.data.z[yIndex][i];
  }
  let infoY = {
    nucleus: spectrum.info.nucleus[1],
    isFid: false,
    isComplex: false,
    dimension: 1
  };
  let dataY = {
    x: zoneToX({ from: spectrum.data.minY, to: spectrum.data.maxY }, spectrum.data.z.length),
    re: new Float64Array(spectrum.data.z.length)
  };
  let index2 = spectrum.data.z.length - 1;
  for (let i = 0; i < spectrum.data.z.length; i++) {
    dataY.re[i] += spectrum.data.z[index2--][xIndex];
  }
  const horizontal = initiateDatum1D({ info: infoX, data: dataX }, {});
  const vertical = initiateDatum1D({ info: infoY, data: dataY }, {});
  return { horizontal, vertical };
}
const defaultContourOptions = {
  positive: {
    contourLevels: [0, 21],
    numberOfLayers: 10
  },
  negative: {
    contourLevels: [0, 21],
    numberOfLayers: 10
  }
};
class Processing2D {
  constructor(minMax, options2 = defaultContourOptions, defaultLevel = {
    positive: 10,
    negative: 10
  }) {
    this.options = options2;
    const { positive, negative } = defaultLevel;
    this.currentLevelPositive = positive;
    this.currentLevelNegative = negative;
    const xs = getRange$1(minMax.minX, minMax.maxX, minMax.z[0].length);
    const ys = getRange$1(minMax.minY, minMax.maxY, minMax.z.length);
    this.conrec = new Conrec(minMax.z, { xs, ys, swapAxes: false });
    this.median = minMax.noise;
    this.minMax = minMax;
  }
  getLevel() {
    return {
      levelPositive: this.currentLevelPositive,
      levelNegative: this.currentLevelNegative
    };
  }
  setLevel(levelPositive, levelNegative) {
    this.currentLevelPositive = levelPositive;
    this.currentLevelNegative = levelNegative;
  }
  setOptions(options2) {
    const positiveBoundary = options2.positive.contourLevels;
    const negativeBoundary = options2.negative.contourLevels;
    if (this.currentLevelPositive >= positiveBoundary[1]) {
      this.currentLevelPositive = positiveBoundary[1];
    } else if (this.currentLevelPositive <= positiveBoundary[0]) {
      this.currentLevelPositive = positiveBoundary[0];
    }
    if (this.currentLevelNegative >= negativeBoundary[1]) {
      this.currentLevelNegative = negativeBoundary[1];
    } else if (this.currentLevelNegative <= negativeBoundary[0]) {
      this.currentLevelNegative = negativeBoundary[0];
    }
    this.options = options2;
  }
  wheel(value) {
    const sign = Math.sign(value);
    const positiveBoundary = this.options.positive.contourLevels;
    const negativeBoundary = this.options.negative.contourLevels;
    if (this.currentLevelPositive > positiveBoundary[0] && sign === -1 || this.currentLevelPositive < positiveBoundary[1] && sign === 1) {
      this.currentLevelPositive += sign;
    }
    if (this.currentLevelNegative > negativeBoundary[0] && sign === -1 || this.currentLevelNegative < negativeBoundary[1] && sign === 1) {
      this.currentLevelNegative += sign;
    }
  }
  shiftWheel(value) {
    const sign = Math.sign(value);
    const [min, max2] = this.options.positive.contourLevels;
    if (this.currentLevelPositive === min && sign === -1 || this.currentLevelPositive >= max2 && sign === 1) {
      return;
    }
    this.currentLevelPositive += sign;
    return [];
  }
  drawContours() {
    const zoomPositive = this.currentLevelPositive / 2 + 1;
    const zoomNegative = this.currentLevelNegative / 2 + 1;
    const {
      positive: { numberOfLayers: numberOfPositiveLayer },
      negative: { numberOfLayers: numberOfNegativeLayer }
    } = this.options;
    return {
      positive: this.getContours(zoomPositive, {
        nbLevels: numberOfPositiveLayer
      }),
      negative: this.getContours(zoomNegative, {
        negative: true,
        nbLevels: numberOfNegativeLayer
      })
    };
  }
  getContours(zoomLevel, options2 = {}) {
    const { negative = false, timeout = 2e3, nbLevels = 10 } = options2;
    const max2 = Math.max(Math.abs(this.minMax.maxZ), Math.abs(this.minMax.minZ));
    let _range = getRange$1(this.median * 1 * Math.pow(2, zoomLevel), max2, nbLevels, 2);
    if (negative) {
      _range = _range.map((value) => -value);
    }
    let contours = [];
    try {
      contours = this.conrec.drawContour({
        contourDrawer: "basic",
        levels: _range,
        timeout
      });
    } catch (e2) {
      console.log(e2);
      throw e2;
    }
    return contours;
  }
}
function getRange$1(min, max2, length, exp) {
  if (exp !== void 0) {
    const factors = [];
    factors[0] = 0;
    for (let i = 1; i <= length; i++) {
      factors[i] = factors[i - 1] + (exp - 1) / Math.pow(exp, i);
    }
    const lastFactor = factors[length];
    const result = new Array(length);
    for (let i = 0; i < length; i++) {
      result[i] = (max2 - min) * (1 - factors[i + 1] / lastFactor) + min;
    }
    return result;
  } else {
    const step = (max2 - min) / (length - 1);
    return range(min, max2 + step / 2, step);
  }
}
function range(from, to, step) {
  const result = [];
  for (let i = from; i < to; i += step) {
    result.push(i);
  }
  return result;
}
function initiateDatum2D(options2, usedColors = {}) {
  var _a;
  const datum = {};
  datum.id = options2.id || generateID();
  datum.source = Object.assign({
    jcampURL: null
  }, options2.source);
  datum.display = Object.assign(__spreadProps(__spreadValues({
    name: ((_a = options2.display) == null ? void 0 : _a.name) ? options2.display.name : generateID()
  }, getColor(options2, usedColors)), {
    isPositiveVisible: true,
    isNegativeVisible: true,
    isVisible: true,
    contourOptions: defaultContourOptions,
    dimension: 2
  }), options2.display);
  datum.info = Object.assign({
    nucleus: ["1H", "1H"],
    isFt: true,
    isFid: false,
    isComplex: false,
    dimension: 2
  }, options2.info);
  datum.originalInfo = datum.info;
  datum.meta = Object.assign({}, options2.meta);
  datum.data = Object.assign({
    z: [],
    minX: 0,
    minY: 0,
    maxX: 0,
    maxY: 0
  }, options2.data);
  datum.originalData = datum.data;
  datum.filters = Object.assign([], options2.filters);
  datum.zones = Object.assign({ values: [], options: {} }, options2.zones);
  datum.processingController = new Processing2D(datum.data, datum.display.contourOptions);
  reapplyFilters(datum);
  return datum;
}
function getColor(options2, usedColors) {
  var _a, _b;
  let color = { positiveColor: "red", negativeColor: "blue" };
  if (((_a = options2 == null ? void 0 : options2.display) == null ? void 0 : _a.negativeColor) === void 0 || ((_b = options2 == null ? void 0 : options2.display) == null ? void 0 : _b.positiveColor) === void 0) {
    color = get2DColor(options2.info.experiment, usedColors["2d"] || []);
  }
  if (usedColors["2d"]) {
    usedColors["2d"].push(color.positiveColor);
  }
  return color;
}
function isSpectrum2D(spectrum) {
  return spectrum.info.dimension === 2;
}
function getShift(datum) {
  let shift = { xShift: 0, yShift: 0 };
  if (datum == null ? void 0 : datum.filters) {
    shift = datum.filters.reduce((acc, filter2) => {
      if (filter2.name === id$1) {
        acc.xShift = (filter2 == null ? void 0 : filter2.flag) ? filter2.value : 0;
      }
      if (filter2.name === id) {
        acc.yShift = (filter2 == null ? void 0 : filter2.flag) ? filter2.value : 0;
      }
      return acc;
    }, { xShift: 0, yShift: 0 });
  }
  return shift;
}
function updateShift(datum) {
  const { xShift, yShift } = getShift(datum);
  updateZonesShift(datum, {
    xShift,
    yShift
  });
}
function updateZonesShift(datum, { xShift, yShift }) {
  datum.zones.values = datum.zones.values.map((zone) => {
    var _a;
    return __spreadProps(__spreadValues({}, zone), {
      signals: (_a = zone.signals) == null ? void 0 : _a.map((signal) => __spreadProps(__spreadValues({}, signal), {
        x: __spreadProps(__spreadValues({}, signal.x), { delta: signal.x.originDelta + xShift }),
        y: __spreadProps(__spreadValues({}, signal.y), { delta: signal.y.originDelta + yShift })
      }))
    });
  });
}
function toJSON$3(datum, dataExportOption) {
  return __spreadProps(__spreadValues({
    id: datum.id
  }, dataExportOption === DataExportOptions.ROW_DATA || dataExportOption === DataExportOptions.DATA_SOURCE && !datum.source.jcampURL ? {
    data: datum.originalData,
    info: datum.originalInfo,
    meta: datum.meta,
    source: {
      jcampURL: null
    }
  } : {
    source: {
      jcampURL: datum.source.jcampURL,
      jcampSpectrumIndex: datum.source.jcampSpectrumIndex
    }
  }), {
    zones: datum.zones,
    filters: datum.filters,
    display: datum.display
  });
}
function changeZoneSignal(datum, zoneID, newSignal) {
  var _a;
  const zoneIndex = datum.zones.values.findIndex((zone) => zone.id === zoneID);
  if (zoneIndex !== -1) {
    const signalIndex = datum.zones.values[zoneIndex].signals.findIndex((s) => s.id === newSignal.id);
    const zone = datum.zones.values[zoneIndex];
    if (signalIndex !== -1) {
      const originalSignal = zone.signals[signalIndex];
      const xShift = (newSignal == null ? void 0 : newSignal.x) || (newSignal == null ? void 0 : newSignal.x) === 0 ? newSignal.x - originalSignal.x.delta : 0;
      const yShift = (newSignal == null ? void 0 : newSignal.y) || (newSignal == null ? void 0 : newSignal.y) === 0 ? newSignal.y - ((_a = originalSignal.y) == null ? void 0 : _a.delta) : 0;
      return { xShift, yShift };
    }
  }
  return { xShift: 0, yShift: 0 };
}
function getDetectionZones(datum, options2) {
  let dataMatrix = {};
  if (options2.selectedZone) {
    options2.enhanceSymmetry = false;
    dataMatrix = getSubMatrix(datum, options2.selectedZone);
  } else {
    dataMatrix = datum.data;
  }
  return autoZonesDetection(dataMatrix, __spreadProps(__spreadValues({}, options2), { info: datum.info }));
}
function autoZonesDetection(data, options2) {
  const { thresholdFactor, clean, maxPercentCutOff, convolutionByFFT } = options2;
  const { nucleus: nuclei, originFrequency } = options2.info;
  const { enhanceSymmetry = nuclei[0] === nuclei[1] } = options2;
  let zones = xyzAutoZonesPicking(data, {
    nuclei,
    observedFrequencies: originFrequency,
    thresholdFactor,
    clean,
    maxPercentCutOff,
    enhanceSymmetry,
    convolutionByFFT
  });
  return zones;
}
function getSubMatrix(datum, selectedZone) {
  const { fromX, toX, fromY, toY } = selectedZone;
  const data = datum.data;
  const xStep = (data.maxX - data.minX) / (data.z[0].length - 1);
  const yStep = (data.maxY - data.minY) / (data.z.length - 1);
  let xIndexFrom = Math.max(Math.floor((fromX - data.minX) / xStep), 0);
  let yIndexFrom = Math.max(Math.floor((fromY - data.minY) / yStep), 0);
  let xIndexTo = Math.min(Math.floor((toX - data.minX) / xStep), data.z[0].length - 1);
  let yIndexTo = Math.min(Math.floor((toY - data.minY) / yStep), data.z.length - 1);
  if (xIndexFrom > xIndexTo)
    [xIndexFrom, xIndexTo] = [xIndexTo, xIndexFrom];
  if (yIndexFrom > yIndexTo)
    [yIndexFrom, yIndexTo] = [yIndexTo, yIndexFrom];
  let dataMatrix = {
    z: [],
    maxX: data.minX + xIndexTo * xStep,
    minX: data.minX + xIndexFrom * xStep,
    maxY: data.minY + yIndexTo * yStep,
    minY: data.minY + yIndexFrom * yStep
  };
  let maxZ = Number.MIN_SAFE_INTEGER;
  let minZ = Number.MAX_SAFE_INTEGER;
  let nbXPoints = xIndexTo - xIndexFrom + 1;
  for (let j = yIndexFrom; j < yIndexTo; j++) {
    let row = new Float32Array(nbXPoints);
    let xIndex = xIndexFrom;
    for (let i = 0; i < nbXPoints; i++) {
      row[i] = data.z[j][xIndex++];
    }
    for (let rowValue of row) {
      if (maxZ < rowValue)
        maxZ = rowValue;
      if (minZ > rowValue)
        minZ = rowValue;
    }
    dataMatrix.z.push(Array.from(row));
  }
  dataMatrix.minZ = minZ;
  dataMatrix.maxZ = maxZ;
  return dataMatrix;
}
function detectZones(datum, options2) {
  const zones = getDetectionZones(datum, options2);
  const { xShift, yShift } = getShift(datum);
  const { minX, maxX, minY, maxY } = datum.data;
  const xError = Math.abs(maxX - minX) / 1e4;
  const yError = Math.abs(maxY - minY) / 1e4;
  const formattedZones = zones.reduce((acc, zone) => {
    const newXRange = zone.x || { from: 0, to: 0 };
    const newYRange = zone.y || { from: 0, to: 0 };
    for (const { x, y } of datum.zones.values) {
      if (Math.abs(newXRange.from - x.from) < xError && Math.abs(newXRange.to - x.to) < xError && Math.abs(newYRange.from - y.from) < yError && Math.abs(newYRange.to - y.to) < yError) {
        return acc;
      }
    }
    const signals = zone.signals.map((signal) => {
      return {
        id: generateID(),
        peaks: signal.peaks,
        x: __spreadValues({
          originDelta: signal.x.delta - xShift
        }, signal.x),
        y: __spreadValues({
          originDelta: signal.y.delta - yShift
        }, signal.y),
        kind: "signal"
      };
    });
    acc.push({
      id: generateID(),
      x: { from: newXRange.from, to: newXRange.to },
      y: { from: newYRange.from, to: newYRange.to },
      signals,
      kind: DatumKind.signal
    });
    return acc;
  }, []);
  return formattedZones;
}
function detectZonesManual(datum, options2) {
  const zones = getDetectionZones(datum, options2);
  const { xShift, yShift } = getShift(datum);
  const formattedZones = zones.map((zone) => {
    const signals = zone.signals.map((signal) => {
      return {
        id: generateID(),
        peaks: signal.peaks,
        x: __spreadValues({
          originDelta: signal.x.delta - xShift
        }, signal.x),
        y: __spreadValues({
          originDelta: signal.y.delta - yShift
        }, signal.y),
        kind: signal.kind || "signal"
      };
    });
    return {
      id: generateID(),
      x: zone.x,
      y: zone.y,
      signals,
      kind: DatumKind.signal
    };
  }, []);
  return formattedZones;
}
function fromParsedJcamp(parsedJcamp, options2, usedColors, jcampSpectrumIndex) {
  var _a;
  const { dependentVariables, info, meta } = parsedJcamp;
  let data = dependentVariables[0].components;
  const ob = initiateDatum2D(__spreadProps(__spreadValues({}, options2), {
    source: __spreadProps(__spreadValues({}, options2 == null ? void 0 : options2.source), { jcampSpectrumIndex }),
    display: __spreadProps(__spreadValues({}, options2.display), {
      name: ((_a = options2 == null ? void 0 : options2.display) == null ? void 0 : _a.name) ? options2.display.name : info == null ? void 0 : info.title
    }),
    info,
    meta,
    data
  }), usedColors);
  return ob;
}
function fromBruker(result, options2 = {}, usedColors = {}) {
  const { dependentVariables, meta, source } = result;
  let data = dependentVariables[0].components;
  const datum2D = initiateDatum2D(__spreadProps(__spreadValues({}, options2), {
    source,
    meta,
    data
  }), usedColors);
  return datum2D;
}
function fromCSD(result, options2 = {}, usedColors = {}) {
  const datum2D = initiateDatum2D({}, usedColors);
  return datum2D;
}
function changeKeys(data, changedKeys) {
  return JSON.parse(JSON.stringify(data), function reviver(key, value) {
    if (key in changedKeys) {
      this[changedKeys[key]] = value;
      return;
    }
    return value;
  });
}
function migrateToVersion1(data) {
  if ((data == null ? void 0 : data.version) === 1)
    return data;
  const newData = __spreadProps(__spreadValues({}, data), { version: 1 });
  const changedKeys = {
    j: "js",
    signal: "signals",
    integral: "integration",
    peak: "peaks",
    diaID: "diaIDs"
  };
  for (const spectrum of newData.spectra) {
    if (spectrum.ranges) {
      spectrum.ranges = changeKeys(spectrum.ranges, changedKeys);
    } else if (spectrum.zones) {
      spectrum.zones = changeKeys(spectrum.zones, changedKeys);
    }
  }
  return newData;
}
function migrateToVersion2(data) {
  if ((data == null ? void 0 : data.version) === 2)
    return data;
  const newData = __spreadProps(__spreadValues({}, data), { version: 2 });
  const changedKeys = {
    peaks: {
      delta: "x",
      originDelta: "originalX",
      intensity: "y"
    },
    ranges: {
      atomIDs: "atoms",
      intensity: "y"
    }
  };
  for (const spectrum of newData.spectra) {
    if (spectrum.peaks) {
      spectrum.peaks = changeKeys(spectrum.peaks, changedKeys.peaks);
    } else if (spectrum.ranges) {
      spectrum.ranges = changeKeys(spectrum.ranges, changedKeys.ranges);
    } else if (spectrum.zones) {
      spectrum.zones.values = mapZones$1(spectrum.zones.values);
    }
  }
  return newData;
}
function mapZones$1(zones) {
  return zones.map((zone) => {
    if (zone.signals) {
      zone.signals = zone.signals.map((signal) => {
        if (signal.x && signal.y) {
          const _a = signal, {
            x: _b
          } = _a, _c = _b, { fromTo: fromToX } = _c, resX = __objRest(_c, ["fromTo"]), {
            y: _d
          } = _a, _e = _d, { fromTo: fromToY } = _e, resY = __objRest(_e, ["fromTo"]);
          signal = __spreadProps(__spreadValues({}, signal), {
            x: __spreadValues(__spreadValues({}, resX), fromToX),
            y: __spreadValues(__spreadValues({}, resY), fromToY)
          });
        } else {
          const _f = signal, {
            fromTo: fromTo2,
            deltaX,
            resolutionX,
            nucleusX,
            deltaY,
            resolutionY,
            nucleusY,
            shiftX: shiftX2,
            shiftY: shiftY2
          } = _f, resSignal = __objRest(_f, [
            "fromTo",
            "deltaX",
            "resolutionX",
            "nucleusX",
            "deltaY",
            "resolutionY",
            "nucleusY",
            "shiftX",
            "shiftY"
          ]);
          signal = __spreadProps(__spreadValues({}, resSignal), {
            x: {
              from: fromTo2[0].from,
              to: fromTo2[0].to,
              delta: deltaX,
              resolution: resolutionX,
              nucleus: nucleusX
            },
            y: {
              from: fromTo2[1].from,
              to: fromTo2[1].to,
              delta: deltaY,
              resolution: resolutionY,
              nucleus: nucleusY
            }
          });
        }
        return signal;
      }, []);
    }
    return zone;
  }, []);
}
const CURRENT_EXPORT_VERSION = 2;
function migrationPipe(functions) {
  return (input) => functions.reduce((input2, func) => func(input2), input);
}
function migrate(data) {
  let migrationsFuncs = [
    migrateToVersion1,
    migrateToVersion2
  ];
  let index2 = (data == null ? void 0 : data.version) || 0;
  if (index2 > CURRENT_EXPORT_VERSION) {
    throw new Error("This file can not be imported using the current NMRium version, Please move to the new one !!! ");
  }
  return migrationPipe(migrationsFuncs.slice(index2))(data);
}
const mfCheck = /^(?:[A-Z][a-z]?\d* *)+$/;
function getAtomsFromMF(mf) {
  if (!mfCheck.test(mf)) {
    throw Error(`MF can not be parsed: ${mf}`);
  }
  const atoms = {};
  const parts = mf.matchAll(/(?<atom>[A-Z][a-z]?)(?<number>[0-9]*)/g);
  for (const part of parts) {
    const { atom, number } = part.groups;
    if (!atoms[atom]) {
      atoms[atom] = 0;
    }
    atoms[atom] += number === "" ? 1 : Number(number);
  }
  return atoms;
}
function initMolecule(options2 = {}) {
  const key = options2.key || generateID();
  const molfile = options2.molfile || "";
  const mol = full.Molecule.fromMolfile(molfile);
  const mfInfo = mol.getMolecularFormula();
  return {
    key,
    molfile,
    mf: mfInfo.formula,
    em: mfInfo.absoluteWeight,
    mw: mfInfo.relativeWeight,
    svg: mol.toSVG(50, 50),
    atoms: getAtomsFromMF(mfInfo.formula),
    isFloat: false
  };
}
function toJSON$2(molecule) {
  return {
    molfile: molecule.molfile
  };
}
var DataExportOptions = /* @__PURE__ */ ((DataExportOptions2) => {
  DataExportOptions2["ROW_DATA"] = "ROW_DATA";
  DataExportOptions2["DATA_SOURCE"] = "DATA_SOURCE";
  return DataExportOptions2;
})(DataExportOptions || {});
function addJcampFromURL(spectra, jcampURL, options2, usedColors) {
  return fetch(jcampURL).then((response) => response.arrayBuffer()).then((jcamp) => {
    addJcamp(spectra, jcamp, options2, usedColors);
  });
}
function addJcamp(spectra, jcamp, options2, usedColors) {
  var _a, _b;
  options2 = options2 || {};
  const entries = fromJCAMP(jcamp, {
    noContour: true,
    xy: true,
    keepRecordsRegExp: /.*/,
    profiling: true
  });
  if (entries.length === 0)
    return;
  for (let index2 = 0; index2 < entries.length; index2++) {
    let entry = entries[index2];
    const components = (_b = (_a = entry.dependentVariables) == null ? void 0 : _a[0]) == null ? void 0 : _b.components;
    if (components && (components.length > 0 || components.z)) {
      addJcampSS(spectra, { index: index2, entry }, options2, usedColors);
    }
  }
}
function addJcampSS(spectra, jcampDatum, options2, usedColors) {
  const source = (options2 == null ? void 0 : options2.source) || {};
  if (!("jcampSpectrumIndex" in source) || source.jcampSpectrumIndex === jcampDatum.index) {
    const dimension = jcampDatum.entry.info.dimension;
    if (dimension === 1) {
      spectra.push(fromParsedJcamp$1(jcampDatum.entry, options2, usedColors, jcampDatum.index));
    }
    if (dimension === 2) {
      spectra.push(fromParsedJcamp(jcampDatum.entry, options2, usedColors, jcampDatum.index));
    }
  }
}
function addData(spectra, datum, usedColors) {
  const dimension = datum.info.dimension;
  if (dimension === 1) {
    spectra.push(initiateDatum1D(datum, usedColors));
  }
  if (dimension === 2) {
    spectra.push(initiateDatum2D(datum, usedColors));
  }
}
function addJDF(spectra, jdf, options2 = {}, usedColors = {}) {
  let converted = fromJEOL(jdf);
  converted = converted[0];
  let info = converted.description;
  let metadata = info.metadata;
  delete info.metadata;
  info.acquisitionMode = 0;
  info.experiment = info.dimension === 1 ? "1d" : "2d";
  info.type = "NMR SPECTRUM";
  info.nucleus = info.nucleus[0];
  info.numberOfPoints = info.numberOfPoints[0];
  info.acquisitionTime = info.acquisitionTime[0];
  info.baseFrequency = info.baseFrequency[0];
  info.frequencyOffset = info.frequencyOffset[0];
  info.spectralWidthClipped = converted.application.spectralWidthClipped;
  if (info.dimension === 1) {
    if (converted.dependentVariables) {
      spectra.push(fromCSD$1(converted, __spreadProps(__spreadValues({}, options2), {
        display: __spreadValues({}, options2.display),
        info,
        meta: metadata
      }), usedColors));
    }
  }
  if (info.dimension === 2 && info.isFt) {
    spectra.push(fromCSD(converted, __spreadProps(__spreadValues({}, options2), {
      display: __spreadValues({}, options2.display),
      info
    }), usedColors));
  }
}
async function fromJSON$1(data = [], usedColors = {}) {
  const spectra = [];
  let promises = [];
  for (let datum of data) {
    const { jcamp, jcampURL } = (datum == null ? void 0 : datum.source) || {};
    if (jcamp != null) {
      addJcamp(spectra, jcamp, datum, usedColors);
    } else if (jcampURL != null) {
      promises.push(addJcampFromURL(spectra, jcampURL, datum, usedColors));
    } else {
      addData(spectra, datum, usedColors);
    }
  }
  await Promise.all(promises);
  return spectra;
}
async function addBruker(options2, data, usedColors) {
  const spectra = [];
  let result = await fromBruker$2(data, {
    xy: true,
    noContours: true,
    keepOriginal: true
  });
  let entries = result;
  for (let entry of entries) {
    let { info, dependentVariables } = entry;
    if (info.dimension === 1) {
      if (dependentVariables[0].components) {
        spectra.push(fromBruker$1(entry, __spreadProps(__spreadValues({}, options2), {
          display: __spreadValues({}, options2.display)
        }), usedColors));
      }
    } else if (info.dimension === 2) {
      if (info.isFt) {
        spectra.push(fromBruker(entry, __spreadProps(__spreadValues({}, options2), {
          info,
          display: __spreadValues({}, options2.display)
        }), usedColors));
      }
    }
  }
  return spectra;
}
function addJDFs(files, usedColors) {
  const spectra = [];
  for (const file of files) {
    addJDF(spectra, file.binary, {
      display: {
        name: file.name
      },
      source: {
        jcampURL: file.jcampURL ? file.jcampURL : null,
        file
      }
    }, usedColors);
  }
  return spectra;
}
function addJcamps(files, usedColors) {
  const spectra = [];
  for (const file of files) {
    addJcamp(spectra, file.binary, {
      display: {
        name: file.name
      },
      source: {
        jcampURL: file.jcampURL ? file.jcampURL : null,
        file
      }
    }, usedColors);
  }
  return spectra;
}
function getPreferences(state) {
  const {
    activeTab,
    verticalAlign: { align }
  } = state;
  return __spreadValues({
    activeTab
  }, state.displayerMode === DISPLAYER_MODE.DM_1D ? { verticalAlign: align } : {});
}
function toJSON$1(state, dataExportOption = "DATA_SOURCE") {
  const {
    data,
    molecules: mols,
    correlations,
    multipleAnalysis,
    toolOptions: {
      data: { exclusionZones: exclusionZones2 }
    }
  } = state || {
    data: [],
    molecules: [],
    correlations: {},
    multipleAnalysis: {},
    exclusionZones: {}
  };
  const spectra = data.map((ob) => {
    return ob.info.dimension === 1 ? toJSON(ob, dataExportOption) : toJSON$3(ob, dataExportOption);
  });
  const preferences = getPreferences(state);
  const molecules = mols.map((mol) => toJSON$2(mol));
  return {
    spectra,
    molecules,
    correlations,
    multipleAnalysis,
    exclusionZones: exclusionZones2,
    version: CURRENT_EXPORT_VERSION,
    preferences
  };
}
function toJSON(datum1D, dataExportOption) {
  return __spreadProps(__spreadValues({
    id: datum1D.id,
    display: datum1D.display
  }, dataExportOption === DataExportOptions.ROW_DATA || dataExportOption === DataExportOptions.DATA_SOURCE && !datum1D.source.jcampURL ? {
    data: datum1D.originalData,
    info: datum1D.originalInfo,
    meta: datum1D.meta,
    source: {
      jcampURL: null
    }
  } : {
    source: {
      jcampURL: datum1D.source.jcampURL,
      jcampSpectrumIndex: datum1D.source.jcampSpectrumIndex
    }
  }), {
    peaks: datum1D.peaks,
    integrals: datum1D.integrals,
    ranges: datum1D.ranges,
    filters: datum1D.filters
  });
}
const defaultPredictionOptions = {
  name: "",
  frequency: 400,
  "1d": {
    "1H": { from: -1, to: 12 },
    "13C": { from: -5, to: 220 },
    nbPoints: 2 ** 17,
    lineWidth: 1
  },
  "2d": {
    nbPoints: { x: 1024, y: 1024 }
  },
  spectra: {
    proton: true,
    carbon: true,
    cosy: true,
    hsqc: true,
    hmbc: true
  }
};
const FREQUENCIES = [
  { key: 1, value: 60, label: "60 MHz" },
  { key: 2, value: 100, label: "100 MHz" },
  { key: 3, value: 200, label: "200 MHz" },
  { key: 4, value: 300, label: "300 MHz" },
  { key: 5, value: 400, label: "400 MHz" },
  { key: 6, value: 500, label: "500 MHz" },
  { key: 7, value: 600, label: "600 MHz" },
  { key: 8, value: 800, label: "800 MHz" },
  { key: 9, value: 1e3, label: "1000 MHz" },
  { key: 10, value: 1200, label: "1200 MHz" }
];
const baseURL = "https://nmr-prediction.service.zakodium.com";
async function predictSpectra(molfile) {
  const molecule = full.Molecule.fromMolfile(molfile);
  return predictAll(molecule, {
    predictOptions: {
      C: {
        webserviceURL: `${baseURL}/v1/predict/carbon`
      }
    }
  });
}
function generateSpectra(data, inputOptions, color) {
  const spectra = [];
  for (const experiment in data) {
    if (inputOptions.spectra[experiment]) {
      const spectrum = data[experiment];
      switch (experiment) {
        case "proton":
        case "carbon": {
          const datum = generated1DSpectrum({
            spectrum,
            inputOptions,
            experiment,
            color
          });
          spectra.push(datum);
          break;
        }
        case "cosy":
        case "hsqc":
        case "hmbc": {
          const datum = generated2DSpectrum({
            spectrum,
            inputOptions,
            experiment,
            color
          });
          spectra.push(datum);
          break;
        }
      }
    }
  }
  return spectra;
}
function generated1DSpectrum(params) {
  const { spectrum, inputOptions, experiment, color } = params;
  const { signals, ranges, nucleus } = spectrum;
  const {
    name: name2,
    "1d": { nbPoints },
    frequency: freq
  } = inputOptions;
  const frequency = calculateFrequency(nucleus, freq);
  const { x, y } = signalsToXY(signals, __spreadProps(__spreadValues({}, inputOptions["1d"][nucleus]), {
    frequency,
    nbPoints
  }));
  const datum = initiateDatum1D({
    data: { x, im: null, re: y },
    display: {
      name: name2,
      color
    },
    info: {
      nucleus,
      originFrequency: frequency,
      baseFrequency: frequency,
      pulseSequence: "prediction",
      solvent: "",
      experiment,
      isFt: true
    }
  }, []);
  datum.ranges.values = mapRanges(ranges, datum);
  updateIntegralsRelativeValues(datum);
  return datum;
}
function mapZones(zones) {
  return zones.reduce((zonesAcc, zone) => {
    const _a = zone, { signals } = _a, resZone = __objRest(_a, ["signals"]);
    const newSignals = signals.reduce((signalsAcc, signal) => {
      const _a2 = signal, { x, y, id: id2 } = _a2, resSignal = __objRest(_a2, ["x", "y", "id"]);
      signalsAcc.push(__spreadValues({
        id: id2 || generateID(),
        kind: "signal",
        x: __spreadProps(__spreadValues({}, x), { originDelta: x.delta || 0 }),
        y: __spreadProps(__spreadValues({}, y), { originDelta: y.delta || 0 })
      }, resSignal));
      return signalsAcc;
    }, []);
    zonesAcc.push(__spreadProps(__spreadValues({
      id: generateID()
    }, resZone), {
      signals: newSignals,
      kind: DatumKind.signal
    }));
    return zonesAcc;
  }, []);
}
function generated2DSpectrum(params) {
  const { spectrum, inputOptions, experiment, color } = params;
  const { signals, zones, nuclei } = spectrum;
  const xOption = inputOptions["1d"][nuclei[0]];
  const yOption = inputOptions["1d"][nuclei[1]];
  const width = get2DWidth(nuclei);
  const frequency = calculateFrequency(nuclei, inputOptions.frequency);
  const spectrumData = signals2DToZ(signals, {
    from: { x: xOption.from, y: yOption.from },
    to: { x: xOption.to, y: yOption.to },
    nbPoints: {
      x: inputOptions["2d"].nbPoints.x,
      y: inputOptions["2d"].nbPoints.y
    },
    width,
    factor: 3
  });
  const datum = initiateDatum2D({
    data: __spreadProps(__spreadValues({}, spectrumData), { noise: 0.01 }),
    display: {
      name: inputOptions.name,
      positiveColor: color,
      negativeColor: adjustAlpha(color, 40)
    },
    info: {
      nucleus: nuclei,
      originFrequency: frequency,
      baseFrequency: frequency,
      pulseSequence: experiment,
      experiment: "2d"
    }
  }, []);
  datum.zones.values = mapZones(zones);
  return datum;
}
function get2DWidth(nucleus) {
  return nucleus[0] === nucleus[1] ? 0.02 : { x: 0.02, y: 0.2133 };
}
function calculateFrequency(nucleus, frequency) {
  if (typeof nucleus === "string") {
    return getFrequency(nucleus, { nucleus: "1H", frequency });
  } else {
    if (nucleus[0] === nucleus[1]) {
      return `${frequency},${frequency}`;
    } else {
      return `${frequency},${getFrequency(nucleus[1], {
        nucleus: nucleus[0],
        frequency
      })}`;
    }
  }
}
const ErrorColors = [
  { key: "outOfLimit", color: "red" },
  { key: "ambiguousAttachment", color: "orange" },
  { key: "notAttached", color: "blue" },
  { key: "incomplete", color: "red" }
];
const Errors = ErrorColors.map((errorColor) => errorColor.key);
const DefaultTolerance = {
  C: 0.25,
  H: 0.02,
  N: 0.25,
  F: 0.25,
  Si: 0.25,
  P: 0.25
};
const options = {
  zoom: {
    id: "zoom",
    label: "Zoom",
    hasOptionPanel: false,
    isFilter: false
  },
  peakPicking: {
    id: "peakPicking",
    label: "Peaks Picking",
    hasOptionPanel: true,
    isFilter: false
  },
  integral: {
    id: "integral",
    label: "integral Tool",
    hasOptionPanel: false,
    isFilter: false
  },
  zone2D: {
    id: "zone2D",
    label: "Zone Tool",
    hasOptionPanel: true,
    isFilter: false
  },
  slicingTool: {
    id: "slicingTool",
    label: "Slicing Tool",
    hasOptionPanel: false,
    isFilter: false
  },
  HMove: {
    id: "HMove",
    label: "Move spectrum horizontally",
    hasOptionPanel: false,
    isFilter: false
  },
  equalizerTool: {
    id: "equalizerTool",
    label: "Equalizer Tool",
    hasOptionPanel: false,
    isFilter: false
  },
  rangesPicking: {
    id: "rangesPicking",
    label: "Ranges Picking",
    hasOptionPanel: true,
    isFilter: false
  },
  zeroFilling: {
    id: id$2,
    label: name$2,
    hasOptionPanel: true,
    isFilter: true
  },
  phaseCorrection: {
    id: id$5,
    label: name$5,
    hasOptionPanel: true,
    isFilter: true
  },
  baseLineCorrection: {
    id: "baseLineCorrection",
    label: "baseline correction",
    hasOptionPanel: true,
    isFilter: true
  },
  generalSelector: {
    id: "generalSelector",
    label: "range general selector",
    hasOptionPanel: false,
    isFilter: false
  },
  editRange: {
    id: "editRange",
    label: "edit range",
    hasOptionPanel: false,
    isFilter: false
  },
  multipleSpectraAnalysis: {
    id: "multipleSpectraAnalysis",
    label: "Multiple Spectra Analysis",
    hasOptionPanel: false,
    isFilter: false
  },
  exclusionZones: {
    id: "exclusionZones",
    label: "Exclusion Zones",
    hasOptionPanel: false,
    isFilter: false
  },
  databaseRangesSelection: {
    id: "databaseRangesSelection",
    label: "Filter Database",
    hasOptionPanel: false,
    isFilter: false
  }
};
function addRanges(signals, datum) {
  let ranges = [];
  const { baseFrequency: frequency = 500 } = datum;
  for (const signal of signals) {
    const {
      jCoupling: js,
      delta,
      diaIDs = [],
      multiplicity,
      integration
    } = signal;
    const fromTo2 = computeFromTo({ delta, js, frequency });
    if (js && multiplicity) {
      if (js.length === multiplicity.length) {
        js.sort((a, b) => b - a);
        for (let i = 0; i < js.length; i++) {
          js[i].multiplicity = multiplicity[i];
        }
      }
    }
    ranges.push(__spreadProps(__spreadValues({}, fromTo2), {
      integration,
      signals: [
        {
          js,
          delta,
          diaIDs,
          multiplicity
        }
      ]
    }));
  }
  datum.ranges.values = mapRanges(joinRanges(ranges), datum);
}
function computeFromTo(options2 = {}) {
  const { delta, js: couplings = [], frequency } = options2;
  let width = 0.5;
  for (let j of couplings) {
    width += j.coupling;
  }
  width /= frequency;
  return { from: delta - width, to: delta + width };
}
function joinRanges(ranges) {
  ranges.sort((a, b) => a.from - b.from);
  for (let i = 0; i < ranges.length - 1; i++) {
    if (ranges[i].to > ranges[i + 1].from) {
      ranges[i].to = Math.max(ranges[i + 1].to, ranges[i].to);
      ranges[i].signals = ranges[i].signals.concat(ranges[i + 1].signals);
      ranges[i].integration += ranges[i + 1].integration;
      ranges.splice(i + 1, 1);
      i--;
    }
  }
  return ranges;
}
const axisLabels = ["y", "x"];
function addZones(signals, datum) {
  let zones = [];
  const shift = getShift(datum);
  const { baseFrequency } = datum.info;
  const frequency = { x: baseFrequency[0], y: baseFrequency[1] };
  for (const signal of signals) {
    let zone = { x: {}, y: {}, id: generateID(), kind: "signal" };
    let signalFormated = { id: generateID(), kind: "signal", peaks: [] };
    let width = { x: 10, y: 10 };
    for (let axis of axisLabels) {
      let { coupling = [], delta, diaIDs = [] } = signal[axis];
      for (let j of coupling) {
        width[axis] += j.coupling;
      }
      if (signal.activeCoupling) {
        const { activeCoupling = [] } = signal;
        for (let j of activeCoupling) {
          width[axis] += j.coupling;
        }
      }
      width[axis] /= frequency[axis];
      zone[axis] = {
        from: delta - width[axis],
        to: delta + width[axis]
      };
      signalFormated[axis] = {
        delta,
        diaIDs,
        originDelta: delta - shift[`${axis}Shift`]
      };
    }
    zones.push(__spreadProps(__spreadValues({}, zone), {
      signals: [signalFormated]
    }));
  }
  datum.zones.values = zones;
}
async function nmredataToNmrium(file, usedColors) {
  const jszip2 = new Zip();
  const zip = await jszip2.loadAsync(file.binary);
  const sdfFiles = await getSDF(zip.files);
  const jsonData = await NmrRecord.toJSON({
    sdf: sdfFiles[0],
    zipFiles: zip.files
  });
  let { spectra, molecules = [] } = jsonData;
  let nmrium = {
    spectra: [],
    molecules
  };
  for (const data of spectra) {
    const { file: file2, jcampURL } = data.source;
    let spectrum = await getSpectra(file2, { jcampURL }, usedColors) || [];
    for (const spectrumData of spectrum) {
      const { info } = spectrumData;
      if (info.isFid)
        continue;
      if (info.dimension > 1) {
        addZones(data.signals, spectrumData);
      } else {
        addRanges(data.signals, spectrumData);
      }
    }
    nmrium.spectra.push(...spectrum);
  }
  return nmrium;
}
async function getSpectra(file, options2 = {}, usedColors = {}) {
  const {
    xy = true,
    noContours = true,
    keepOriginal = true,
    jcampURL
  } = options2;
  switch (file.extension) {
    case "jdx":
    case "dx":
      return addJcamps([file], usedColors);
    case "zip":
      return addBruker({ xy, noContours, keepOriginal }, file.binary, usedColors);
    default:
      if (!jcampURL) {
        return;
      }
  }
}
async function getSDF(zipFiles) {
  let result = [];
  for (const file in zipFiles) {
    const pathFile = file.split("/");
    if (/^[^.].+sdf$/.exec(pathFile[pathFile.length - 1])) {
      const filename = pathFile[pathFile.length - 1].replace(/\.sdf/, "");
      const root2 = pathFile.slice(0, pathFile.length - 1).join("/");
      const sdf = await zipFiles[file].async("string");
      let parserResult = parseSDF(`${sdf}`, { mixedEOL: true });
      parserResult.filename = filename;
      parserResult.root = root2 !== "" ? `${root2}/` : "";
      result.push(parserResult);
    }
  }
  return result;
}
function setAutomaticAssignmentsHandler(draft, action) {
  const assignments = action.payload.assignments;
  for (let datum of assignments) {
    const index2 = draft.data.findIndex((spectrum) => spectrum.id === datum.id);
    if (index2 !== -1) {
      const dimension = draft.data[index2].info.dimension;
      if (dimension === 1) {
        draft.data[index2].ranges.values = datum.ranges;
      } else if (dimension === 2) {
        draft.data[index2].zones.values = datum.zones;
      }
    }
  }
}
function findSpectrum(spectraData, spectrumID, checkIsVisible) {
  const spectrum = spectraData.find((_spectrum) => _spectrum.id === spectrumID);
  if (spectrum && checkIsVisible === true && spectrum.display.isVisible === false) {
    return void 0;
  }
  return spectrum;
}
function findSignal1D(spectrum, signalID) {
  for (let range2 of spectrum.ranges.values) {
    const signalIndex = range2.signals.findIndex((_signal) => _signal.id === signalID);
    if (signalIndex >= 0) {
      return range2.signals[signalIndex];
    }
  }
}
function findSignal2D(spectrum, signalID) {
  for (let zone of spectrum.zones.values) {
    const signalIndex = zone.signals.findIndex((_signal) => _signal.id === signalID);
    if (signalIndex >= 0) {
      return zone.signals[signalIndex];
    }
  }
}
function findRange(spectrum, signalID) {
  for (let range2 of spectrum.ranges.values) {
    const signalIndex = range2.signals.findIndex((_signal) => _signal.id === signalID);
    if (signalIndex >= 0) {
      return range2;
    }
  }
}
function findZone(spectrum, signalID) {
  for (let zone of spectrum.zones.values) {
    const signalIndex = zone.signals.findIndex((_signal) => _signal.id === signalID);
    if (signalIndex >= 0) {
      return zone;
    }
  }
}
function findRangeOrZoneID(spectraData, experimentID, signalID, checkIsVisible) {
  const spectrum = findSpectrum(spectraData, experimentID, checkIsVisible);
  if (spectrum) {
    if (spectrum.info.dimension === 1) {
      const range2 = findRange(spectrum, signalID);
      if (range2)
        return range2.id;
    } else if (spectrum.info.dimension === 2) {
      const zone = findZone(spectrum, signalID);
      if (zone)
        return zone.id;
    }
  }
}
function getXScale(state, spectrumId = null) {
  const { width, margin, xDomains, xDomain, mode } = state;
  const range2 = mode === "RTL" ? [width - margin.right, margin.left] : [margin.left, width - margin.right];
  return linear(spectrumId ? xDomains[spectrumId] : xDomain, range2);
}
function getYScale$1(state, spectrumId = null) {
  const { height, margin, verticalAlign, yDomain, yDomains } = state;
  const _height = verticalAlign.align === "center" ? (height - 30) / 2 : height - margin.bottom - 30;
  let domainY = [];
  if (spectrumId === null || yDomains[spectrumId] === void 0) {
    domainY = [0, yDomain[1]];
  } else {
    domainY = [0, yDomains[spectrumId][1]];
  }
  return linear(domainY, [_height, margin.top]);
}
function getIntegralYScale(state) {
  const { height, margin, verticalAlign, integralsYDomains, activeSpectrum } = state;
  const _height = verticalAlign.align === "center" ? height / 2 : height;
  return linear((activeSpectrum == null ? void 0 : activeSpectrum.id) && integralsYDomains && integralsYDomains[activeSpectrum == null ? void 0 : activeSpectrum.id] ? integralsYDomains[activeSpectrum == null ? void 0 : activeSpectrum.id] : [0, 0], [_height * 0.3, margin.top + _height * 0.1]);
}
function getRange(draft, options2) {
  const { startX, endX } = options2;
  const scaleX = getXScale(draft);
  const start = scaleX.invert(startX);
  const end = scaleX.invert(endX);
  const range2 = [0, 0];
  if (start > end) {
    range2[0] = end;
    range2[1] = start;
  } else {
    range2[0] = start;
    range2[1] = end;
  }
  return range2;
}
function nucleusToString(nucleus) {
  return typeof nucleus === "string" ? nucleus : nucleus.join(",");
}
function getActiveData(draft) {
  let data = draft.data.filter((datum) => nucleusToString(datum.info.nucleus) === draft.activeTab && datum.info.dimension === 1);
  if (draft.activeSpectrum) {
    const activeSpectrumIndex = data.findIndex((datum) => {
      var _a;
      return datum.id === ((_a = draft.activeSpectrum) == null ? void 0 : _a.id);
    });
    if (activeSpectrumIndex !== -1) {
      const isFid = data[activeSpectrumIndex].info.isFid || false;
      data = data.filter((datum) => datum.info.isFid === isFid);
    }
  } else {
    data = data.filter((datum) => datum.info.isFid === false);
  }
  return data;
}
function getDomain(drfat) {
  let xArray = [];
  let yArray = [];
  let yDomains = {};
  let xDomains = {};
  const data = getActiveData(drfat);
  try {
    xArray = data.reduce((acc, d) => {
      const { display, data: data2 } = d;
      const domain = [data2.x[0], data2.x[data2.x.length - 1]];
      xDomains[d.id] = domain;
      if (display.isVisible) {
        acc = acc.concat(domain);
      }
      return acc;
    }, []);
    yArray = data.reduce((acc, d) => {
      const { display } = d;
      const data2 = get1DDataXY(d);
      const _extent = extent(data2.y);
      yDomains[d.id] = _extent;
      if (display.isVisible) {
        acc = acc.concat(_extent);
      }
      return acc;
    }, []);
  } catch (e2) {
    console.log(e2);
  }
  return {
    xDomain: extent(xArray),
    yDomain: extent(yArray),
    yDomains,
    xDomains
  };
}
function get2DDomain(state) {
  let xArray = [];
  let yArray = [];
  let yDomains = {};
  let xDomains = {};
  const { activeTab, tabActiveSpectrum, data } = state;
  const nucleus = activeTab.split(",");
  try {
    xArray = data.reduce((acc, datum) => {
      var _a;
      if (isSpectrum2D(datum) && ((_a = datum.info.nucleus) == null ? void 0 : _a.join(",")) === activeTab && datum.info.isFt) {
        acc = acc.concat([datum.data.minX, datum.data.maxX]);
      }
      return acc;
    }, []);
    yArray = data.reduce((acc, datum) => {
      var _a;
      if (isSpectrum2D(datum) && ((_a = datum.info.nucleus) == null ? void 0 : _a.join(",")) === activeTab && datum.info.isFt) {
        acc = acc.concat([datum.data.minY, datum.data.maxY]);
      }
      return acc;
    }, []);
  } catch (e2) {
    console.log(e2);
  }
  const spectrumsIDs = nucleus.map((n) => {
    var _a;
    return (_a = tabActiveSpectrum[n]) == null ? void 0 : _a.id;
  });
  const filteredData = data.reduce((acc, datum) => {
    return spectrumsIDs.includes(datum.id) && datum.info.dimension === 1 ? acc.concat(datum) : acc.concat([]);
  }, []);
  try {
    xDomains = filteredData.reduce((acc, d) => {
      const { x } = d.data;
      const domain = [x[0], x[x.length - 1]];
      acc[d.id] = domain;
      return acc;
    }, {});
    yDomains = filteredData.reduce((acc, d) => {
      const _extent = extent(d.data.re);
      acc[d.id] = _extent;
      return acc;
    }, {});
  } catch (e2) {
    console.log(e2);
  }
  return {
    xDomain: extent(xArray),
    yDomain: extent(yArray),
    yDomains,
    xDomains
  };
}
function setDomain(draft, options2) {
  const { yDomain = { isChanged: true, isShared: true } } = options2 || {};
  let domain;
  if (draft.activeTab) {
    if (draft.displayerMode === DISPLAYER_MODE.DM_1D) {
      domain = getDomain(draft);
    } else {
      domain = get2DDomain(draft);
    }
    draft.xDomain = domain.xDomain;
    draft.xDomains = domain.xDomains;
    draft.originDomain = domain;
    if (yDomain.isChanged) {
      draft.yDomain = domain.yDomain;
      if (draft.displayerMode === DISPLAYER_MODE.DM_1D && yDomain.isShared) {
        draft.yDomains = Object.keys(domain.yDomains).reduce((acc, key) => {
          acc[key] = domain.yDomain;
          return acc;
        }, {});
      } else {
        draft.yDomains = domain.yDomains;
      }
    } else {
      draft.originDomain = __spreadProps(__spreadValues({}, draft.originDomain), {
        xDomain: domain.xDomain,
        xDomains: domain.xDomains
      });
    }
  }
}
function getSpectrumIntegralsDomain(datum) {
  const { integrals, ranges } = datum;
  let max2 = Number.NEGATIVE_INFINITY;
  for (const integral of integrals.values) {
    max2 = Math.max(max2, integral.absolute);
  }
  for (const range2 of ranges.values) {
    max2 = Math.max(max2, range2.absolute);
  }
  return [0, max2];
}
function setIntegralsYDomain(draft, data) {
  var _a;
  for (const spectrum of Array.isArray(data) ? data : [data]) {
    if (((_a = spectrum == null ? void 0 : spectrum.info) == null ? void 0 : _a.dimension) === 1) {
      draft.integralsYDomains[spectrum.id] = getSpectrumIntegralsDomain(spectrum);
    }
  }
}
function setOriginalDomain(draft, originDomain) {
  draft.originDomain = originDomain;
}
function setXDomain(draft, xDomain) {
  draft.xDomain = xDomain;
}
function setYDomain(draft, yDomain) {
  draft.yDomain = yDomain;
}
function handelResetDomain(draft) {
  const { xDomain, yDomain, xDomains, yDomains } = draft.originDomain;
  draft.xDomain = xDomain;
  draft.yDomain = yDomain;
  draft.xDomains = xDomains;
  draft.yDomains = yDomains;
}
function setMode(draft) {
  var _a;
  const data = draft.data.filter((datum) => draft.xDomains[datum.id] && nucleusToString(datum.info.nucleus) === draft.activeTab);
  draft.mode = ((_a = data[0]) == null ? void 0 : _a.info.isFid) ? "LTR" : "RTL";
}
function handleAutoRangesDetection(draft, options2) {
  const {
    activeSpectrum,
    data,
    xDomain,
    molecules,
    activeTab: nucleus
  } = draft;
  if (activeSpectrum == null ? void 0 : activeSpectrum.id) {
    const { index: index2 } = activeSpectrum;
    const datum = data[index2];
    const [from, to] = xDomain;
    const windowFromIndex = xFindClosestIndex(datum.data.x, from);
    const windowToIndex = xFindClosestIndex(datum.data.x, to);
    const detectionOptions = __spreadValues({
      factorStd: 8,
      integrationSum: 100,
      compile: true,
      frequencyCluster: 16,
      clean: true,
      keepPeaks: true
    }, options2);
    detectRanges(datum, __spreadProps(__spreadValues({}, detectionOptions), {
      windowFromIndex,
      windowToIndex,
      molecules,
      nucleus
    }));
    handleOnChangeRangesData(draft);
    setIntegralsYDomain(draft, datum);
  }
}
function handleAutoSpectraRangesDetection(draft) {
  const peakPicking = {
    factorStd: 8,
    minMaxRatio: 0.05,
    integrationSum: 100,
    compile: true,
    frequencyCluster: 16,
    clean: true,
    keepPeaks: true
  };
  const { data, activeTab: nucleus, molecules } = draft;
  for (const datum of data) {
    if (datum.info.dimension === 1) {
      detectRanges(datum, { peakPicking, molecules, nucleus });
      handleOnChangeRangesData(draft);
    }
  }
}
function getRangeIndex(draft, spectrumIndex, rangeID) {
  return draft.data[spectrumIndex].ranges.values.findIndex((range2) => range2.id === rangeID);
}
function handleDeleteRange(draft, action) {
  var _a;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = draft.activeSpectrum;
    const { id: id2 = null, assignmentData } = action.payload.data;
    const datum = draft.data[index2];
    if (id2) {
      const rangeIndex = getRangeIndex(draft, index2, id2);
      unlinkInAssignmentData$1(assignmentData, [datum.ranges.values[rangeIndex]]);
      datum.ranges.values.splice(rangeIndex, 1);
    } else {
      unlinkInAssignmentData$1(assignmentData, datum.ranges.values);
      datum.ranges.values = [];
    }
    updateRangesRelativeValues(datum);
    handleOnChangeRangesData(draft);
  }
}
function handleChangeRangeSignalKind(draft, action) {
  var _a;
  const state = e(draft);
  if ((_a = state.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = state.activeSpectrum;
    const { rowData, value } = action.payload.data;
    const rangeIndex = getRangeIndex(state, index2, rowData.id);
    const _range = draft.data[index2].ranges.values[rangeIndex];
    if (_range == null ? void 0 : _range.signals) {
      _range.signals[rowData.tableMetaInfo.signalIndex].kind = value;
      _range.kind = SignalKindsToInclude.includes(value) ? DatumKind.signal : DatumKind.mixed;
      updateRangesRelativeValues(draft.data[index2]);
      handleOnChangeRangesData(draft);
    }
  }
}
function handleSaveEditedRange(draft, action) {
  var _a;
  const state = e(draft);
  if ((_a = state.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = state.activeSpectrum;
    const { editedRowData, assignmentData } = action.payload;
    draft.toolOptions.data.tempRange = null;
    const _editedRowData = unlink$1(editedRowData);
    delete _editedRowData.tableMetaInfo;
    delete _editedRowData.rowKey;
    unlinkInAssignmentData$1(assignmentData, [_editedRowData]);
    const rangeIndex = getRangeIndex(state, index2, _editedRowData.id);
    draft.data[index2].ranges.values[rangeIndex] = _editedRowData;
    updateRangesRelativeValues(draft.data[index2]);
    handleOnChangeRangesData(draft);
  }
}
function handleDeleteSignal$1(draft, action) {
  const {
    spectrum,
    range: range2,
    signal,
    assignmentData,
    unlinkSignalInAssignmentData = true
  } = action.payload;
  if (spectrum && range2) {
    const datum1D = draft.data.find((datum) => datum.id === spectrum.id);
    const rangeIndex = datum1D.ranges.values.findIndex((_range2) => _range2.id === range2.id);
    const signalIndex = range2.signals.findIndex((_signal) => _signal.id === signal.id);
    const _range = unlink$1(cloneDeep_1(range2), "signal", { signalIndex });
    if (unlinkSignalInAssignmentData === true) {
      unlinkInAssignmentData$1(assignmentData, [{ signals: [signal] }]);
    }
    _range.signals.splice(signalIndex, 1);
    datum1D.ranges.values[rangeIndex] = _range;
    if (_range.signals.length === 0) {
      unlinkInAssignmentData$1(assignmentData, [_range]);
      datum1D.ranges.values.splice(rangeIndex, 1);
    }
    handleOnChangeRangesData(draft);
  }
}
function handleUnlinkRange(draft, action) {
  var _a;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = draft.activeSpectrum;
    const {
      assignmentData,
      rangeData = null,
      signalIndex = -1
    } = action.payload;
    if (rangeData) {
      const rangeIndex = getRangeIndex(draft, index2, rangeData.id);
      const range2 = cloneDeep_1(draft.data[index2].ranges.values[rangeIndex]);
      let newRange = {};
      let id2 = rangeData.id;
      if (rangeData && signalIndex === -1) {
        newRange = unlink$1(range2, "range");
      } else {
        newRange = unlink$1(range2, "signal", { signalIndex });
        id2 = rangeData.signals[signalIndex].id;
      }
      unlinkInAssignmentData$1(assignmentData, [
        {
          id: id2
        }
      ]);
      draft.data[index2].ranges.values[rangeIndex] = newRange;
    } else {
      const ranges = draft.data[index2].ranges.values.map((range2) => {
        return unlink$1(range2);
      });
      draft.data[index2].ranges.values = ranges;
      unlinkInAssignmentData$1(assignmentData, ranges);
    }
  }
}
function handleSetDiaIDRange(draft, action) {
  var _a;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = draft.activeSpectrum;
    const { rangeData, diaIDs, signalIndex, nbAtoms } = action.payload;
    const getNbAtoms2 = (input, current = 0) => input + current;
    const rangeIndex = getRangeIndex(draft, index2, rangeData.id);
    const _range = draft.data[index2].ranges.values[rangeIndex];
    if (signalIndex === void 0) {
      _range.diaIDs = diaIDs;
      _range.nbAtoms = getNbAtoms2(nbAtoms, _range.nbAtoms);
    } else {
      _range.signals[signalIndex].diaIDs = diaIDs;
      _range.signals[signalIndex].nbAtoms = getNbAtoms2(nbAtoms, _range.signals[signalIndex].nbAtoms);
    }
  }
}
function handleResizeRange(draft, action) {
  var _a;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = draft.activeSpectrum;
    changeRange(draft.data[index2], action.data);
  }
}
function handleChangeRangeSum(draft, options2) {
  const { data, activeSpectrum, activeTab: nucleus } = draft;
  if (activeSpectrum == null ? void 0 : activeSpectrum.id) {
    const { index: index2 } = activeSpectrum;
    const datum = data[index2];
    setSumOptions(datum.ranges, { options: options2, nucleus });
    updateRangesRelativeValues(datum, true);
  }
}
function handleAddRange(draft, action) {
  const { startX, endX } = action.payload;
  const { activeSpectrum, activeTab: nucleus, molecules } = draft;
  const range2 = getRange(draft, { startX, endX });
  if (activeSpectrum == null ? void 0 : activeSpectrum.id) {
    const { index: index2 } = activeSpectrum;
    const [from, to] = range2;
    addRange(draft.data[index2], { from, to, nucleus, molecules });
    handleOnChangeRangesData(draft);
    setIntegralsYDomain(draft, draft.data[index2]);
  }
}
function handleChangeRangeRelativeValue(draft, action) {
  var _a;
  const data = action.payload.data;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = draft.activeSpectrum;
    changeRangeRelativeValue(draft.data[index2], data);
  }
}
function handleChangeRangeSignalValue(draft, action) {
  var _a;
  const { rangeID, signalID, value } = action.payload;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = draft.activeSpectrum;
    const shift = changeRangeSignal(draft.data[index2], {
      rangeID,
      signalID,
      newSignalValue: value
    });
    applyFilter(draft.data[index2], [
      { name: id$4, options: shift }
    ]);
    updateXShift(draft.data[index2]);
    handleOnChangeRangesData(draft);
    setDomain(draft);
  }
}
function handleOnChangeRangesData(draft) {
  handleUpdateCorrelations(draft);
}
function handleChangeRangesSumFlag(draft, action) {
  var _a;
  const flag = action.payload;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = draft.activeSpectrum;
    draft.data[index2].ranges.options.isSumConstant = !flag;
  }
}
function handleChangeTempRange(draft, action) {
  draft.toolOptions.data.tempRange = action.payload.tempRange;
}
function handleShowMultiplicityTrees(draft) {
  draft.toolOptions.data.showMultiplicityTrees = !draft.toolOptions.data.showMultiplicityTrees;
}
function handleShowRangesIntegrals(draft) {
  draft.toolOptions.data.showRangesIntegrals = !draft.toolOptions.data.showRangesIntegrals;
}
function handleShowJGraph(draft) {
  draft.toolOptions.data.showJGraph = !draft.toolOptions.data.showJGraph;
}
function getNbAtoms(zone, axis) {
  return zone.signals ? zone.signals.reduce((sum, signal) => signal[axis].nbAtoms ? sum + signal[axis].nbAtoms : sum, 0) : 0;
}
function setNbAtoms(zone, axis) {
  zone[axis].nbAtoms = getNbAtoms(zone, axis);
  if (zone[axis].nbAtoms === 0) {
    delete zone[axis].nbAtoms;
  }
}
function resetDiaIDs(zone, axis) {
  delete zone[axis].diaIDs;
  delete zone[axis].nbAtoms;
  zone.signals.forEach((signal) => {
    delete signal[axis].diaIDs;
    delete signal[axis].nbAtoms;
  });
  return zone;
}
function checkZoneKind(zone) {
  return zone.kind === DatumKind.signal;
}
function unlink(zone, isOnZoneLevel, signalIndex, axis) {
  if (isOnZoneLevel !== void 0 && axis !== void 0) {
    if (isOnZoneLevel === true) {
      delete zone[axis].diaIDs;
      delete zone[axis].nbAtoms;
    } else if (typeof signalIndex === "number" && signalIndex !== -1 && zone.signals[signalIndex]) {
      delete zone.signals[signalIndex][axis].diaIDs;
      delete zone.signals[signalIndex][axis].nbAtoms;
    }
    setNbAtoms(zone, axis);
  } else if (axis !== void 0) {
    resetDiaIDs(zone, axis);
    setNbAtoms(zone, axis);
  } else {
    ["x", "y"].forEach((key) => {
      resetDiaIDs(zone, key);
      setNbAtoms(zone, key);
    });
  }
  return zone;
}
function unlinkInAssignmentData(assignmentData, zones, axis) {
  const ids = zones.reduce((acc, zone) => {
    if (zone.id) {
      acc.push(zone.id);
    }
    if (zone.signals) {
      acc = acc.concat(zone.signals.map((signal) => signal.id, []));
    }
    return acc;
  }, []);
  if (axis) {
    assignmentData.dispatch({
      type: "REMOVE_ALL",
      payload: { id: ids, axis }
    });
  } else {
    assignmentData.dispatch({
      type: "REMOVE_ALL",
      payload: { id: ids, axis: "x" }
    });
    assignmentData.dispatch({
      type: "REMOVE_ALL",
      payload: { id: ids, axis: "y" }
    });
  }
}
const LAYOUT = {
  TOP_1D: "TOP_1D",
  LEFT_1D: "LEFT_1D",
  CENTER_2D: "CENTER_2D"
};
function get2DDimensionLayout({
  width,
  height,
  margin
}) {
  return {
    CENTER_2D: {
      startX: margin.left,
      startY: margin.top,
      endX: width - margin.right,
      endY: height - margin.bottom
    },
    TOP_1D: {
      startX: margin.left,
      startY: 0,
      endX: width - margin.right,
      endY: margin.top
    },
    LEFT_1D: {
      startX: 0,
      startY: margin.top,
      endX: margin.left,
      endY: height - margin.bottom
    }
  };
}
function getLayoutID(dimension, brushData) {
  for (const key of Object.keys(dimension)) {
    if (brushData.startX >= dimension[key].startX && brushData.startX <= dimension[key].endX && brushData.startY >= dimension[key].startY && brushData.startY <= dimension[key].endY) {
      return key;
    }
  }
  return null;
}
function get2DXScale(props) {
  const { width, margin, xDomain } = props;
  return linear(xDomain, [width - margin.right, margin.left]);
}
function get2DYScale(props, reverse = false) {
  const { height, margin, yDomain } = props;
  return linear(yDomain, reverse ? [height - margin.bottom, margin.top] : [margin.top, height - margin.bottom]);
}
function get1DYScale(yDomain, height, margin = 10) {
  return linear(yDomain, [height - margin, margin]);
}
function get2DRange(draft, options2) {
  const { startX, startY, endX, endY } = options2;
  const scaleX = get2DXScale(draft);
  const scaleY = get2DYScale(draft);
  const x1 = startX * 1e6 > endX * 1e6 ? endX : startX;
  const x2 = startX * 1e6 > endX * 1e6 ? startX : endX;
  const y1 = startY * 1e6 > endY * 1e6 ? endY : startY;
  const y2 = startY * 1e6 > endY * 1e6 ? startY : endY;
  const fromY = scaleY.invert(y1);
  const fromX = scaleX.invert(x1);
  const toY = scaleY.invert(y2);
  const toX = scaleX.invert(x2);
  return { fromX, fromY, toX, toY };
}
function changeZonesFactorHandler(draft, action) {
  draft.toolOptions.data.zonesNoiseFactor = action.payload;
}
function add2dZoneHandler(draft, action) {
  var _a;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = draft.activeSpectrum;
    const drawnZone = get2DRange(draft, action);
    const datum = draft.data[index2];
    const zones = detectZonesManual(e(datum), {
      selectedZone: drawnZone,
      thresholdFactor: draft.toolOptions.data.zonesNoiseFactor,
      convolutionByFFT: false
    });
    datum.zones.values = datum.zones.values.concat(zones);
    handleOnChangeZonesData(draft);
  }
}
function handleAutoZonesDetection(draft, detectionOptions) {
  var _a;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = draft.activeSpectrum;
    const [fromX, toX] = draft.xDomain;
    const [fromY, toY] = draft.yDomain;
    detectionOptions.selectedZone = { fromX, toX, fromY, toY };
    const datum = draft.data[index2];
    const zones = detectZones(e(datum), detectionOptions);
    datum.zones.values = datum.zones.values.concat(zones);
    handleOnChangeZonesData(draft);
  }
}
function handleAutoSpectraZonesDetection(draft) {
  for (const datum of draft.data) {
    if (datum.info.dimension === 2) {
      const { minX, maxX, minY, maxY } = datum.data;
      const detectionOptions = {
        selectedZone: { fromX: minX, toX: maxX, fromY: minY, toY: maxY },
        thresholdFactor: 1
      };
      const zones = detectZones(e(datum), detectionOptions);
      datum.zones.values = datum.zones.values.concat(zones);
      handleOnChangeZonesData(draft);
    }
  }
}
function changeZoneSignalDelta(draft, action) {
  var _a;
  const { zoneID, signal } = action.payload;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = draft.activeSpectrum;
    const { xShift, yShift } = changeZoneSignal(draft.data[index2], zoneID, signal);
    let filters = [];
    if (xShift !== 0) {
      filters.push({ name: id$1, options: xShift });
    }
    if (yShift !== 0) {
      filters.push({ name: id, options: yShift });
    }
    applyFilter(draft.data[index2], filters);
    updateShift(draft.data[index2]);
    setDomain(draft);
    handleOnChangeZonesData(draft);
  }
}
function getZoneIndex(state, spectrumIndex, zoneID) {
  return state.data[spectrumIndex].zones.values.findIndex((zone) => zone.id === zoneID);
}
function handleChangeZoneSignalKind(draft, action) {
  var _a;
  const state = e(draft);
  if ((_a = state.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = state.activeSpectrum;
    const { rowData, value } = action.payload;
    const zoneIndex = getZoneIndex(state, index2, rowData.id);
    const _zone = draft.data[index2].zones.values[zoneIndex];
    _zone.signals[rowData.tableMetaInfo.signalIndex].kind = value;
    _zone.kind = SignalKindsToInclude.includes(value) ? DatumKind.signal : DatumKind.mixed;
    handleOnChangeZonesData(draft);
  }
}
function handleDeleteZone(draft, action) {
  var _a;
  const state = e(draft);
  if ((_a = state.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = state.activeSpectrum;
    const { id: id2, assignmentData } = action.payload;
    if (id2) {
      const zone = draft.data[index2].zones.values.find((zone2) => zone2.id === id2);
      unlinkInAssignmentData(assignmentData, [zone || {}]);
      const zoneIndex = getZoneIndex(state, index2, id2);
      draft.data[index2].zones.values.splice(zoneIndex, 1);
    } else {
      unlinkInAssignmentData(assignmentData, draft.data[index2].zones.values);
      draft.data[index2].zones.values = [];
    }
    handleOnChangeZonesData(draft);
  }
}
function handleDeleteSignal(draft, action) {
  const {
    spectrum,
    zone,
    signal,
    assignmentData,
    unlinkSignalInAssignmentData = true
  } = action.payload;
  if (spectrum && zone) {
    const datum2D = draft.data.find((datum) => datum.id === spectrum.id);
    const zoneIndex = datum2D.zones.values.findIndex((_zone2) => _zone2.id === zone.id);
    const signalIndex = zone.signals.findIndex((_signal) => _signal.id === signal.id);
    const _zone = unlink(cloneDeep_1(zone), false, signalIndex, void 0);
    if (unlinkSignalInAssignmentData === true) {
      unlinkInAssignmentData(assignmentData, [{ signals: [signal] }], void 0);
    }
    _zone.signals.splice(signalIndex, 1);
    datum2D.zones.values[zoneIndex] = _zone;
    if (_zone.signals.length === 0) {
      unlinkInAssignmentData(assignmentData, [_zone]);
      datum2D.zones.values.splice(zoneIndex, 1);
    }
    handleOnChangeZonesData(draft);
  }
}
function handleSetSignalPathLength(draft, action) {
  const { spectrum, zone, signal, pathLength } = action.payload;
  if (spectrum && zone) {
    const datum2D = draft.data.find((datum) => datum.id === spectrum.id);
    const zoneIndex = datum2D.zones.values.findIndex((_zone2) => _zone2.id === zone.id);
    const signalIndex = zone.signals.findIndex((_signal) => _signal.id === signal.id);
    const _zone = unlink(cloneDeep_1(zone), false, signalIndex, void 0);
    _zone.signals[signalIndex].j = __spreadProps(__spreadValues({}, _zone.signals[signalIndex].j), {
      pathLength
    });
    datum2D.zones.values[zoneIndex] = _zone;
    handleOnChangeZonesData(draft);
  }
}
function handleUnlinkZone(draft, action) {
  var _a;
  const state = e(draft);
  if ((_a = state.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = state.activeSpectrum;
    const {
      zoneData = null,
      assignmentData,
      isOnZoneLevel = void 0,
      signalIndex = -1,
      axis = void 0
    } = action.payload;
    if (zoneData) {
      const zoneIndex = getZoneIndex(state, index2, zoneData.id);
      const zone = cloneDeep_1(draft.data[index2].zones.values[zoneIndex]);
      const _zoneData = unlink(zone, isOnZoneLevel, signalIndex, axis);
      unlinkInAssignmentData(assignmentData, [{ id: zoneData.signals[signalIndex].id }], axis);
      draft.data[index2].zones.values[zoneIndex] = _zoneData;
    } else {
      const zones = draft.data[index2].zones.values.map((zone) => {
        return unlink(zone);
      });
      draft.data[index2].zones.values = zones;
      unlinkInAssignmentData(assignmentData, zones);
    }
  }
}
function handleSetDiaIDZone(draft, action) {
  var _a;
  const state = e(draft);
  if ((_a = state.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = state.activeSpectrum;
    const { zoneData, diaIDs, axis, signalIndex, nbAtoms } = action.payload;
    const getNbAtoms2 = (input, current = 0) => input + current;
    const zoneIndex = getZoneIndex(state, index2, zoneData.id);
    const _zone = draft.data[index2].zones.values[zoneIndex];
    if (signalIndex === void 0) {
      _zone[axis].diaIDs = diaIDs;
      _zone[axis].nbAtoms = getNbAtoms2(nbAtoms, _zone[axis].nbAtoms);
    } else {
      _zone.signals[signalIndex][axis].diaIDs = diaIDs;
      _zone.signals[signalIndex][axis].nbAtoms = getNbAtoms2(nbAtoms, _zone.signals[signalIndex][axis].nbAtoms);
    }
  }
}
function handleSaveEditedZone(draft, action) {
  var _a;
  const state = e(draft);
  if ((_a = state.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = state.activeSpectrum;
    const { editedRowData } = action.payload;
    delete editedRowData.tableMetaInfo;
    const zoneIndex = getZoneIndex(state, index2, editedRowData.id);
    draft.data[index2].zones.values[zoneIndex] = editedRowData;
    if (editedRowData.signals) {
      editedRowData.signals.forEach((signal) => {
        var _a2;
        setPathLength(draft.correlations.values, signal.id, (_a2 = signal.j) == null ? void 0 : _a2.pathLength);
      });
    }
    handleOnChangeZonesData(draft);
  }
}
function handleOnChangeZonesData(draft) {
  handleUpdateCorrelations(draft);
}
function handleUpdateCorrelations(draft) {
  const { data: spectra, correlations } = draft;
  draft.correlations = buildCorrelationData(spectra, __spreadProps(__spreadValues({}, correlations.options), {
    values: cloneDeep_1(correlations.values)
  }));
}
function handleSetMF(draft, payload) {
  const state = e(draft);
  const { data: spectra, correlations } = state;
  const { mf } = payload;
  if (correlations.options.mf === "" || correlations.options.mf !== mf) {
    draft.correlations = buildCorrelationData(spectra, __spreadProps(__spreadValues({}, correlations.options), {
      mf,
      values: cloneDeep_1(correlations.values)
    }));
  }
}
function handleSetTolerance(draft, payload) {
  const state = e(draft);
  const { data: spectra, correlations } = state;
  const { tolerance } = payload;
  draft.correlations = buildCorrelationData(spectra, __spreadProps(__spreadValues({}, correlations.options), {
    tolerance,
    values: cloneDeep_1(correlations.values)
  }));
}
function handleSetCorrelation(draft, payload) {
  const state = e(draft);
  const { correlations } = state;
  const { id: id2, correlation, options: options2 } = payload;
  draft.correlations = setCorrelation(correlations, id2, correlation);
  if (options2) {
    draft.correlations = __spreadProps(__spreadValues({}, draft.correlations), {
      options: __spreadValues(__spreadValues({}, draft.correlations.options), options2)
    });
  }
  handleUpdateCorrelations(draft);
}
function handleSetCorrelations(draft, payload) {
  const { correlations, options: options2 } = payload;
  const state = e(draft);
  let correlationsData = cloneDeep_1(state.correlations);
  correlations.forEach((correlation) => {
    correlationsData = setCorrelation(correlationsData, correlation.id, correlation);
  });
  draft.correlations = correlationsData;
  if (options2) {
    draft.correlations = __spreadProps(__spreadValues({}, draft.correlations), {
      options: __spreadValues(__spreadValues({}, draft.correlations.options), options2)
    });
  }
  handleUpdateCorrelations(draft);
}
function handleDeleteCorrelation(draft, payload) {
  const { correlation, assignmentData } = payload;
  correlation.link.forEach((link) => {
    const spectrum = findSpectrum(draft.data, link.experimentID, false);
    if (spectrum) {
      if (spectrum.info.dimension === 1) {
        const range2 = findRange(spectrum, link.signal.id);
        const signal = findSignal1D(spectrum, link.signal.id);
        handleDeleteSignal$1(draft, {
          payload: {
            spectrum,
            range: range2,
            signal,
            assignmentData
          }
        });
      } else if (spectrum.info.dimension === 2) {
        const zone = findZone(spectrum, link.signal.id);
        const signal = findSignal2D(spectrum, link.signal.id);
        handleDeleteSignal(draft, {
          payload: {
            spectrum,
            zone,
            signal,
            assignmentData
          }
        });
      }
    }
  });
}
const ZoomType = {
  HORIZONTAL: "HORIZONTAL",
  VERTICAL: "VERTICAL",
  STEP_HORIZONTAL: "STEP_HORIZONTAL",
  FULL: "FULL"
};
function wheelZoom(event, domain, zoomOptions = {}) {
  const { factor = 1, invert = false } = zoomOptions;
  const deltaY = Math.abs(event.deltaY) < 100 ? event.deltaY * 100 : event.deltaY;
  const delta = deltaY * (invert ? -1e-3 : 1e-3) * factor;
  const ratio = delta < 0 ? -1 / (delta - 1) : 1 + delta;
  const [min, max2] = domain;
  return [min * ratio, max2 * ratio];
}
function setZoom(draft, options2 = {}) {
  const { height, margin, activeSpectrum } = draft;
  const { scale = 1, spectrumID = null } = options2;
  if (activeSpectrum === null && spectrumID === null) {
    const { shareYDomain, yDomain, yDomains } = draft.originDomain;
    draft.yDomains = Object.keys(draft.yDomains).reduce((acc, id2) => {
      const _scale = linear(shareYDomain ? yDomain : yDomains[id2], [
        height - margin.bottom,
        margin.top
      ]);
      const [min, max2] = shareYDomain ? yDomain : yDomains[id2];
      const maxPoint = Math.max(Math.abs(max2), Math.abs(min));
      const scalePoint = maxPoint === max2 ? 0 : min;
      const t = identity.translate(0, Math.sign(scalePoint) >= 0 ? _scale(scalePoint) : _scale(scalePoint)).scale(scale).translate(0, -_scale(0));
      const newYDomain = t.rescaleY(_scale).domain();
      acc[id2] = newYDomain;
      return acc;
    }, {});
  } else {
    const spectrumId = spectrumID || (activeSpectrum == null ? void 0 : activeSpectrum.id);
    if (spectrumId) {
      const _scale = linear(draft.originDomain.yDomains[spectrumId], [
        height - margin.bottom,
        margin.top
      ]);
      const t = identity.translate(0, _scale(0)).scale(scale).translate(0, -_scale(0));
      const yDomain = t.rescaleY(_scale).domain();
      draft.yDomains = __spreadProps(__spreadValues({}, draft.yDomains), {
        [spectrumId]: yDomain
      });
    }
  }
}
function handleRangeResurrecting(draft, action) {
  const { ranges, info } = action.payload;
  const datum = generateSpectrumFromRanges(ranges, info, draft.usedColors);
  draft.data.push(datum);
  setDomain(draft, { yDomain: { isShared: false } });
  setZoom(draft, { scale: 0.8, spectrumID: datum.id });
}
function setWidth(draft, width) {
  draft.width = width;
}
function handleSetDimensions(draft, width, height) {
  draft.width = width;
  draft.height = height;
}
function getSpectraByNucleus(nucleus, data) {
  return data.filter((spectrum) => nucleusToString(spectrum.info.nucleus) === nucleus);
}
function zoomHistoryManager(zoomHistory, nucleus) {
  if (!zoomHistory[nucleus] && !Array.isArray(zoomHistory[nucleus])) {
    zoomHistory[nucleus] = [];
  }
  const push = preparePush(zoomHistory[nucleus]);
  const pop = preparePop(zoomHistory[nucleus]);
  const getLast = prepareGetLast(zoomHistory[nucleus]);
  const clear = () => zoomHistory[nucleus] = [];
  return { historyStack: zoomHistory[nucleus], push, pop, getLast, clear };
}
function preparePush(historyStack) {
  return (val) => {
    historyStack.push(val);
  };
}
function preparePop(historyStack) {
  return () => {
    const val = historyStack.pop();
    return val ? historyStack[historyStack.length - 1] : null;
  };
}
function prepareGetLast(historyStack) {
  return () => {
    if (historyStack.length === 0)
      return null;
    return historyStack[historyStack.length - 1];
  };
}
function getNucleusSum(input) {
  const nucleus = input.split(",");
  return nucleus.reduce((acc, i) => {
    const additions = nucleus.length === 2 ? 100 : 0;
    acc += Number(i.replace(/\D/g, "")) + additions;
    return acc;
  }, 0);
}
function GroupByInfoKey(key) {
  return (array2, orderByNucleus = false) => {
    const unorderedGroup = array2.reduce((objectsByKeyValue, obj) => {
      const value = obj.info[key];
      objectsByKeyValue[value] = (objectsByKeyValue[value] || []).concat(obj);
      return objectsByKeyValue;
    }, {});
    if (!orderByNucleus) {
      return unorderedGroup;
    } else {
      return Object.keys(unorderedGroup).sort((a, b) => getNucleusSum(a) - getNucleusSum(b)).reduce((acc, key2) => {
        acc[key2] = unorderedGroup[key2];
        return acc;
      }, {});
    }
  };
}
function changeSpectrumVerticalAlignment(draft, options2) {
  var _a;
  if (draft.data && draft.data.length > 0) {
    let dataPerNucleus = [];
    if (["auto-check", "stack"].includes(options2.align || "")) {
      dataPerNucleus = draft.data.filter((datum) => datum.info.nucleus === (options2 == null ? void 0 : options2.activeTab) ? options2.activeTab : draft.activeTab && datum.info.dimension === 1);
    }
    switch (options2.align) {
      case "auto-check":
      case "bottom":
      case "center": {
        if (options2.align === "center" || options2.align === "auto-check" && ((_a = dataPerNucleus[0]) == null ? void 0 : _a.info.isFid) && !dataPerNucleus.some((d) => d.info.isFid === false)) {
          const YAxisShift = draft.height / 2;
          draft.verticalAlign.align = "center";
          draft.verticalAlign.verticalShift = YAxisShift;
        } else {
          draft.verticalAlign.align = "bottom";
          draft.verticalAlign.verticalShift = DEFAULT_YAXIS_SHIFT_VALUE;
        }
        break;
      }
      case "stack": {
        draft.verticalAlign.align = "stack";
        const visibleSpectra = dataPerNucleus.filter((datum) => datum.display.isVisible === true);
        draft.verticalAlign.verticalShift = Math.abs(Math.floor((draft.height - draft.margin.bottom) / (visibleSpectra.length + 2)));
        break;
      }
      default:
        return;
    }
  }
}
function setKeyPreferencesHandler(draft, keyCode) {
  const {
    activeTab,
    data,
    activeSpectrum,
    zoom,
    xDomain,
    xDomains,
    yDomain,
    yDomains,
    originDomain,
    margin,
    displayerMode,
    tabActiveSpectrum
  } = draft;
  if (activeTab) {
    const groupByNucleus = GroupByInfoKey("nucleus");
    const spectrumsGroupsList = groupByNucleus(data);
    const level = displayerMode === DISPLAYER_MODE.DM_2D ? spectrumsGroupsList[activeTab].reduce((acc, datum) => {
      acc[datum.id] = datum.processingController.getLevel();
      return acc;
    }, {}) : null;
    draft.keysPreferences[keyCode] = {
      activeTab,
      activeSpectrum,
      displayerMode,
      tabActiveSpectrum,
      zoom,
      xDomain,
      xDomains,
      yDomain,
      yDomains,
      originDomain,
      level,
      margin,
      data: spectrumsGroupsList[activeTab].reduce((acc, datum) => {
        acc[datum.id] = {
          display: {
            color: datum.display.color,
            isVisible: datum.display.isVisible,
            isPeaksMarkersVisible: datum.display.isPeaksMarkersVisible
          }
        };
        return acc;
      }, {})
    };
  }
}
function applyKeyPreferencesHandler(draft, keyCode) {
  const preferences = draft.keysPreferences[keyCode];
  if (preferences) {
    draft.activeTab = preferences.activeTab;
    draft.data.forEach((datum, index2) => {
      if (nucleusToString(datum.info.nucleus) === preferences.activeTab) {
        draft.data[index2].display = Object.assign(cloneDeep_1(datum.display), preferences.data[datum.id].display);
      }
    });
    draft.displayerMode = preferences.displayerMode;
    draft.tabActiveSpectrum = preferences.tabActiveSpectrum;
    draft.activeSpectrum = preferences.activeSpectrum;
    draft.margin = preferences.margin;
    setDomain(draft);
    draft.xDomain = preferences.xDomain;
    draft.xDomains = preferences.xDomains;
    draft.yDomain = preferences.yDomain;
    draft.originDomain = preferences.originDomain;
    draft.yDomains = preferences.yDomains;
    if (draft.displayerMode === DISPLAYER_MODE.DM_2D) {
      for (const datumID of Object.keys(preferences.level)) {
        const { levelPositive, levelNegative } = preferences.level[datumID];
        const index2 = draft.data.findIndex((datum) => datum.id === datumID);
        const processController = draft.data[index2].processingController;
        processController.setLevel(levelPositive, levelNegative);
        draft.contours[datumID] = processController.drawContours();
      }
    } else {
      draft.zoom = preferences.zoom;
    }
  }
}
function getStrongestPeak(draft) {
  const { activeSpectrum, data } = draft;
  if (activeSpectrum) {
    const activeData = data[activeSpectrum == null ? void 0 : activeSpectrum.index].data;
    const strongestPeakValue = max$1(activeData.re);
    const index2 = activeData.re.findIndex((val) => val === strongestPeakValue);
    return {
      xValue: activeData.x[index2],
      yValue: strongestPeakValue,
      index: index2
    };
  }
}
function setFilterChanges(draft, selectedFilter) {
  var _a;
  const activeSpectrumId = (_a = draft.activeSpectrum) == null ? void 0 : _a.id;
  if (selectedFilter === id$5) {
    const datumAfterPhaseCorrection = resetSpectrumByFilter(draft, id$5, {
      rollback: true,
      searchBy: "name",
      returnCurrentDatum: true
    });
    draft.tempData = D(draft).data;
    if (datumAfterPhaseCorrection) {
      draft.tempData[datumAfterPhaseCorrection == null ? void 0 : datumAfterPhaseCorrection.index] = datumAfterPhaseCorrection == null ? void 0 : datumAfterPhaseCorrection.datum;
    }
    const { xValue, index: index2 } = getStrongestPeak(draft) || {
      xValue: 0,
      index: 0
    };
    draft.toolOptions.data.pivot = { value: xValue, index: index2 };
  } else {
    if (draft.toolOptions.selectedTool === options.phaseCorrection.id) {
      draft.toolOptions.data.activeFilterID = null;
      const spectrumIndex = draft.data.findIndex((spectrum) => spectrum.id === activeSpectrumId);
      draft.data[spectrumIndex].data = draft.tempData[spectrumIndex].data;
    }
  }
}
function resetTool(draft, setDefaultTool = true) {
  draft.toolOptions.data.tempRange = null;
  setSelectedOptionPanel(draft, null);
  if (setDefaultTool) {
    draft.toolOptions.selectedTool = options.zoom.id;
  }
  draft.toolOptions.data.baseLineZones = [];
  if (draft.toolOptions.data.activeFilterID) {
    resetSpectrumByFilter(draft);
  }
  if (draft.tempData) {
    draft.tempData = null;
    setDomain(draft);
  }
}
function resetSelectedTool(draft, filterOnly = false) {
  if (draft.toolOptions.selectedTool && options[draft.toolOptions.selectedTool].isFilter || !filterOnly) {
    resetTool(draft);
  }
}
function setSelectedTool(draft, action) {
  const { selectedTool } = action.payload;
  if ((draft == null ? void 0 : draft.data.length) > 0) {
    if (selectedTool) {
      if (selectedTool === options.editRange.id) {
        draft.toolOptions.data.tempRange = action.payload.tempRange;
      } else {
        draft.toolOptions.data.tempRange = null;
      }
      if (selectedTool !== draft.toolOptions.selectedTool) {
        resetTool(draft, false);
      }
      draft.toolOptions.selectedTool = selectedTool;
      if (options[selectedTool].hasOptionPanel) {
        setSelectedOptionPanel(draft, selectedTool);
      }
      if (options[selectedTool].isFilter) {
        setFilterChanges(draft, selectedTool);
      }
    } else {
      resetTool(draft, false);
    }
    setMargin(draft);
  }
}
function setSelectedOptionPanel(draft, selectedOptionPanel) {
  draft.toolOptions.selectedOptionPanel = selectedOptionPanel;
}
function setSpectrumsVerticalAlign(draft) {
  const align = ["stack", "center"].includes(draft.verticalAlign.align) ? "bottom" : "center";
  changeSpectrumVerticalAlignment(draft, { align });
}
function handleChangeSpectrumDisplayMode(draft) {
  const align = draft.verticalAlign.align === "stack" ? "bottom" : "stack";
  changeSpectrumVerticalAlignment(draft, { align });
}
function handleAddBaseLineZone(draft, { from, to }) {
  const scaleX = getXScale(draft);
  let start = scaleX.invert(from);
  const end = scaleX.invert(to);
  let zone = [];
  if (start > end) {
    zone = [end, start];
  } else {
    zone = [start, end];
  }
  const zones = draft.toolOptions.data.baseLineZones.slice();
  zones.push({
    id: generateID(),
    from: zone[0],
    to: zone[1]
  });
  draft.toolOptions.data.baseLineZones = zones;
}
function handleDeleteBaseLineZone(draft, id2) {
  const state = e(draft);
  draft.toolOptions.data.baseLineZones = state.toolOptions.data.baseLineZones.baseLineZones.filter((zone) => zone.id !== id2);
}
function handleToggleRealImaginaryVisibility(draft) {
  if (draft.activeSpectrum != null) {
    const { index: index2 } = draft.activeSpectrum;
    draft.data[index2].display.isRealSpectrumVisible = !draft.data[index2].display.isRealSpectrumVisible;
    setDomain(draft);
  }
}
function handleBrushEnd(draft, action) {
  const is2D = draft.displayerMode === DISPLAYER_MODE.DM_2D;
  const xScale = getXScale(draft);
  const yScale = is2D ? get2DYScale(draft) : getYScale$1(draft);
  const startX = xScale.invert(action.startX);
  const endX = xScale.invert(action.endX);
  const startY = yScale.invert(action.startY);
  const endY = yScale.invert(action.endY);
  const domainX = startX > endX ? [endX, startX] : [startX, endX];
  const domainY = startY > endY ? [endY, startY] : [startY, endY];
  const brushHistory = zoomHistoryManager(draft.zoom.history, draft.activeTab);
  if (draft.displayerMode === DISPLAYER_MODE.DM_2D) {
    switch (action.trackID) {
      case LAYOUT.CENTER_2D:
        draft.xDomain = domainX;
        draft.yDomain = domainY;
        break;
      case LAYOUT.TOP_1D:
        draft.xDomain = domainX;
        break;
      case LAYOUT.LEFT_1D:
        draft.yDomain = domainY;
        break;
    }
    if (brushHistory) {
      brushHistory.push({ xDomain: draft.xDomain, yDomain: draft.yDomain });
    }
  } else {
    draft.xDomain = domainX;
    if (brushHistory) {
      brushHistory.push({ xDomain: domainX, yDomain: domainY });
    }
  }
}
function setVerticalIndicatorXPosition(draft, position) {
  var _a;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const scaleX = getXScale(draft);
    const value = scaleX.invert(position);
    const datum = draft.data[draft.activeSpectrum.index];
    const index2 = xFindClosestIndex(datum.data.x, value);
    draft.toolOptions.data.pivot = { value, index: index2 };
  }
}
function getSpectrumID(draft, index2) {
  const spectrum = draft.tabActiveSpectrum[draft.activeTab.split(",")[index2]];
  return (spectrum == null ? void 0 : spectrum.id) ? spectrum.id : null;
}
function handleZoom(draft, action) {
  const { event, trackID, selectedTool } = action;
  const {
    activeSpectrum,
    toolOptions: {
      data: { showRangesIntegrals }
    },
    displayerMode
  } = draft;
  if (displayerMode === DISPLAYER_MODE.DM_2D) {
    const index2 = trackID === LAYOUT.TOP_1D ? 0 : trackID === LAYOUT.LEFT_1D ? 1 : null;
    if (index2 !== null) {
      const id2 = getSpectrumID(draft, index2);
      if (id2) {
        const domain = draft.yDomains[id2];
        draft.yDomains[id2] = wheelZoom(event, domain);
      }
    }
  } else {
    if (activeSpectrum == null ? void 0 : activeSpectrum.id) {
      if ((showRangesIntegrals || selectedTool === options.integral.id) && event.shiftKey) {
        const domain = draft.integralsYDomains[activeSpectrum == null ? void 0 : activeSpectrum.id];
        draft.integralsYDomains[activeSpectrum == null ? void 0 : activeSpectrum.id] = wheelZoom(event, domain);
      } else {
        const domain = draft.yDomains[activeSpectrum == null ? void 0 : activeSpectrum.id];
        draft.yDomains[activeSpectrum == null ? void 0 : activeSpectrum.id] = wheelZoom(event, domain);
      }
    } else {
      const spectra = getSpectraByNucleus(draft.activeTab, draft.data);
      for (const spectrum of spectra) {
        const domain = draft.yDomains[spectrum.id];
        draft.yDomains[spectrum.id] = wheelZoom(event, domain);
      }
    }
  }
}
function zoomOut(draft, action) {
  if ((draft == null ? void 0 : draft.data.length) > 0) {
    const { zoomType, trackID } = action;
    const zoomHistory = zoomHistoryManager(draft.zoom.history, draft.activeTab);
    if (draft.displayerMode === DISPLAYER_MODE.DM_1D) {
      switch (zoomType) {
        case ZoomType.HORIZONTAL: {
          draft.xDomain = draft.originDomain.xDomain;
          zoomHistory.clear();
          break;
        }
        case ZoomType.VERTICAL:
          setZoom(draft, { scale: 0.8 });
          break;
        case ZoomType.STEP_HORIZONTAL: {
          const zoomValue = zoomHistory.pop();
          draft.xDomain = zoomValue ? zoomValue.xDomain : draft.originDomain.xDomain;
          setZoom(draft, { scale: 0.8 });
          break;
        }
        default: {
          draft.xDomain = draft.originDomain.xDomain;
          setZoom(draft, { scale: 0.8 });
          break;
        }
      }
    } else {
      const { xDomain, yDomain, yDomains } = draft.originDomain;
      if ([LAYOUT.TOP_1D, LAYOUT.LEFT_1D, LAYOUT.CENTER_2D].includes(trackID)) {
        const zoomValue = zoomHistory.pop();
        draft.xDomain = zoomValue ? zoomValue.xDomain : xDomain;
        draft.yDomain = zoomValue ? zoomValue.yDomain : yDomain;
      } else {
        zoomHistory.clear();
        draft.xDomain = xDomain;
        draft.yDomain = yDomain;
        draft.yDomains = yDomains;
      }
    }
  }
}
function hasAcceptedSpectrum(draft, index2) {
  const nucleuses = draft.activeTab.split(",");
  const activeSpectrum = draft.tabActiveSpectrum[nucleuses[index2]];
  return (activeSpectrum == null ? void 0 : activeSpectrum.id) && !draft.data[activeSpectrum.index].info.isFid;
}
function setMargin(draft) {
  if (draft.displayerMode === DISPLAYER_MODE.DM_2D && draft.toolOptions.selectedTool !== options.slicingTool.id) {
    const top = hasAcceptedSpectrum(draft, 0) ? MARGIN["2D"].top : MARGIN["1D"].top;
    const left = hasAcceptedSpectrum(draft, 1) ? MARGIN["2D"].left : MARGIN["1D"].left;
    draft.margin = __spreadProps(__spreadValues({}, MARGIN["2D"]), { top, left });
  } else if (draft.toolOptions.selectedTool === options.slicingTool.id) {
    draft.margin = MARGIN["2D"];
  } else if (draft.displayerMode === DISPLAYER_MODE.DM_1D) {
    draft.margin = MARGIN["1D"];
  }
}
function Processing2DData(draft, data) {
  if (draft.displayerMode === DISPLAYER_MODE.DM_2D) {
    let _data = {};
    for (const datum of data[draft.activeTab]) {
      _data[datum.id] = datum.processingController.drawContours();
    }
    draft.contours = _data;
  }
}
function setDisplayerMode(draft, data) {
  draft.displayerMode = data && data.some((d) => d.info.dimension === 2) ? DISPLAYER_MODE.DM_2D : DISPLAYER_MODE.DM_1D;
}
function setTabActiveSpectrum(draft, dataGroupByTab) {
  let tabs2D = [];
  const tabActiveSpectrum = {};
  const tabkeys = Object.keys(dataGroupByTab).sort((a, b) => a.split(",").length > b.split(",").length ? -1 : 1);
  for (let tabKey of tabkeys) {
    const data = dataGroupByTab[tabKey];
    const nucleusLength = tabKey.split(",").length;
    if (nucleusLength === 2) {
      tabs2D.push(tabKey);
    }
    if (data.length === 1) {
      const index2 = draft.data.findIndex((datum) => datum.id === data[0].id);
      tabActiveSpectrum[tabKey] = { id: data[0].id, index: index2 };
    } else {
      const tabSpectra = dataGroupByTab[tabKey];
      const tabSpectraLength = tabSpectra.length;
      if (tabSpectraLength >= 2) {
        const FTSpectrums = tabSpectra.filter((d) => !d.info.isFid);
        if (FTSpectrums.length > 0 && (nucleusLength === 2 || nucleusLength === 1 && tabSpectraLength !== FTSpectrums.length)) {
          const index2 = draft.data.findIndex((datum) => datum.id === FTSpectrums[0].id);
          tabActiveSpectrum[tabKey] = { id: FTSpectrums[0].id, index: index2 };
        } else {
          tabActiveSpectrum[tabKey] = null;
        }
      } else {
        tabActiveSpectrum[tabKey] = null;
      }
    }
  }
  draft.tabActiveSpectrum = tabActiveSpectrum;
  return tabs2D;
}
function setTab(draft, dataGroupByTab, tab, refresh = false) {
  const groupByTab = Object.keys(dataGroupByTab).sort((a, b) => a.split(",").length > b.split(",").length ? -1 : 1);
  if (JSON.stringify(groupByTab) !== JSON.stringify(Object.keys(draft.tabActiveSpectrum)) || refresh) {
    const tabs2D = setTabActiveSpectrum(draft, dataGroupByTab);
    if (tabs2D.length > 0 && tab == null) {
      draft.activeSpectrum = draft.tabActiveSpectrum[tabs2D[0]];
      draft.activeTab = tabs2D[0];
    } else {
      draft.activeSpectrum = tab ? draft.tabActiveSpectrum[tab] : tab;
      draft.activeTab = tab;
    }
  } else {
    draft.activeTab = tab;
    draft.activeSpectrum = draft.tabActiveSpectrum[tab];
  }
  setDisplayerMode(draft, dataGroupByTab[draft.activeTab]);
  setMargin(draft);
}
function setActiveTab(draft, options2) {
  const {
    tab = null,
    refreshActiveTab = false,
    domainOptions = {}
  } = options2 || {};
  const groupByNucleus = GroupByInfoKey("nucleus");
  const dataGroupByNucleus = groupByNucleus(draft.data, true);
  const tabs = Object.keys(dataGroupByNucleus);
  const currentTab = !tab || !tabs.includes(tab || "") ? tabs[0] : tab;
  setTab(draft, dataGroupByNucleus, currentTab, refreshActiveTab);
  resetTool(draft);
  Processing2DData(draft, dataGroupByNucleus);
  setDomain(draft, domainOptions);
  setIntegralsYDomain(draft, dataGroupByNucleus[currentTab]);
  const zoomHistory = zoomHistoryManager(draft.zoom.history, draft.activeTab);
  const zoomValue = zoomHistory.getLast();
  if (zoomValue) {
    draft.xDomain = zoomValue.xDomain;
    draft.yDomain = zoomValue.yDomain;
  }
  setMode(draft);
}
function handelSetActiveTab(draft, tab) {
  if (tab) {
    setActiveTab(draft, { tab });
  }
}
function levelChangeHandler(draft, { deltaY, shiftKey }) {
  var _a;
  try {
    if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
      const { index: index2, id: id2 } = draft.activeSpectrum;
      const processingController = draft.data[index2].processingController;
      if (shiftKey) {
        processingController.shiftWheel(deltaY);
      } else {
        processingController.wheel(deltaY);
      }
      const contours = Object.freeze(processingController.drawContours());
      draft.contours[id2] = contours;
    }
  } catch (e2) {
    console.log(e2);
  }
}
function setSpectraSameTopHandler(draft) {
  if (draft.displayerMode === DISPLAYER_MODE.DM_1D) {
    draft.originDomain.shareYDomain = false;
    setZoom(draft, { scale: 0.8 });
  }
}
function resetSpectraScale(draft) {
  draft.originDomain.shareYDomain = true;
  draft.yDomains = draft.originDomain.yDomains;
  draft.yDomain = draft.originDomain.yDomain;
  setZoom(draft, { scale: 0.8 });
}
function shiftSpectrumAlongXAxis(draft, shiftValue) {
  var _a, _b;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const index2 = (_b = draft.activeSpectrum) == null ? void 0 : _b.index;
    applyFilter(draft.data[index2], [
      { name: id$4, options: shiftValue }
    ]);
    updateXShift(draft.data[index2]);
    resetSelectedTool(draft);
    setDomain(draft);
  }
}
function applyZeroFillingFilter(draft, filterOptions) {
  var _a;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const index2 = draft.activeSpectrum.index;
    const filters = [
      { name: id$2, options: filterOptions.zeroFillingSize },
      {
        name: id$7,
        options: filterOptions.lineBroadeningValue
      }
    ];
    applyFilter(draft.data[index2], filters);
    resetSelectedTool(draft);
    setDomain(draft);
    setMode(draft);
  }
}
function applyFFTFilter(draft) {
  var _a;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = draft.activeSpectrum;
    applyFilter(draft.data[index2], [
      { name: id$9, options: {} }
    ]);
    resetSelectedTool(draft);
    changeSpectrumVerticalAlignment(draft, { align: "bottom" });
    setDomain(draft, { yDomain: { isChanged: true } });
    setMode(draft);
  }
}
function applyManualPhaseCorrectionFilter(draft, filterOptions) {
  var _a;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = draft.activeSpectrum;
    const { ph0, ph1 } = filterOptions;
    applyFilter(draft.data[index2], [
      { name: id$5, options: { ph0, ph1 } }
    ]);
    resetSelectedTool(draft);
    draft.tempData = null;
    setDomain(draft);
  }
}
function applyAbsoluteFilter(draft) {
  var _a;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = draft.activeSpectrum;
    applyFilter(draft.data[index2], [
      { name: id$g, options: {} }
    ]);
    resetSelectedTool(draft);
    draft.tempData = null;
    setDomain(draft);
  }
}
function applyAutoPhaseCorrectionFilter(draft) {
  var _a;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = draft.activeSpectrum;
    const { ph0, ph1 } = apply$f(draft.data[index2]);
    applyFilter(draft.data[index2], [
      { name: id$5, options: { ph0, ph1 } }
    ]);
    resetSelectedTool(draft);
    draft.tempData = null;
    setDomain(draft);
  }
}
function calculateManualPhaseCorrection(draft, filterOptions) {
  if (draft.activeSpectrum) {
    const { index: index2 } = draft.activeSpectrum;
    const {
      data: { x, re, im },
      info
    } = draft.data[index2];
    const { ph0, ph1 } = filterOptions;
    let _data = { data: { x, re, im }, info };
    apply$5(_data, { ph0, ph1 });
    const { im: newIm, re: newRe } = _data.data;
    draft.tempData[index2].data.im = newIm;
    draft.tempData[index2].data.re = newRe;
  }
}
function enableFilter(draft, filterID, checked) {
  var _a, _b, _c;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = draft.activeSpectrum;
    enableFilter$1(draft.data[index2], filterID, checked);
    if (((_b = draft.data[index2].info) == null ? void 0 : _b.dimension) === 1) {
      updateXShift(draft.data[index2]);
    } else if (((_c = draft.data[index2].info) == null ? void 0 : _c.dimension) === 2) {
      updateShift(draft.data[index2]);
    }
    resetSelectedTool(draft);
    setDomain(draft);
    setMode(draft);
    const zoomHistory = zoomHistoryManager(draft.zoom.history, draft.activeTab);
    const zoomValue = zoomHistory.getLast();
    if (zoomValue) {
      draft.xDomain = zoomValue.xDomain;
      draft.yDomain = zoomValue.yDomain;
    }
  }
}
function deleteFilter(draft, actions) {
  var _a, _b, _c;
  const filterID = actions.payload.id;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = draft.activeSpectrum;
    deleteFilter$1(draft.data[index2], filterID);
    if (((_b = draft.data[index2].info) == null ? void 0 : _b.dimension) === 1) {
      updateXShift(draft.data[index2]);
    } else if (((_c = draft.data[index2].info) == null ? void 0 : _c.dimension) === 2) {
      updateShift(draft.data[index2]);
    }
    resetSelectedTool(draft);
    setDomain(draft);
    setMode(draft);
  }
}
function deleteSpectraFilter(draft, actions) {
  var _a, _b;
  const filterType = actions.payload.filterType;
  if (draft.activeTab) {
    for (const datum of draft.data) {
      if (nucleusToString((_a = datum == null ? void 0 : datum.info) == null ? void 0 : _a.nucleus) === draft.activeTab) {
        const filtersResult = ((_b = datum.filters) == null ? void 0 : _b.filter((filter2) => filter2.name === filterType)) || [];
        filtersResult.forEach((filter2) => {
          var _a2, _b2;
          deleteFilter$1(datum, filter2.id);
          if (((_a2 = datum.info) == null ? void 0 : _a2.dimension) === 1) {
            updateXShift(datum);
          } else if (((_b2 = datum.info) == null ? void 0 : _b2.dimension) === 2) {
            updateShift(datum);
          }
        });
      }
    }
    resetSelectedTool(draft);
    setDomain(draft);
    setMode(draft);
  }
}
function handleBaseLineCorrectionFilter(draft, action) {
  var _a;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = draft.activeSpectrum;
    applyFilter(draft.data[index2], [
      {
        name: id$e,
        options: __spreadValues({
          zones: draft.toolOptions.data.baseLineZones
        }, action.options)
      }
    ]);
    draft.toolOptions.data.baseLineZones = [];
    const xDomainSnapshot = draft.xDomain.slice();
    resetSelectedTool(draft);
    setDomain(draft);
    draft.xDomain = xDomainSnapshot;
  }
}
function resetSpectrumByFilter(draft, id2 = null, options2 = {}, activeSpectrum = null) {
  var _a, _b, _c, _d;
  const {
    updateDomain = true,
    rollback = false,
    searchBy = "id",
    returnCurrentDatum = false
  } = options2;
  let currentDatum = null;
  const currentActiveSpectrum = activeSpectrum ? activeSpectrum : draft.activeSpectrum;
  if (currentActiveSpectrum == null ? void 0 : currentActiveSpectrum.id) {
    const index2 = currentActiveSpectrum.index;
    const datum = draft.data[index2];
    if (id2 && draft.toolOptions.data.activeFilterID !== id2) {
      const filterIndex = datum.filters.findIndex((f) => f[searchBy] === id2);
      let filters = [];
      if (filterIndex !== -1) {
        filters = datum.filters.slice(0, rollback ? filterIndex : filterIndex + 1);
        if (filters.length > 1) {
          draft.toolOptions.data.activeFilterID = (_a = datum.filters[rollback ? filterIndex - 1 : filterIndex]) == null ? void 0 : _a.id;
        } else {
          draft.toolOptions.data.activeFilterID = null;
        }
        reapplyFilters(datum, filters);
        if (returnCurrentDatum) {
          const { name: name2, value: options22 } = datum.filters[filterIndex];
          const newDatum = D(draft).data[index2];
          if (((_b = newDatum.info) == null ? void 0 : _b.dimension) === 1) {
            applyFilter(newDatum, [{ name: name2, options: options22 }]);
          }
          currentDatum = { datum: newDatum, index: index2 };
        }
      }
    } else {
      draft.toolOptions.data.activeFilterID = null;
      reapplyFilters(datum);
    }
    if (((_c = datum.info) == null ? void 0 : _c.dimension) === 1) {
      updateXShift(datum);
    } else if (((_d = datum.info) == null ? void 0 : _d.dimension) === 2) {
      updateShift(datum);
    }
    if (updateDomain) {
      setDomain(draft);
      setMode(draft);
    }
  }
  if (returnCurrentDatum) {
    return currentDatum;
  }
}
function filterSnapshotHandler(draft, action) {
  resetSpectrumByFilter(draft, action.id);
}
function handleMultipleSpectraFilter(draft, action) {
  var _a;
  const spectra = getSpectraByNucleus(draft.activeTab, draft.data);
  if (spectra && spectra.length > 0 && Array.isArray(action.payload)) {
    const exclusions = ((_a = spectra[0].filters.find((f) => f.name === id$a)) == null ? void 0 : _a.value) || [];
    for (const spectrum of spectra) {
      const filters = action.payload.map((filter2) => {
        if (filter2.name === id$b) {
          return __spreadProps(__spreadValues({}, filter2), {
            options: __spreadProps(__spreadValues({}, filter2.options), { exclusions })
          });
        }
        return filter2;
      });
      applyFilter(spectrum, filters);
    }
  }
  setDomain(draft);
}
function handleAddExclusionZone(draft, action) {
  var _a, _b;
  const { from: startX, to: endX } = action.payload;
  const range2 = getRange(draft, { startX, endX });
  let spectra;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const index2 = (_b = draft.activeSpectrum) == null ? void 0 : _b.index;
    spectra = [draft.data[index2]];
  } else {
    spectra = getSpectraByNucleus(draft.activeTab, draft.data);
  }
  for (const spectrum of spectra) {
    applyFilter(spectrum, [
      {
        name: id$a,
        options: [
          {
            id: generateID(),
            from: range2[0],
            to: range2[1]
          }
        ]
      }
    ]);
  }
  setDomain(draft);
}
function handleDeleteExclusionZone(draft, action) {
  const { id: id2, spectrumID } = action.payload;
  const spectrumIndex = draft.data.findIndex((spectrum) => spectrum.id === spectrumID);
  const exclusionZonesFilter = draft.data[spectrumIndex].filters.find((filter2) => filter2.name === id$a);
  if (exclusionZonesFilter) {
    if (exclusionZonesFilter.value.length === 1) {
      deleteFilter$1(draft.data[spectrumIndex], exclusionZonesFilter.id);
    } else {
      exclusionZonesFilter.value = exclusionZonesFilter.value.filter((zone) => zone.id !== id2);
      reapplyFilters(draft.data[spectrumIndex]);
    }
  }
}
function setIsOverDisplayer(draft, actions) {
  draft.overDisplayer = actions.payload;
}
function handleHistoryUndo(draft) {
  const { past, present, future } = draft.history;
  const previous = past[past.length - 1];
  const newPast = past.slice(0, past.length - 1);
  const newfuture = [present, ...future];
  const hasRedo = newfuture.length !== 0;
  const hasUndo = past.length !== 0;
  const domain = getDomain(draft.data);
  const history = {
    past: newPast,
    present: previous,
    future: newfuture,
    hasRedo,
    hasUndo
  };
  draft.xDomain = domain.xDomain;
  draft.yDomain = domain.yDomain;
  draft.originDomain = domain;
  draft.history = history;
}
function handleHistoryRedo(draft) {
  const { history } = draft;
  const newPresent = history.future.shift();
  history.past.push(history.present);
  history.present = newPresent;
  history.hasUndo = true;
  history.hasRedo = history.future.length > 0;
  setDomain(draft.data);
}
function handleHistoryReset(draft, action) {
  draft.history = {
    past: [],
    present: action,
    future: [],
    hasRedo: false,
    hasUndo: false
  };
}
function handleChangeIntegralSum(draft, options2) {
  const { data, activeSpectrum, activeTab: nucleus } = draft;
  if (activeSpectrum == null ? void 0 : activeSpectrum.id) {
    const { index: index2 } = activeSpectrum;
    const datum = data[index2];
    setSumOptions(datum.integrals, { options: options2, nucleus });
    updateIntegralsRelativeValues(datum, true);
  }
}
function addIntegral(draft, action) {
  const { startX, endX } = action;
  const { data, molecules, activeTab: nucleus, activeSpectrum } = draft;
  const [from, to] = getRange(draft, { startX, endX });
  if (activeSpectrum == null ? void 0 : activeSpectrum.id) {
    const datum = data[activeSpectrum.index];
    const { x, re } = datum.data;
    const shiftX2 = getShiftX(datum);
    const integral = {
      id: generateID(),
      originFrom: from - shiftX2,
      originTo: to - shiftX2,
      from,
      to,
      absolute: xyIntegration({ x, y: re }, { from, to, reverse: true }),
      kind: "signal"
    };
    datum.integrals.values.push(integral);
    datum.integrals.options = initSumOptions(datum.integrals.options, {
      molecules,
      nucleus
    });
    updateIntegralsRelativeValues(datum);
    setIntegralsYDomain(draft, datum);
  }
}
function deleteIntegral(draft, action) {
  if (draft.activeSpectrum) {
    const state = e(draft);
    const { index: index2 } = draft.activeSpectrum;
    const { integralID } = action;
    const datum = draft.data[index2];
    if (integralID == null) {
      datum.integrals.values = [];
    } else {
      const peakIndex = state.data[index2].integrals.values.findIndex((p2) => p2.id === integralID);
      datum.integrals.values.splice(peakIndex, 1);
      updateIntegralsRelativeValues(datum);
    }
  }
}
function changeIntegral(draft, action) {
  var _a;
  const state = e(draft);
  const integral = action.payload.data;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = draft.activeSpectrum;
    const originalDatum = state.data[index2];
    const datum = draft.data[index2];
    const { x, re } = originalDatum.data;
    const integralIndex = originalDatum.integrals.values.findIndex((i) => i.id === integral.id);
    if (integralIndex !== -1) {
      datum.integrals.values[integralIndex] = __spreadProps(__spreadValues({
        originFrom: integral.from,
        originTo: integral.to
      }, integral), {
        absolute: xyIntegration({ x, y: re }, { from: integral.from, to: integral.to, reverse: true })
      });
      updateIntegralsRelativeValues(datum);
    }
  }
}
function handleChangeIntegralsRelativeValue(draft, action) {
  var _a;
  const data = action.payload.data;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = draft.activeSpectrum;
    changeIntegralsRelative(draft.data[index2], data);
  }
}
function handleChangeIntegralsSumFlag(draft, action) {
  var _a;
  const flag = action.payload;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = draft.activeSpectrum;
    draft.data[index2].integrals.options.isSumConstant = !flag;
  }
}
function fromJSON(mols = []) {
  const molecules = [];
  for (const mol of mols) {
    const molecule = full.Molecule.fromMolfile(mol.molfile);
    const fragments = molecule.getFragments();
    for (let fragment of fragments) {
      molecules.push(initMolecule({
        molfile: fragment.toMolfileV3()
      }));
    }
  }
  return molecules;
}
function addMolfile(molecules, molfile) {
  const molecule = full.Molecule.fromMolfile(molfile);
  let fragments = molecule.getFragments();
  for (let fragment of fragments) {
    molecules.push(initMolecule({
      molfile: fragment.toMolfileV3()
    }));
  }
}
function setMolfile(molecules, molfile, key) {
  let molecule = full.Molecule.fromMolfile(molfile);
  let fragments = molecule.getFragments();
  if (fragments.length > 1) {
    molecules = molecules.filter((m) => m.key !== key);
    for (let fragment of fragments) {
      molecules.push(initMolecule({
        molfile: fragment.toMolfileV3()
      }));
    }
  } else if (fragments.length === 1) {
    const fragment = fragments[0];
    const _mol = initMolecule({
      molfile: fragment.toMolfileV3(),
      key
    });
    let molIndex = molecules.findIndex((m) => m.key === key);
    molecules.splice(molIndex, 1, _mol);
  }
}
const INITIATE = "INITIATE";
const SAVE_DATA_AS_JSON = "SAVE_DATA_AS_JSON";
const LOAD_JSON_FILE = "LOAD_JSON_FILE";
const LOAD_JCAMP_FILE = "LOAD_JCAMP_FILE";
const LOAD_NMREDATA_FILE = "LOAD_NMREDATA_FILE";
const LOAD_MOL_FILE = "LOAD_MOL_FILE";
const LOAD_ZIP_FILE = "LOAD_ZIP_FILE";
const LOAD_JDF_FILE = "LOAD_JDF_FILE";
const ADD_PEAK = "ADD_PEAK";
const ADD_PEAKS = "ADD_PEAKS";
const DELETE_PEAK_NOTATION = "DELETE_PEAK_NOTATION";
const SHIFT_SPECTRUM = "SHIFT_SPECTRUM";
const SET_X_DOMAIN = "SET_X_DOMAIN";
const SET_Y_DOMAIN = "SET_Y_DOMAIN";
const SET_ORIGINAL_DOMAIN = "SET_ORIGINAL_DOMAIN";
const SET_WIDTH = "SET_WIDTH";
const SET_DIMENSIONS = "SET_DIMENSIONS";
const SET_SELECTED_TOOL = "SET_SELECTED_TOOL";
const SET_SELECTED_FILTER = "SET_SELECTED_FILTER";
const CHANGE_SPECTRUM_SETTING = "CHANGE_SPECTRUM_SETTING";
const FULL_ZOOM_OUT = "FULL_ZOOM_OUT";
const CHANGE_VISIBILITY = "CHANGE_VISIBILITY";
const CHANGE_PEAKS_MARKERS_VISIBILITY = "CHANGE_PEAKS_MARKERS_VISIBILITY";
const CHANGE_ACTIVE_SPECTRUM = "CHANGE_ACTIVE_SPECTRUM";
const CHANGE_SPECTRUM_COLOR = "CHANGE_SPECTRUM_COLOR";
const ADD_INTEGRAL = "ADD_INTEGRAL";
const DELETE_INTEGRAL = "DELETE_INTEGRAL";
const TOGGLE_REAL_IMAGINARY_VISIBILITY = "TOGGLE_REAL_IMAGINARY_VISIBILITY";
const SET_ZOOM = "SET_ZOOM";
const ADD_MOLECULE = "ADD_MOLECULE";
const SET_MOLECULE = "SET_MOLECULE";
const DELETE_MOLECULE = "DELETE_MOLECULE";
const SET_CORRELATION = "SET_CORRELATION";
const SET_CORRELATIONS = "SET_CORRELATIONS";
const DELETE_CORRELATION = "DELETE_CORRELATION";
const SET_CORRELATIONS_MF = "SET_CORRELATIONS_MF";
const SET_CORRELATIONS_TOLERANCE = "SET_CORRELATIONS_TOLERANCE";
const DELETE_SPECTRA = "DELETE_SPECTRA";
const CHANGE_SPECTRUM_DISPLAY_VIEW_MODE = "CHANGE_SPECTRUM_DISPLAY_VIEW_MODE";
const RESIZE_INTEGRAL = "RESIZE_INTEGRAL";
const BRUSH_END = "BRUSH_END";
const RESET_DOMAIN = "RESET_X_DOMAIN";
const ENABLE_FILTER = "ENABLE_FILTER";
const DELETE_FILTER = "DELETE_FILTER";
const DELETE_SPECTRA_FILTER = "DELETE_SPECTRA_FILTER";
const APPLY_ZERO_FILLING_FILTER = "APPLY_ZERO_FILLING_FILTER";
const APPLY_FFT_FILTER = "APPLY_FFT_FILTER";
const CALCULATE_MANUAL_PHASE_CORRECTION_FILTER = "CALCULATE_MANUAL_PHASE_CORRECTION_FILTER";
const APPLY_MANUAL_PHASE_CORRECTION_FILTER = "APPLY_MANUAL_PHASE_CORRECTION_FILTER";
const APPLY_AUTO_PHASE_CORRECTION_FILTER = "APPLY_AUTO_PHASE_CORRECTION_FILTER";
const APPLY_ABSOLUTE_FILTER = "APPLY_ABSOLUTE_FILTER";
const SET_VERTICAL_INDICATOR_X_POSITION = "SET_VERTICAL_INDICATOR_X_POSITION";
const AUTO_PEAK_PICKING = "AUTO_PEAK_PICKING";
const AUTO_RANGES_DETECTION = "AUTO_RANGES_DETECTION";
const AUTO_ZONES_DETECTION = "AUTO_ZONES_DETECTION";
const DELETE_RANGE = "DELETE_RANGE";
const DELETE_1D_SIGNAL = "DELETE_1D_SIGNAL";
const SET_SELECTED_OPTIONS_PANEL = "SET_SELECTED_OPTIONS_PANEL";
const SET_LOADING_FLAG = "SET_LOADING_FLAG";
const RESET_SELECTED_TOOL = "RESET_SELECTED_TOOL";
const SET_SPECTRUMS_VERTICAL_ALIGN = "SET_SPECTRUMS_VERTICAL_AlIGN";
const SAVE_AS_SVG = "SAVE_AS_SVG";
const CHANGE_INTEGRAL_DATA = "CHANGE_INTEGRAL_DATA";
const SET_ACTIVE_TAB = "SET_ACTIVE_TAB";
const CHANGE_INTEGRAL_SUM = "CHANGE_INTEGRAL_SUM";
const ADD_BASE_LINE_ZONE = "ADD_BASE_LINE_ZONE";
const DELETE_BASE_LINE_ZONE = "DELETE_BASE_LINE_ZONE";
const APPLY_BASE_LINE_CORRECTION_FILTER = "APPLY_BASE_LINE_CORRECTION_FILTER";
const SET_KEY_PREFERENCES = "SET_KEY_PREFERENCES";
const APPLY_KEY_PREFERENCES = "APPLY_KEY_PREFERENCES";
const RESIZE_RANGE = "RESIZE_RANGE";
const CHANGE_RANGE_SUM = "CHANGE_RANGE_SUM";
const ADD_RANGE = "ADD_RANGE";
const SET_2D_LEVEL = "SET_2D_LEVEL";
const ADD_2D_ZONE = "ADD_2D_ZONE";
const DELETE_2D_ZONE = "DELETE_2D_ZONE";
const DELETE_2D_SIGNAL = "DELETE_2D_SIGNAL";
const SET_2D_SIGNAL_PATH_LENGTH = "SET_2D_SIGNAL_PATH_LENGTH";
const ADD_MISSING_PROJECTION = "ADD_MISSING_PROJECTION";
const SET_FILTER_SNAPSHOT = "SET_FILTER_SNAPSHOT";
const CHANGE_RANGE_RELATIVE = "CHANGE_RANGE_RELATIVE";
const CHANGE_RANGE_SIGNAL_VALUE = "CHANGE_RANGE_SIGNAL_VALUE";
const CHANGE_RANGE_SIGNAL_KIND = "CHANGE_RANGE_SIGNAL_KIND";
const SAVE_EDITED_RANGE = "SAVE_EDITED_RANGE";
const UNLINK_RANGE = "UNLINK_RANGE";
const SET_DIAID_RANGE = "SET_DIAID_RANGE";
const CHANGE_INTEGRAL_RELATIVE = "CHANGE_INTEGRAL_RELATIVE";
const ANALYZE_SPECTRA = "ANALYZE_SPECTRA";
const DELETE_ANALYZE_SPECTRA_RANGE = "DELETE_ANALYZE_SPECTRA_RANGE";
const RESIZE_ANALYZE_SPECTRA_RANGE = "RESIZE_ANALYZE_SPECTRA_RANGE";
const SET_ANALYZE_SPECTRA_COLUMNS = "SET_ANALYZE_SPECTRA_COLUMNS";
const FILTER_SPECTRA_COLUMN = "FILTER_SPECTRA_COLUMN";
const ALIGN_SPECTRA = "ALIGN_SPECTRA";
const CHANGE_ZONE_SIGNAL_VALUE = "CHANGE_ZONE_SIGNAL_VALUE";
const CHANGE_ZONE_SIGNAL_KIND = "CHANGE_ZONE_SIGNAL_KIND";
const SAVE_EDITED_ZONE = "SAVE_EDITED_ZONE";
const UNLINK_ZONE = "UNLINK_ZONE";
const SET_DIAID_ZONE = "SET_DIAID_ZONE";
const PREDICT_SPECTRA = "PREDICT_SPECTRA";
const SET_SPECTRA_SAME_TOP = "SET_SPECTRA_SAME_TOP";
const RESET_SPECTRA_SCALE = "RESET_SPECTRA_SCALE";
const SET_MOUSE_OVER_DISPLAYER = "SET_MOUSE_OVER_DISPLAYER";
const APPLY_MULTIPLE_SPECTRA_FILTER = "APPLY_MULTIPLE_SPECTRA_FILTER";
const ADD_EXCLUSION_ZONE = "ADD_EXCLUSION_ZONE";
const DELETE_EXCLUSION_ZONE = "DELETE_EXCLUSION_ZONE";
const CHANGE_RANGES_SUM_FLAG = "CHANGE_RANGES_SUM_FLAG";
const CHANGE_INTEGRALS_SUM_FLAG = "CHANGE_INTEGRALS_SUM_FLAG";
const CHANGE_ZONES_NOISE_FACTOR = "CHANGE_ZONES_NOISE_FACTOR";
const CHANGE_TEMP_RANGE = "CHANGE_TEMP_RANGE";
const SHOW_MULTIPLICTY_TREES = "SHOW_MULTIPLICTY_TREES";
const SHOW_RANGES_INTEGRALS = "SHOW_RANGES_INTEGRALS";
const AUTO_RANGES_SPECTRA_PICKING = "AUTO_RANGES_SPECTRA_PICKING";
const AUTO_ZONES_SPECTRA_PICKING = "AUTO_ZONES_SPECTRA_PICKING";
const GENERATE_SPECTRUM_FROM_PUBLICATION_STRING = "GENERATE_SPECTRUM_FROM_PUBLICATION_STRING";
const RESURRECTING_SPECTRUM_FROM_RANGES = "RESURRECTING_SPECTRUM_FROM_RANGES";
const SHOW_J_GRAPH = "SHOW_J_GRAPH";
const SET_AUTOMATIC_ASSIGNMENTS = "SET_AUTOMATIC_ASSIGNMENTS";
const FLOAT_MOLECULE_OVER_SPECTRUM = "FLOAT_MOLECULE_OVER_SPECTRUM";
function setIsLoading(draft, isLoading) {
  draft.isLoading = isLoading;
}
function setColors(draft, colors) {
  draft.usedColors["1d"] = draft.usedColors["1d"].concat(colors["1d"]);
  draft.usedColors["2d"] = draft.usedColors["2d"].concat(colors["2d"]);
}
function setData(draft, data) {
  const { spectra, molecules, correlations, usedColors } = data || {
    spectra: [],
    molecules: [],
    correlations: {},
    multipleAnalysis: {},
    exclusionZones: []
  };
  setColors(draft, usedColors);
  draft.data = spectra;
  draft.molecules = fromJSON(molecules);
  if (!correlations || Object.keys(correlations).length === 0) {
    draft.correlations = buildCorrelationData([], {
      tolerance: DefaultTolerance
    });
  } else {
    draft.correlations = convertHybridizationStringValuesInCorrelations(correlations);
  }
}
function convertHybridizationStringValuesInCorrelations(correlations) {
  return __spreadProps(__spreadValues({}, correlations), {
    values: correlations.values.map((correlation) => {
      if (typeof correlation.hybridization === "string") {
        let values = [];
        if (correlation.hybridization.length > 0) {
          const hybridizationString = correlation.hybridization.replaceAll("SP", "");
          const value = Number(hybridizationString);
          values.push(value);
        }
        correlation.hybridization = values;
      }
      return correlation;
    })
  });
}
function setPreferences(draft, data) {
  const emptyPreferences = {
    verticalAlign: null
  };
  const { verticalAlign = null } = data || emptyPreferences;
  if (verticalAlign) {
    changeSpectrumVerticalAlignment(draft, {
      align: verticalAlign
    });
  } else {
    changeSpectrumVerticalAlignment(draft, { align: "auto-check" });
  }
}
function initiate(draft, action) {
  var _a;
  const state = getInitialState();
  setData(state, action.payload);
  const preferences = ((_a = action.payload) == null ? void 0 : _a.preferences) || {};
  setActiveTab(state, { tab: (preferences == null ? void 0 : preferences.activeTab) || "" });
  state.width = draft.width;
  state.height = draft.height;
  setPreferences(state, action.payload);
  state.isLoading = false;
  state.actionType = INITIATE;
  return state;
}
function loadJDFFile(draft, actions) {
  const { files } = actions;
  const spectra = addJDFs(files, draft.usedColors);
  for (const spectrum of spectra) {
    draft.data.push(spectrum);
  }
  setActiveTab(draft);
  draft.isLoading = false;
}
function loadJcampFile(draft, actions) {
  const { files } = actions;
  const spectra = addJcamps(files, draft.usedColors);
  for (const spectrum of spectra) {
    draft.data.push(spectrum);
  }
  setActiveTab(draft);
  changeSpectrumVerticalAlignment(draft, { align: "auto-check" });
  draft.isLoading = false;
}
function handleLoadJsonFile(draft, action) {
  var _a;
  const state = getInitialState();
  setData(state, action.payload);
  const preferences = ((_a = action.payload) == null ? void 0 : _a.preferences) || {};
  setActiveTab(state, { tab: (preferences == null ? void 0 : preferences.activeTab) || "" });
  state.width = draft.width;
  state.height = draft.height;
  setPreferences(state, preferences);
  state.isLoading = false;
  state.actionType = LOAD_JSON_FILE;
  return state;
}
function handleLoadMOLFile(draft, actions) {
  const { files } = actions;
  for (let file of files) {
    addMolfile(draft.molecules, file.binary.toString());
  }
  draft.isLoading = false;
}
function handleLoadZIPFile(draft, action) {
  const { data, usedColors } = action.payload;
  draft.data = draft.data.concat(data);
  setColors(draft, usedColors);
  setActiveTab(draft);
  changeSpectrumVerticalAlignment(draft, { align: "auto-check" });
  draft.isLoading = false;
}
function handleLoadNmredata(draft, action) {
  const state = getInitialState();
  setData(state, action.payload);
  setActiveTab(state);
  changeSpectrumVerticalAlignment(state, { align: "auto-check" });
  state.isLoading = false;
  state.width = draft.width;
  state.height = draft.height;
  state.actionType = LOAD_NMREDATA_FILE;
  return state;
}
function addMoleculeHandler(draft, molfile) {
  const isEmpty = draft.molecules.length === 0;
  addMolfile(draft.molecules, molfile);
  const molecule = draft.molecules[0] || null;
  if (isEmpty && molecule) {
    changeSpectraRelativeSum(draft, molecule.key, molecule);
  }
}
function setMoleculeHandler(draft, molfile, key) {
  setMolfile(draft.molecules, molfile, key);
  const index2 = draft.molecules.findIndex((molecule) => molecule.key === key);
  changeSpectraRelativeSum(draft, key, index2 !== -1 ? draft.molecules[index2] : draft.molecules[0] || null);
}
function removeAssignments$1(draft, assignmentData) {
  if (draft.displayerMode === DISPLAYER_MODE.DM_1D) {
    handleUnlinkRange(draft, { payload: { assignmentData, rangeData: null } });
  }
  if (draft.displayerMode === DISPLAYER_MODE.DM_2D) {
    handleUnlinkZone(draft, { payload: { assignmentData, zoneData: null } });
  }
}
function deleteMoleculeHandler(draft, action) {
  const { key, assignmentData } = action.payload;
  removeAssignments$1(draft, assignmentData);
  const moleculeIndex = draft.molecules.findIndex((molecule) => molecule.key === key);
  draft.molecules.splice(moleculeIndex, 1);
  changeSpectraRelativeSum(draft, key, draft.molecules[0] || null);
}
function predictSpectraFromMoleculeHandler(draft, action) {
  const { data, options: options2 } = action.payload;
  if (!data) {
    draft.isLoading = false;
  } else {
    const color = getColor$2(false, draft.usedColors["1d"]);
    for (const spectrum of generateSpectra(data, options2, color)) {
      draft.data.push(spectrum);
      draft.tabActiveSpectrum[nucleusToString(spectrum.info.nucleus)] = {
        id: spectrum.id,
        index: draft.data.length - 1
      };
    }
    draft.usedColors["1d"].push(color);
  }
  draft.toolOptions.data.predictionIndex++;
  setActiveTab(draft);
  draft.isLoading = false;
}
function floatMoleculeOverSpectrum(draft, action) {
  const { key } = action.payload;
  const moleculeIndex = draft.molecules.findIndex((molecule) => molecule.key === key);
  draft.molecules[moleculeIndex].isFloat = !draft.molecules[moleculeIndex].isFloat;
}
function addPeak(draft, mouseCoordinates) {
  var _a;
  const state = e(draft);
  if (((_a = draft.activeSpectrum) == null ? void 0 : _a.id) && state) {
    const { index: index2 } = draft.activeSpectrum;
    const xShift = 10;
    const startX = mouseCoordinates.x - xShift;
    const endX = mouseCoordinates.x + xShift;
    const [from, to] = getRange(draft, { startX, endX });
    const candidatePeak = lookupPeak(state.data[index2].data, {
      from,
      to
    });
    const shiftX2 = getShiftX(draft.data[index2]);
    if (candidatePeak) {
      const peak = {
        id: generateID(),
        originalX: candidatePeak.x - shiftX2,
        x: candidatePeak.x,
        y: candidatePeak.y,
        width: 0
      };
      draft.data[index2].peaks.values.push(peak);
    }
  }
}
function addPeaks(draft, action) {
  const state = e(draft);
  if (draft.activeSpectrum) {
    const { index: index2 } = draft.activeSpectrum;
    const datumOriginal = state.data[index2];
    const { startX, endX } = action;
    const [from, to] = getRange(draft, { startX, endX });
    if (from !== to) {
      const peak = lookupPeak(datumOriginal.data, { from, to });
      const shiftX2 = getShiftX(draft.data[index2]);
      if (peak && !datumOriginal.peaks.values.some((p2) => p2.x === peak.x)) {
        const newPeak = {
          id: generateID(),
          originalX: peak.x - shiftX2,
          x: peak.x,
          y: peak.y,
          width: 0
        };
        draft.data[index2].peaks.values.push(newPeak);
      }
    }
  }
}
function deletePeak(draft, peakData) {
  if (draft.activeSpectrum) {
    const { index: index2 } = draft.activeSpectrum;
    const state = e(draft);
    if (peakData == null) {
      draft.data[index2].peaks.values = [];
    } else {
      const peakIndex = state.data[index2].peaks.values.findIndex((p2) => p2.id === peakData.id);
      draft.data[index2].peaks.values.splice(peakIndex, 1);
    }
  }
}
function handleAutoPeakPicking(draft, autOptions) {
  var _a;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    draft.toolOptions.selectedTool = options.zoom.id;
    draft.toolOptions.selectedOptionPanel = null;
    const { index: index2 } = draft.activeSpectrum;
    const datum = draft.data[index2];
    const [from, to] = draft.xDomain;
    const windowFromIndex = xFindClosestIndex(datum.data.x, from);
    const windowToIndex = xFindClosestIndex(datum.data.x, to);
    const peaks = autoPeakPicking(draft.data[index2], __spreadProps(__spreadValues({}, autOptions), {
      windowFromIndex,
      windowToIndex
    }));
    datum.peaks.values = datum.peaks.values.concat(peaks);
  }
}
function generateChar(index2) {
  const aPotions = "a".charCodeAt(0);
  const zPostion = "z".charCodeAt(0);
  const len = zPostion - aPotions + 1;
  let chartResult = "";
  while (index2 >= 0) {
    chartResult = String.fromCharCode(index2 % len + aPotions) + chartResult;
    index2 = Math.floor(index2 / len) - 1;
  }
  return chartResult;
}
var COLUMNS_TYPES = /* @__PURE__ */ ((COLUMNS_TYPES2) => {
  COLUMNS_TYPES2["NORMAL"] = "NORMAL";
  COLUMNS_TYPES2["FORMULA"] = "FORMULA";
  return COLUMNS_TYPES2;
})(COLUMNS_TYPES || {});
var COLUMNS_VALUES_KEYS = /* @__PURE__ */ ((COLUMNS_VALUES_KEYS2) => {
  COLUMNS_VALUES_KEYS2["RELATIVE"] = "relative";
  COLUMNS_VALUES_KEYS2["ABSOLUTE"] = "absolute";
  COLUMNS_VALUES_KEYS2["MIN"] = "min";
  COLUMNS_VALUES_KEYS2["MAX"] = "max";
  return COLUMNS_VALUES_KEYS2;
})(COLUMNS_VALUES_KEYS || {});
function addColumnKey(spectraAnalysis, nucleus, columnProps, columnKey) {
  const key = columnKey ? columnKey : generateChar(spectraAnalysis[nucleus].options.columnIndex).toUpperCase();
  spectraAnalysis[nucleus].options.columns[key] = columnProps;
  spectraAnalysis[nucleus].options.columnIndex++;
  return key;
}
function getSpectraAnalysis(spectra, options2) {
  const { from, to, nucleus } = options2;
  return spectra.reduce((acc, datum) => {
    if (isSpectrum1D(datum) && datum.info.nucleus === nucleus && !datum.info.isFid) {
      const range2 = detectRange(datum, { from, to });
      acc.sum += range2.absolute;
      acc.values.push(__spreadValues({ SID: datum.id }, range2));
    }
    return acc;
  }, { values: [], sum: 0 });
}
function init(spectraAnalysis, nucleus) {
  if (spectraAnalysis[nucleus] === void 0) {
    spectraAnalysis[nucleus] = {
      options: {
        sum: 100,
        code: null,
        columns: {},
        columnIndex: 0
      },
      values: {}
    };
  }
}
function changeColumnValueKey(spectraAnalysis, nucleus, columnKey, newKey) {
  spectraAnalysis[nucleus].options.columns[columnKey].valueKey = newKey;
  spectraAnalysis[nucleus].values = refreshCalculation(spectraAnalysis, nucleus);
}
function setColumn(spectraAnalysis, nucleus, { columns: inputColumns, code }) {
  init(spectraAnalysis, nucleus);
  spectraAnalysis[nucleus].options.code = code;
  spectraAnalysis[nucleus].options.columns = Object.values(inputColumns).reduce((acc, value) => {
    const data2 = __spreadValues({}, value);
    delete data2.tempKey;
    acc[value.tempKey] = data2;
    return acc;
  }, {});
  const { columns: newColumns } = spectraAnalysis[nucleus].options;
  let data = Object.entries(spectraAnalysis[nucleus].values).reduce((outerAcc, [spectraKey, spectra]) => {
    outerAcc[spectraKey] = Object.keys(inputColumns).reduce((acc, key) => {
      const newKey = inputColumns[key].tempKey;
      if (spectra[key]) {
        acc[newKey] = spectra[key];
      }
      return acc;
    }, {});
    return outerAcc;
  }, {});
  data = Object.entries(data).reduce((acc, spectra) => {
    acc[spectra[0]] = Object.keys(newColumns).reduce((acc2, key) => {
      const isFormula = newColumns[key].type === "FORMULA";
      acc2[key] = isFormula ? {
        colKey: key,
        value: calculate$1(newColumns, data[spectra[0]], newColumns[key].formula)
      } : __spreadProps(__spreadValues({}, spectra[1][key]), { colKey: key });
      return acc2;
    }, {});
    return acc;
  }, {});
  spectraAnalysis[nucleus].values = data;
}
function refreshByRow(row, columns) {
  return Object.keys(columns).reduce((acc, key) => {
    if (columns[key].type === "FORMULA") {
      acc[key] = __spreadProps(__spreadValues({
        colKey: key
      }, row), {
        value: calculate$1(columns, row, columns[key].formula)
      });
    }
    return acc;
  }, {});
}
function refreshCalculation(spectraAnalysis, nucleus) {
  const { columns } = spectraAnalysis[nucleus].options;
  const data = Object.entries(spectraAnalysis[nucleus].values).reduce((acc, spectra) => {
    const [id2, row] = spectra;
    acc[id2] = __spreadValues(__spreadValues({}, row), refreshByRow(row, columns));
    return acc;
  }, {});
  return data;
}
function analyzeSpectra$1(spectra, spectraAnalysis, options2) {
  const { from, to, nucleus, columnKey = null } = options2;
  init(spectraAnalysis, nucleus);
  const colKey = addColumnKey(spectraAnalysis, nucleus, {
    type: "NORMAL",
    valueKey: "relative",
    from,
    to,
    index: 1
  }, columnKey);
  const { sum } = spectraAnalysis[nucleus].options;
  const { values: result, sum: spectraSum } = getSpectraAnalysis(spectra, {
    from,
    to,
    nucleus
  });
  const prevNucleusData = get_1(spectraAnalysis, `${nucleus}.values`, {});
  let data = result.reduce((acc, row) => {
    const factor = spectraSum > 0 ? sum / spectraSum : 0;
    acc[row.SID] = __spreadProps(__spreadValues({}, prevNucleusData[row.SID]), {
      [colKey]: __spreadProps(__spreadValues({
        colKey
      }, row), {
        relative: Math.abs(row.absolute) * factor
      })
    });
    return acc;
  }, {});
  spectraAnalysis[nucleus].values = data;
  spectraAnalysis[nucleus].values = refreshCalculation(spectraAnalysis, nucleus);
}
function deleteSpectraAnalysis(spectraAnalysis, colKey, nucleus) {
  const result = Object.entries(spectraAnalysis[nucleus].values).reduce((acc, item) => {
    delete item[1][colKey];
    if (item[1] && Object.keys(item[1]).length > 0) {
      acc[item[0]] = item[1];
      return acc;
    }
    return acc;
  }, {});
  const _a = spectraAnalysis[nucleus].options.columns, { [colKey]: deletedColumnKey } = _a, resColumns = __objRest(_a, [__restKey(colKey)]);
  const currentColumns = Object.keys(spectraAnalysis[nucleus].options.columns);
  if (currentColumns.length === 1) {
    spectraAnalysis[nucleus].options.columnIndex = 0;
  }
  spectraAnalysis[nucleus].options.columns = resColumns;
  spectraAnalysis[nucleus].values = result;
  spectraAnalysis[nucleus].values = refreshCalculation(spectraAnalysis, nucleus);
}
function calculate$1(columns, data, formula = "") {
  const array2 = formula.split(/\+|-|\*|\/|%|\(|\)/);
  const variables = [];
  for (const col of array2) {
    const column = col.trim();
    if (columns[column]) {
      variables.push(column);
    }
  }
  const params = variables.map((key) => data[key] ? data[key][columns[key].valueKey] : null);
  let result;
  try {
    result = new Function(...variables, `return ${formula}`)(...params);
  } catch (e2) {
    console.error(e2);
    result = new Error(`Invalid Formula ( ${formula} ) `);
  }
  return result;
}
function getDataAsString(spectraAnalysis, nucleus) {
  if (spectraAnalysis == null ? void 0 : spectraAnalysis[nucleus]) {
    const {
      values,
      options: { columns }
    } = spectraAnalysis[nucleus];
    let result = "";
    for (const letter in columns) {
      result += `${letter}	`;
    }
    result += "\n";
    for (const spectrum of Object.values(values)) {
      for (const letter in columns) {
        result += `${spectrum[letter][columns[letter].valueKey]}	`;
      }
      result += "\n";
    }
    return result;
  }
  return null;
}
function analyzeSpectra(draft, action) {
  const [from, to] = getRange(draft, action);
  analyzeSpectra$1(draft.data, draft.spectraAnalysis, {
    from,
    to,
    nucleus: draft.activeTab
  });
}
function handleDeleteSpectraRanges(draft, action) {
  const { colKey } = action;
  deleteSpectraAnalysis(draft.spectraAnalysis, colKey, draft.activeTab);
}
function handleResizeSpectraRange(draft, action) {
  const { columnKey, from, to } = action.payload;
  analyzeSpectra$1(draft.data, draft.spectraAnalysis, {
    from,
    to,
    nucleus: draft.activeTab,
    columnKey
  });
}
function handleSetColumns(draft, action) {
  const data = action.payload;
  setColumn(draft.spectraAnalysis, draft.activeTab, data);
}
function handleFilterColumn(draft, action) {
  const { columnKey, valueKey } = action.payload;
  changeColumnValueKey(draft.spectraAnalysis, draft.activeTab, columnKey, valueKey);
}
function checkIsVisible2D(datum) {
  if (datum.display.isPositiveVisible === false && datum.display.isNegativeVisible === false) {
    return false;
  }
  return true;
}
function setVisible(datum, flag) {
  if (datum.info.dimension === 2) {
    datum.display.isPositiveVisible = flag;
    datum.display.isNegativeVisible = flag;
    datum.display.isVisible = checkIsVisible2D(datum);
  } else {
    datum.display.isVisible = flag;
  }
}
function handleSpectrumVisibility(draft, action) {
  if (Array.isArray(action.id)) {
    const IDs = action.id;
    if (IDs.length === 0) {
      for (const datum of draft.data) {
        setVisible(datum, false);
      }
    } else {
      for (const datum of draft.data) {
        if (IDs.includes(datum.id)) {
          setVisible(datum, true);
        } else {
          setVisible(datum, false);
        }
      }
    }
  } else {
    const index2 = draft.data.findIndex((d) => d.id === action.id);
    draft.data[index2].display[action.key] = action.value;
    if (draft.data[index2].info.dimension === 2) {
      draft.data[index2].display.isVisible = checkIsVisible2D(draft.data[index2]);
    }
  }
}
function handleChangePeaksMarkersVisibility(draft, data) {
  var _a;
  for (let datum of draft.data) {
    if (((_a = datum.info) == null ? void 0 : _a.dimension) === 1 && data.some((activeData) => activeData.id === datum.id)) {
      datum.display.isPeaksMarkersVisible = true;
    } else {
      datum.display.isPeaksMarkersVisible = false;
    }
  }
}
function handleChangeActiveSpectrum(draft, activeSpectrum) {
  let refreshDomain = false;
  const currentActiveSpectrum = draft.activeSpectrum;
  if (activeSpectrum) {
    const newIndex = draft.data.findIndex((d) => d.id === activeSpectrum.id);
    const oldIndex = draft.data.findIndex((d) => {
      var _a;
      return d.id === ((_a = draft.activeSpectrum) == null ? void 0 : _a.id);
    });
    if (newIndex !== -1) {
      const newActiveSpectrum = draft.data[newIndex];
      newActiveSpectrum.display.isVisible = true;
      if (oldIndex !== -1) {
        refreshDomain = draft.data[oldIndex].info.isFid === newActiveSpectrum.info.isFid ? false : true;
      } else {
        refreshDomain = newActiveSpectrum.info.isFid || false;
      }
    }
    activeSpectrum = __spreadProps(__spreadValues({}, activeSpectrum), { index: newIndex });
    draft.activeSpectrum = activeSpectrum;
    draft.tabActiveSpectrum[draft.activeTab] = activeSpectrum;
  } else {
    if (currentActiveSpectrum) {
      const index2 = draft.data.findIndex((d) => d.id === currentActiveSpectrum.id);
      refreshDomain = draft.data[index2].info.isFid;
    } else {
      refreshDomain = false;
    }
    draft.activeSpectrum = null;
    draft.tabActiveSpectrum[draft.activeTab] = null;
  }
  if (options[draft.toolOptions.selectedTool].isFilter) {
    draft.toolOptions.selectedTool = options.zoom.id;
    draft.toolOptions.data.baseLineZones = [];
    draft.toolOptions.selectedOptionPanel = null;
    draft.tempData = null;
  }
  if (draft.toolOptions.data.activeFilterID) {
    resetSpectrumByFilter(draft, null, {}, currentActiveSpectrum);
  } else if (refreshDomain) {
    setDomain(draft);
    setMode(draft);
  }
}
function changeSpectrumSetting(draft, { id: id2, display }) {
  const state = e(draft);
  const index2 = state.data.findIndex((d) => d.id === id2);
  if (index2 !== -1) {
    draft.data[index2].display = display;
  }
}
function handleChangeSpectrumColor(draft, { id: id2, color, key }) {
  const state = e(draft);
  const index2 = state.data.findIndex((d) => d.id === id2);
  if (index2 !== -1) {
    draft.data[index2].display[key] = color;
  }
}
function handleDeleteSpectra(draft, action) {
  const state = e(draft);
  if (action.id) {
    const index2 = state.data.findIndex((d) => d.id === action.id);
    draft.data.splice(index2, 1);
  } else {
    draft.data = [];
  }
  setActiveTab(draft, { tab: draft.activeTab, refreshActiveTab: true });
}
function addMissingProjectionHandler(draft, action) {
  var _a;
  const state = e(draft);
  const { nucleus } = action;
  if ((_a = draft.activeSpectrum) == null ? void 0 : _a.id) {
    const { index: index2 } = draft.activeSpectrum;
    for (let n of nucleus) {
      const datum1D = getMissingProjection(state.data[index2], n, draft.usedColors);
      draft.data.push(datum1D);
    }
    const groupByNucleus = GroupByInfoKey("nucleus");
    const dataGroupByNucleus = groupByNucleus(draft.data);
    setTab(draft, dataGroupByNucleus, draft.activeTab, true);
    setDomain(draft);
    setMode(draft);
  }
}
function alignSpectraHandler(draft, action) {
  var _a, _b;
  if (draft.data && draft.data.length > 0) {
    for (let datum of draft.data) {
      if (((_a = datum.info) == null ? void 0 : _a.dimension) === 1 && datum.info.nucleus === draft.activeTab && !((_b = datum.info) == null ? void 0 : _b.isFid)) {
        const shift = getReferenceShift(datum, __spreadValues({}, action.payload));
        applyFilter(datum, [
          {
            name: id$4,
            options: shift
          }
        ]);
      }
    }
  }
  setDomain(draft);
  setMode(draft);
}
function generateSpectrumFromPublicationStringHandler(draft, action) {
  const publicationString = action.payload.publicationText;
  const spectrum = generateSpectrumFromPublicationString(publicationString, draft.usedColors);
  draft.data.push(spectrum);
  setActiveTab(draft);
  setZoom(draft, { scale: 0.8, spectrumID: spectrum.id });
}
const UNDO = "undo";
const REDO = "redo";
const RESET = "reset";
const getInitialState = () => ({
  actionType: "",
  data: [],
  contours: {},
  tempData: null,
  xDomain: [],
  yDomain: [],
  yDomains: {},
  xDomains: {},
  originDomain: {
    xDomain: [],
    yDomain: [],
    xDomains: {},
    yDomains: {},
    shareYDomain: false
  },
  integralsYDomains: {},
  activeTab: "",
  width: 0,
  height: 0,
  margin: {
    top: 10,
    right: 20,
    bottom: 70,
    left: 0
  },
  activeSpectrum: null,
  mode: "RTL",
  molecules: [],
  verticalAlign: {
    align: "bottom",
    verticalShift: DEFAULT_YAXIS_SHIFT_VALUE
  },
  history: {
    past: [],
    present: null,
    future: [],
    hasUndo: false,
    hasRedo: false
  },
  isLoading: false,
  keysPreferences: {},
  displayerMode: DISPLAYER_MODE.DM_1D,
  tabActiveSpectrum: {},
  spectraAnalysis: {},
  correlations: {},
  displayerKey: "",
  zoom: {
    history: {}
  },
  overDisplayer: false,
  toolOptions: {
    selectedTool: options.zoom.id,
    selectedOptionPanel: null,
    data: {
      baseLineZones: [],
      pivot: { value: 0, index: 0 },
      zonesNoiseFactor: 1,
      activeFilterID: null,
      tempRange: null,
      showMultiplicityTrees: false,
      showRangesIntegrals: true,
      showJGraph: false,
      predictionIndex: 0
    }
  },
  usedColors: { "1d": [], "2d": [] }
});
const initialState = getInitialState();
function initState(state) {
  const displayerKey = generateID();
  const correlations = buildCorrelationData([], {
    tolerance: DefaultTolerance
  });
  return __spreadProps(__spreadValues({}, state), {
    correlations,
    displayerKey,
    history: {}
  });
}
function dispatchMiddleware(dispatch) {
  const usedColors = { "1d": [], "2d": [] };
  return (action) => {
    switch (action.type) {
      case INITIATE: {
        if (action.payload) {
          const _a = migrate(action.payload), { spectra } = _a, res = __objRest(_a, ["spectra"]);
          void fromJSON$1(spectra, usedColors).then((data) => {
            action.payload = __spreadProps(__spreadValues({ spectra: data }, res), { usedColors });
            dispatch(action);
          });
        }
        break;
      }
      case LOAD_JSON_FILE: {
        const parsedData = JSON.parse(action.files[0].binary.toString());
        const data = migrate(parsedData);
        void fromJSON$1(data.spectra, usedColors).then((spectra) => {
          action.payload = Object.assign(data, { spectra, usedColors });
          dispatch(action);
        });
        break;
      }
      case LOAD_ZIP_FILE: {
        for (let zipFile of action.files) {
          void addBruker({ display: { name: zipFile.name } }, zipFile.binary, usedColors).then((data) => {
            action.payload = { data, usedColors };
            dispatch(action);
          });
        }
        break;
      }
      case LOAD_NMREDATA_FILE: {
        void nmredataToNmrium(action.file, usedColors).then((data) => {
          action.payload = Object.assign(data, { usedColors });
          dispatch(action);
        });
        break;
      }
      case PREDICT_SPECTRA: {
        const {
          mol: { molfile },
          options: options2
        } = action.payload;
        void predictSpectra(molfile).then((data) => {
          action.payload = { data, options: options2 };
          dispatch(action);
        }, () => {
          dispatch(action);
        });
        break;
      }
      default:
        action.usedColors = usedColors;
        dispatch(action);
        break;
    }
  };
}
function innerSpectrumReducer(draft, action) {
  if (![LOAD_JSON_FILE, LOAD_NMREDATA_FILE, INITIATE].includes(action.type)) {
    draft.actionType = action.type;
  }
  switch (action.type) {
    case INITIATE:
      return initiate(draft, action);
    case SET_LOADING_FLAG:
      return setIsLoading(draft, action.isLoading);
    case LOAD_JSON_FILE:
      return handleLoadJsonFile(draft, action);
    case LOAD_JCAMP_FILE:
      return loadJcampFile(draft, action);
    case LOAD_JDF_FILE:
      return loadJDFFile(draft, action);
    case LOAD_MOL_FILE:
      return handleLoadMOLFile(draft, action);
    case LOAD_ZIP_FILE:
      return handleLoadZIPFile(draft, action);
    case LOAD_NMREDATA_FILE:
      return handleLoadNmredata(draft, action);
    case ADD_PEAK:
      return addPeak(draft, action.mouseCoordinates);
    case ADD_PEAKS:
      return addPeaks(draft, action);
    case DELETE_PEAK_NOTATION:
      return deletePeak(draft, action.data);
    case ADD_INTEGRAL:
      return addIntegral(draft, action);
    case DELETE_INTEGRAL:
      return deleteIntegral(draft, action);
    case CHANGE_INTEGRAL_DATA:
      return changeIntegral(draft, action);
    case RESIZE_INTEGRAL:
      return changeIntegral(draft, action);
    case CHANGE_INTEGRAL_SUM:
      return handleChangeIntegralSum(draft, action.value);
    case CHANGE_INTEGRALS_SUM_FLAG:
      return handleChangeIntegralsSumFlag(draft, action);
    case CHANGE_INTEGRAL_RELATIVE:
      return handleChangeIntegralsRelativeValue(draft, action);
    case SET_ORIGINAL_DOMAIN:
      return setOriginalDomain(draft, action.domain);
    case SET_X_DOMAIN:
      return setXDomain(draft, action.xDomain);
    case SET_Y_DOMAIN:
      return setYDomain(draft, action.yDomain);
    case SET_WIDTH:
      return setWidth(draft, action.width);
    case SET_DIMENSIONS:
      return handleSetDimensions(draft, action.width, action.height);
    case SET_SELECTED_TOOL:
      return setSelectedTool(draft, action);
    case RESET_SELECTED_TOOL:
      return resetSelectedTool(draft);
    case SET_SELECTED_OPTIONS_PANEL:
      return setSelectedOptionPanel(draft, action.selectedOptionPanel);
    case FULL_ZOOM_OUT:
      return zoomOut(draft, action);
    case SHIFT_SPECTRUM:
      return shiftSpectrumAlongXAxis(draft, action.shiftValue);
    case APPLY_ZERO_FILLING_FILTER:
      return applyZeroFillingFilter(draft, action.value);
    case APPLY_FFT_FILTER:
      return applyFFTFilter(draft);
    case APPLY_MANUAL_PHASE_CORRECTION_FILTER:
      return applyManualPhaseCorrectionFilter(draft, action.value);
    case APPLY_AUTO_PHASE_CORRECTION_FILTER:
      return applyAutoPhaseCorrectionFilter(draft);
    case APPLY_ABSOLUTE_FILTER:
      return applyAbsoluteFilter(draft);
    case CALCULATE_MANUAL_PHASE_CORRECTION_FILTER:
      return calculateManualPhaseCorrection(draft, action.value);
    case ENABLE_FILTER:
      return enableFilter(draft, action.id, action.checked);
    case DELETE_FILTER:
      return deleteFilter(draft, action);
    case DELETE_SPECTRA_FILTER:
      return deleteSpectraFilter(draft, action);
    case SET_FILTER_SNAPSHOT:
      return filterSnapshotHandler(draft, action);
    case APPLY_MULTIPLE_SPECTRA_FILTER:
      return handleMultipleSpectraFilter(draft, action);
    case ADD_EXCLUSION_ZONE:
      return handleAddExclusionZone(draft, action);
    case DELETE_EXCLUSION_ZONE:
      return handleDeleteExclusionZone(draft, action);
    case CHANGE_VISIBILITY:
      return handleSpectrumVisibility(draft, action);
    case CHANGE_PEAKS_MARKERS_VISIBILITY:
      return handleChangePeaksMarkersVisibility(draft, action.data);
    case CHANGE_ACTIVE_SPECTRUM:
      return handleChangeActiveSpectrum(draft, action.data);
    case CHANGE_SPECTRUM_COLOR:
      return handleChangeSpectrumColor(draft, action.data);
    case CHANGE_SPECTRUM_SETTING:
      return changeSpectrumSetting(draft, action);
    case ALIGN_SPECTRA:
      return alignSpectraHandler(draft, action);
    case DELETE_SPECTRA:
      return handleDeleteSpectra(draft, action);
    case ADD_MISSING_PROJECTION:
      return addMissingProjectionHandler(draft, action);
    case GENERATE_SPECTRUM_FROM_PUBLICATION_STRING:
      return generateSpectrumFromPublicationStringHandler(draft, action);
    case TOGGLE_REAL_IMAGINARY_VISIBILITY:
      return handleToggleRealImaginaryVisibility(draft);
    case SET_ZOOM:
      return handleZoom(draft, action);
    case SET_SPECTRA_SAME_TOP:
      return setSpectraSameTopHandler(draft);
    case RESET_SPECTRA_SCALE:
      return resetSpectraScale(draft);
    case CHANGE_SPECTRUM_DISPLAY_VIEW_MODE:
      return handleChangeSpectrumDisplayMode(draft);
    case ADD_MOLECULE:
      return addMoleculeHandler(draft, action.molfile);
    case SET_MOLECULE:
      return setMoleculeHandler(draft, action.molfile, action.key);
    case DELETE_MOLECULE:
      return deleteMoleculeHandler(draft, action);
    case PREDICT_SPECTRA:
      return predictSpectraFromMoleculeHandler(draft, action);
    case FLOAT_MOLECULE_OVER_SPECTRUM:
      return floatMoleculeOverSpectrum(draft, action);
    case SET_CORRELATIONS_MF:
      return handleSetMF(draft, action.payload);
    case SET_CORRELATIONS_TOLERANCE:
      return handleSetTolerance(draft, action.payload);
    case SET_CORRELATION:
      return handleSetCorrelation(draft, action.payload);
    case SET_CORRELATIONS:
      return handleSetCorrelations(draft, action.payload);
    case DELETE_CORRELATION:
      return handleDeleteCorrelation(draft, action.payload);
    case BRUSH_END:
      return handleBrushEnd(draft, action);
    case SET_VERTICAL_INDICATOR_X_POSITION:
      return setVerticalIndicatorXPosition(draft, action.position);
    case SET_SPECTRUMS_VERTICAL_ALIGN:
      return setSpectrumsVerticalAlign(draft);
    case AUTO_PEAK_PICKING:
      return handleAutoPeakPicking(draft, action.options);
    case AUTO_ZONES_DETECTION:
      return handleAutoZonesDetection(draft, action.options);
    case CHANGE_ZONES_NOISE_FACTOR:
      return changeZonesFactorHandler(draft, action);
    case AUTO_RANGES_DETECTION:
      return handleAutoRangesDetection(draft, action.options);
    case ADD_RANGE:
      return handleAddRange(draft, action);
    case DELETE_RANGE:
      return handleDeleteRange(draft, action);
    case DELETE_1D_SIGNAL:
      return handleDeleteSignal$1(draft, action);
    case RESIZE_RANGE:
      return handleResizeRange(draft, action);
    case CHANGE_RANGE_SUM:
      return handleChangeRangeSum(draft, action.value);
    case CHANGE_RANGES_SUM_FLAG:
      return handleChangeRangesSumFlag(draft, action);
    case CHANGE_RANGE_RELATIVE:
      return handleChangeRangeRelativeValue(draft, action);
    case CHANGE_RANGE_SIGNAL_VALUE:
      return handleChangeRangeSignalValue(draft, action);
    case CHANGE_RANGE_SIGNAL_KIND:
      return handleChangeRangeSignalKind(draft, action);
    case SAVE_EDITED_RANGE:
      return handleSaveEditedRange(draft, action);
    case UNLINK_RANGE:
      return handleUnlinkRange(draft, action);
    case SET_DIAID_RANGE:
      return handleSetDiaIDRange(draft, action);
    case CHANGE_TEMP_RANGE:
      return handleChangeTempRange(draft, action);
    case SHOW_MULTIPLICTY_TREES:
      return handleShowMultiplicityTrees(draft);
    case SHOW_RANGES_INTEGRALS:
      return handleShowRangesIntegrals(draft);
    case AUTO_RANGES_SPECTRA_PICKING:
      return handleAutoSpectraRangesDetection(draft);
    case SHOW_J_GRAPH:
      return handleShowJGraph(draft);
    case SET_ACTIVE_TAB:
      return handelSetActiveTab(draft, action.tab);
    case ADD_BASE_LINE_ZONE:
      return handleAddBaseLineZone(draft, action.zone);
    case DELETE_BASE_LINE_ZONE:
      return handleDeleteBaseLineZone(draft, action.id);
    case APPLY_BASE_LINE_CORRECTION_FILTER:
      return handleBaseLineCorrectionFilter(draft, action);
    case SET_KEY_PREFERENCES:
      return setKeyPreferencesHandler(draft, action.keyCode);
    case APPLY_KEY_PREFERENCES:
      return applyKeyPreferencesHandler(draft, action.keyCode);
    case SET_2D_LEVEL:
      return levelChangeHandler(draft, action);
    case ADD_2D_ZONE:
      return add2dZoneHandler(draft, action);
    case DELETE_2D_ZONE:
      return handleDeleteZone(draft, action);
    case DELETE_2D_SIGNAL:
      return handleDeleteSignal(draft, action);
    case SET_2D_SIGNAL_PATH_LENGTH:
      return handleSetSignalPathLength(draft, action);
    case RESET_DOMAIN:
      return handelResetDomain(draft);
    case CHANGE_ZONE_SIGNAL_VALUE:
      return changeZoneSignalDelta(draft, action);
    case CHANGE_ZONE_SIGNAL_KIND:
      return handleChangeZoneSignalKind(draft, action);
    case UNLINK_ZONE:
      return handleUnlinkZone(draft, action);
    case SET_DIAID_ZONE:
      return handleSetDiaIDZone(draft, action);
    case AUTO_ZONES_SPECTRA_PICKING:
      return handleAutoSpectraZonesDetection(draft);
    case SAVE_EDITED_ZONE:
      return handleSaveEditedZone(draft, action);
    case ANALYZE_SPECTRA:
      return analyzeSpectra(draft, action);
    case DELETE_ANALYZE_SPECTRA_RANGE:
      return handleDeleteSpectraRanges(draft, action);
    case RESIZE_ANALYZE_SPECTRA_RANGE:
      return handleResizeSpectraRange(draft, action);
    case SET_ANALYZE_SPECTRA_COLUMNS:
      return handleSetColumns(draft, action);
    case FILTER_SPECTRA_COLUMN:
      return handleFilterColumn(draft, action);
    case RESURRECTING_SPECTRUM_FROM_RANGES:
      return handleRangeResurrecting(draft, action);
    case SET_AUTOMATIC_ASSIGNMENTS:
      return setAutomaticAssignmentsHandler(draft, action);
    case UNDO:
      return handleHistoryUndo(draft);
    case REDO:
      return handleHistoryRedo(draft);
    case RESET:
      return handleHistoryReset(draft, action);
    case SET_MOUSE_OVER_DISPLAYER:
      return setIsOverDisplayer(draft, action);
    default:
      return;
  }
}
const spectrumReducer = fn(innerSpectrumReducer);
const ChartContext = react.exports.createContext(initialState);
const ChartDataProvider = ChartContext.Provider;
function useChartData() {
  return react.exports.useContext(ChartContext);
}
const dispatchContext = react.exports.createContext({});
const DispatchProvider = dispatchContext.Provider;
function useDispatch() {
  return react.exports.useContext(dispatchContext);
}
function useSpectrum(defaultValue) {
  const { data, activeSpectrum } = useChartData();
  return react.exports.useMemo(() => {
    if (data && activeSpectrum && activeSpectrum.id) {
      const datum = data.find((datum2) => datum2.id === activeSpectrum.id) || defaultValue;
      return datum;
    }
    return defaultValue;
  }, [activeSpectrum, data, defaultValue]);
}
function defaultLoader() {
}
const LoaderContext = react.exports.createContext(defaultLoader);
const LoaderProvider = LoaderContext.Provider;
function useLoader() {
  return react.exports.useContext(LoaderContext);
}
const styles$1g = css`
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: rgba(255, 255, 255, 0.25);
  flex-direction: column;
  user-select: none;
  width: 100%;
  height: 100%;
  outline: 10px dashed rgba(0, 0, 0, 0.3);
  outline-offset: -10px;
  padding-left: 20px;
  padding-right: 20px;

  p {
    padding: 15px 30px;
    background-color:rgba(0, 0, 0, 0.5);
    border-radius: 39px;
    color: white;
    font-size: x-large;
    font-weight: bold;

  }
}
`;
function NoData({
  isEmpty = true,
  emptyText = "Drag and drop here a JCAMP-DX, zipped Bruker folder, Jeol jdf or NMRium file",
  canOpenLoader = true
}) {
  const openLoader = useLoader();
  if (!isEmpty) {
    return null;
  }
  return /* @__PURE__ */ jsx("div", __spreadProps(__spreadValues({
    css: styles$1g
  }, canOpenLoader && {
    onClick: openLoader
  }), {
    children: /* @__PURE__ */ jsx("p", {
      children: emptyText
    })
  }));
}
const styles$1f = css`
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: rgba(255, 255, 255, 0.25);
  height: 100%;
  flex-direction: column;
  user-select: none;
  position: absolute;
  width: 100%;

  svg {
    animation-duration: 0.5s;
    animation-name: spinAnimation;
    animation-iteration-count: infinite;
    animation-fill-mode: forwards;
    animation-direction: inherit;
    animation-timing-function: linear;
    animation-duration: 1s;
    width: 100px;
    height: 100px;
  }

  @keyframes spinAnimation {
    from {
      transform: rotate(0deg);
    }

    to {
      transform: rotate(360deg);
    }
  }
`;
function DefaultSpinnerComponent() {
  return /* @__PURE__ */ jsxs("div", {
    css: styles$1f,
    children: [/* @__PURE__ */ jsx("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 841.9 595.3",
      children: /* @__PURE__ */ jsxs("g", {
        fill: "#61DAFB",
        children: [/* @__PURE__ */ jsx("path", {
          d: "M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"
        }), /* @__PURE__ */ jsx("path", {
          d: "M520.5 78.1z"
        })]
      })
    }), /* @__PURE__ */ jsx("p", {
      children: "Loading ..."
    })]
  });
}
function defaultGetSpinner() {
  return /* @__PURE__ */ jsx$1(DefaultSpinnerComponent, {});
}
const spinnerContext = react.exports.createContext(defaultGetSpinner);
const SpinnerProvider = spinnerContext.Provider;
function Spinner({
  isLoading = true,
  emptyText = void 0
}) {
  const {
    data
  } = useChartData();
  const [checkEmpty, startCheckEmpty] = react.exports.useState(false);
  react.exports.useEffect(() => {
    let timeout = null;
    if (!isLoading) {
      timeout = setTimeout(() => {
        startCheckEmpty(true);
      }, 500);
    }
    return () => {
      clearTimeout(timeout);
    };
  }, [isLoading]);
  const getSpinner = react.exports.useContext(spinnerContext);
  return /* @__PURE__ */ jsxs$1(react.exports.Fragment, {
    children: [isLoading && getSpinner(), checkEmpty && !isLoading && /* @__PURE__ */ jsx$1(NoData, {
      isEmpty: data && data.length === 0,
      emptyText
    })]
  });
}
const styles$1e = {
  container: {
    transformOrigin: "top left",
    position: "absolute",
    top: "0px",
    left: "0px",
    zoom: "100%"
  }
};
const allowTools$1 = [options.zoom.id, options.zeroFilling.id, options.peakPicking.id, options.integral.id, options.phaseCorrection.id, options.baseLineCorrection.id, options.rangesPicking.id, options.zone2D.id, options.slicingTool.id, options.editRange.id, options.multipleSpectraAnalysis.id, options.exclusionZones.id, options.databaseRangesSelection.id];
const BRUSH_TYPE = {
  X: 1,
  Y: 2,
  XY: 3
};
const defaultDimensionBorder = {
  startX: 0,
  startY: 0
};
function BrushXY({
  brushType = BRUSH_TYPE.XY,
  dimensionBorder = defaultDimensionBorder,
  width: widthProps,
  height: heightProps
}) {
  let {
    width,
    height,
    toolOptions: {
      selectedTool
    }
  } = useChartData();
  let {
    startX,
    endX,
    startY,
    endY,
    step
  } = react.exports.useContext(BrushContext);
  if (!allowTools$1.includes(selectedTool) || step !== "brushing" || !dimensionBorder || dimensionBorder.startX && startX < dimensionBorder.startX || dimensionBorder.startY && startY < dimensionBorder.startY || (dimensionBorder.endX && Math.sign(endX - startX) === 1 ? endX > dimensionBorder.endX : endX < dimensionBorder.startX) && (dimensionBorder.endX && dimensionBorder.endY && Math.sign(endY - startY) === 1 ? endY > dimensionBorder.endY : endY < dimensionBorder.startY)) {
    return null;
  }
  width = widthProps ? widthProps : width;
  height = heightProps ? heightProps : height;
  endX = dimensionBorder.endX && endX > dimensionBorder.endX ? dimensionBorder.endX : dimensionBorder.startX && endX < dimensionBorder.startX ? dimensionBorder.startX : endX;
  endY = dimensionBorder.endY && endY > dimensionBorder.endY ? dimensionBorder.endY : dimensionBorder.startY && endY < dimensionBorder.startY ? dimensionBorder.startY : endY;
  const scaleX = brushType === BRUSH_TYPE.X || brushType === BRUSH_TYPE.XY ? (endX - startX) / width : 1;
  startX = brushType === BRUSH_TYPE.X || brushType === BRUSH_TYPE.XY ? startX : 0;
  const scaleY = brushType === BRUSH_TYPE.Y || brushType === BRUSH_TYPE.XY ? (endY - startY) / height : 1;
  startY = brushType === BRUSH_TYPE.Y || brushType === BRUSH_TYPE.XY ? startY : 0;
  return /* @__PURE__ */ jsx$1("div", {
    style: __spreadProps(__spreadValues({}, styles$1e.container), {
      transform: `translate(${startX}px, ${startY}px) scale(${scaleX},${scaleY})`,
      willChange: "transform"
    }),
    children: /* @__PURE__ */ jsx$1("svg", {
      width,
      height,
      children: /* @__PURE__ */ jsx$1("rect", {
        x: "0",
        y: "0",
        width,
        height,
        fill: "gray",
        opacity: "0.2"
      })
    })
  });
}
const styles$1d = {
  line: {
    stroke: "black",
    strokeOpacity: 1,
    shapeRendering: "crispEdges",
    strokeWidth: "1",
    willChange: "transform"
  }
};
const allowTools = [options.zoom.id, options.equalizerTool.id, options.baseLineCorrection.id, options.zone2D.id, options.slicingTool.id, options.integral.id, options.rangesPicking.id, options.editRange.id, options.multipleSpectraAnalysis.id, options.exclusionZones.id, options.databaseRangesSelection.id];
function CrossLinePointer() {
  const {
    height,
    width,
    margin,
    toolOptions: {
      selectedTool
    }
  } = useChartData();
  let position = react.exports.useContext(MouseContext);
  const brushState = react.exports.useContext(BrushContext);
  if (!allowTools.includes(selectedTool) || brushState.step === "brushing" || !position || position.x > width - margin.right || position.y > height - margin.bottom || !width || !height) {
    return null;
  }
  return /* @__PURE__ */ jsx$1("div", {
    style: {
      willChange: "transform",
      cursor: "crosshair",
      transform: `translate(${-width + position.x}px, ${-height + position.y}px)`,
      position: "absolute",
      top: 0,
      left: 0,
      pointerEvents: "none",
      overflow: "visible",
      width: 2 * width,
      height: 2 * height
    },
    children: /* @__PURE__ */ jsxs$1("svg", {
      width: 2 * width,
      height: 2 * height,
      children: [/* @__PURE__ */ jsx$1("line", {
        style: styles$1d.line,
        x1: width,
        y1: "0",
        x2: width,
        y2: height * 2
      }, "vertical_line"), /* @__PURE__ */ jsx$1("line", {
        style: styles$1d.line,
        x1: "0",
        y1: height,
        x2: width * 2,
        y2: height
      }, "horizontal_line")]
    })
  }, "crossLine");
}
const GlobalConetxt = react.exports.createContext({
  rootRef: null,
  elementsWrapperRef: null,
  viewerRef: null
});
const GlobalProvider = GlobalConetxt.Provider;
function useGlobal() {
  return react.exports.useContext(GlobalConetxt);
}
function useDraggable(props) {
  const {
    position: { x, y },
    parentElement,
    fromEdge = false,
    dragHandleClassName
  } = props;
  const isActive = react.exports.useRef(false);
  const positionRef = react.exports.useRef({ x, y });
  const [position, setPosition] = react.exports.useState({
    value: { x, y },
    action: null
  });
  const onMouseDown = react.exports.useCallback((e2) => {
    var _a;
    e2.stopPropagation();
    isActive.current = true;
    const eventTarget = e2.currentTarget;
    const classes = ((_a = e2.target.getAttribute("class")) == null ? void 0 : _a.split(" ")) || [];
    if (dragHandleClassName && classes.includes(dragHandleClassName) || !dragHandleClassName) {
      const _parentElement = parentElement ? parentElement : eventTarget == null ? void 0 : eventTarget.parentElement;
      if (_parentElement) {
        const parentBounding = _parentElement.getBoundingClientRect();
        const currentBounding = eventTarget == null ? void 0 : eventTarget.getBoundingClientRect();
        const startPosition = {
          x: parentBounding.x + (!fromEdge ? e2.clientX - currentBounding.x : 0),
          y: parentBounding.y + (!fromEdge ? e2.clientY - currentBounding.y : 0)
        };
        if (parentBounding) {
          positionRef.current = startPosition;
        }
        setPosition((prevPortion) => __spreadProps(__spreadValues({}, prevPortion), { action: "start" }));
      }
      window.addEventListener("mousemove", onMouseMove);
      window.addEventListener("mouseup", onMouseUp);
    }
    function onMouseUp(e22) {
      e22.stopPropagation();
      if (isActive.current) {
        setPosition({
          value: {
            x: e22.clientX - positionRef.current.x,
            y: e22.clientY - positionRef.current.y
          },
          action: "end"
        });
        isActive.current = false;
      }
      window.removeEventListener("mousemove", onMouseMove);
      window.removeEventListener("mouseup", onMouseUp);
    }
    function onMouseMove(e22) {
      e22.stopPropagation();
      if (isActive.current) {
        setPosition({
          value: {
            x: e22.clientX - positionRef.current.x,
            y: e22.clientY - positionRef.current.y
          },
          action: "move"
        });
      }
    }
  }, [dragHandleClassName, fromEdge, parentElement]);
  return react.exports.useMemo(() => ({
    onMouseDown,
    position,
    isActive: isActive.current
  }), [onMouseDown, position]);
}
function SVGDraggable(props) {
  const {
    children,
    initialPosition = {
      x: 0,
      y: 0
    },
    width,
    height,
    onStart,
    onMove,
    onEnd,
    parentElement,
    dragHandleClassName
  } = props;
  const {
    position: {
      value: {
        x,
        y
      },
      action
    },
    onMouseDown
  } = useDraggable({
    position: initialPosition,
    parentElement,
    dragHandleClassName
  });
  react.exports.useEffect(() => {
    const position = {
      x,
      y
    };
    switch (action) {
      case "start":
        onStart == null ? void 0 : onStart(position);
        break;
      case "move":
        onMove == null ? void 0 : onMove(position);
        break;
      case "end":
        onEnd == null ? void 0 : onEnd(position);
        break;
    }
  }, [action, onEnd, onMove, onStart, x, y]);
  return /* @__PURE__ */ jsx$1("g", {
    style: {
      transform: `translate(${x}px,${y}px)`
    },
    onMouseDown,
    children: typeof children === "function" ? children(width, height) : children
  });
}
const ConcatenationString = "___";
function buildID(prefix, suffix) {
  return `${prefix}${ConcatenationString}${suffix}`;
}
const assignmentState = {
  assignments: {},
  activated: null,
  highlighted: null
};
const assignmentContext = react.exports.createContext({
  data: assignmentState,
  dispatch: () => null
});
assignmentContext.Provider;
function useAssignmentData() {
  const context = react.exports.useContext(assignmentContext);
  if (!context) {
    throw new Error("Assignment context was not found");
  }
  return context;
}
function useAssignment(key) {
  const {
    data: { activated, highlighted, assignments },
    dispatch
  } = useAssignmentData();
  if (typeof key !== "string" && typeof key !== "number" || key === "") {
    throw new Error(`assignment key must be a non-empty string or number`);
  }
  const id2 = String(key);
  const isActive = react.exports.useMemo(() => {
    return (activated == null ? void 0 : activated.id) === id2;
  }, [activated == null ? void 0 : activated.id, id2]);
  const isOver = react.exports.useMemo(() => {
    return (highlighted == null ? void 0 : highlighted.id) === id2;
  }, [highlighted == null ? void 0 : highlighted.id, id2]);
  const assigned = react.exports.useMemo(() => {
    return assignments[id2] || null;
  }, [assignments, id2]);
  const removeAll = react.exports.useCallback((axis) => {
    dispatch({
      type: "REMOVE",
      payload: { ids: [id2], axis }
    });
  }, [dispatch, id2]);
  const toggle = react.exports.useCallback((atomIDs, dimension) => {
    dispatch({
      type: "TOGGLE",
      payload: { atomIDs, id: id2, dimension }
    });
  }, [dispatch, id2]);
  const setActive = react.exports.useCallback((axis) => {
    dispatch({
      type: "SET_ACTIVE",
      payload: {
        id: id2,
        axis
      }
    });
  }, [dispatch, id2]);
  const show = react.exports.useCallback((axis) => {
    dispatch({
      type: "SHOW",
      payload: {
        id: id2,
        axis
      }
    });
  }, [dispatch, id2]);
  const hide = react.exports.useCallback(() => {
    dispatch({
      type: "HIDE"
    });
  }, [dispatch]);
  return {
    id: id2,
    activated,
    isActive,
    isOver,
    highlighted,
    assigned,
    removeAll,
    toggle,
    setActive,
    show,
    hide
  };
}
function filterForIDsWithAssignment(assignmentData, ids) {
  return ids.filter((id2) => Object.keys(assignmentData.data).filter((_id) => _id === id2));
}
const positions = {
  TOP_LEFT: "top left",
  TOP_CENTER: "top center",
  TOP_RIGHT: "top right",
  MIDDLE_LEFT: "middle left",
  MIDDLE: "middle",
  MIDDLE_RIGHT: "middle right",
  BOTTOM_LEFT: "bottom left",
  BOTTOM_CENTER: "bottom center",
  BOTTOM_RIGHT: "bottom right"
};
const types = {
  INFO: "info",
  SUCCESS: "success",
  ERROR: "error",
  PROGRESS_INDICATOR: "progress_indicator"
};
const transitions = {
  FADE: "fade",
  SCALE: "scale",
  SLIDE_RIGHT: "slide_right",
  SLIDE_LEFT: "slide_left",
  SLIDE_TOP: "slide_top",
  SLIDE_BOTTOM: "slide_bottom"
};
const AlertContext = react.exports.createContext({});
const AlertProvider$1 = AlertContext.Provider;
function useAlert() {
  return react.exports.useContext(AlertContext);
}
const duration = 250;
const defaultStyle = {
  [transitions.FADE]: {
    transition: `opacity ${duration}ms ease`,
    opacity: 0
  },
  [transitions.SCALE]: {
    transform: "scale(1)",
    transition: `all ${duration}ms ease-in-out`
  }
};
const defaultTransitionStyles = {
  [transitions.FADE]: {
    entering: {
      opacity: 0
    },
    entered: {
      opacity: 1
    }
  },
  [transitions.SCALE]: {
    entering: {
      transform: "scale(0)"
    },
    entered: {
      transform: "scale(1)"
    },
    exiting: {
      transform: "scale(0)"
    },
    exited: {
      transform: "scale(1)"
    }
  }
};
function Transtion(_a) {
  var _b = _a, {
    children,
    type,
    transitionStyles: transitionStyles2 = defaultTransitionStyles
  } = _b, props = __objRest(_b, [
    "children",
    "type",
    "transitionStyles"
  ]);
  const ref = react.exports.useRef(null);
  return /* @__PURE__ */ jsx$1(ContainerTransition, __spreadProps(__spreadValues({
    nodeRef: ref
  }, props), {
    timeout: duration,
    children: (state) => /* @__PURE__ */ jsx$1("div", {
      ref,
      style: __spreadValues(__spreadValues(__spreadValues({}, defaultStyle[type]), transitionStyles2[type][state]), transitionStyles2.default),
      children
    })
  }));
}
function getStyles(position, containerStyle2) {
  const initialStyles = __spreadValues({
    position: "fixed",
    display: "flex",
    justifyContent: "center",
    alignItems: "center",
    flexDirection: "column",
    pointerEvents: "none",
    overflow: "visible"
  }, containerStyle2 ? {
    top: `${containerStyle2.top}px`,
    left: `${containerStyle2.left}px`,
    height: `${containerStyle2.height}px`,
    width: `${containerStyle2.width}px`
  } : {
    width: "100%",
    height: "100%"
  });
  switch (position) {
    case positions.TOP_LEFT:
      return __spreadProps(__spreadValues({}, initialStyles), {
        justifyContent: "flex-start",
        alignItems: "flex-start"
      });
    case positions.TOP_CENTER:
      return __spreadProps(__spreadValues({}, initialStyles), {
        justifyContent: "flex-start"
      });
    case positions.TOP_RIGHT:
      return __spreadProps(__spreadValues({}, initialStyles), {
        justifyContent: "flex-start",
        alignItems: "flex-end"
      });
    case positions.MIDDLE_LEFT:
      return __spreadProps(__spreadValues({}, initialStyles), {
        justifyContent: "center",
        alignItems: "flex-start"
      });
    case positions.MIDDLE: {
      return __spreadProps(__spreadValues({}, initialStyles), {
        justifyContent: "center"
      });
    }
    case positions.MIDDLE_RIGHT:
      return __spreadProps(__spreadValues({}, initialStyles), {
        justifyContent: "center",
        alignItems: "flex-end"
      });
    case positions.BOTTOM_LEFT:
      return __spreadProps(__spreadValues({}, initialStyles), {
        justifyContent: "flex-end",
        alignItems: "flex-start"
      });
    case positions.BOTTOM_CENTER:
      return __spreadProps(__spreadValues({}, initialStyles), {
        justifyContent: "flex-end"
      });
    case positions.BOTTOM_RIGHT:
      return __spreadProps(__spreadValues({}, initialStyles), {
        justifyContent: "flex-end",
        alignItems: "flex-end"
      });
    default: {
      return initialStyles;
    }
  }
}
function Wrapper(_c) {
  var _d = _c, {
    children,
    options: {
      position
    },
    containerStyle: containerStyle2
  } = _d, props = __objRest(_d, [
    "children",
    "options",
    "containerStyle"
  ]);
  const styles2 = react.exports.useMemo(() => getStyles(position, containerStyle2), [position, containerStyle2]);
  return children.length > 0 && /* @__PURE__ */ jsx$1("div", __spreadProps(__spreadValues({
    style: styles2
  }, props), {
    children
  }));
}
function groupBy(array2, fn2) {
  return array2.reduce((result, item) => {
    const key = fn2(item);
    if (!result[key])
      result[key] = [];
    result[key].push(item);
    return result;
  }, {});
}
const styles$1c = css`
  width: 40px;
  height: 40px;
  margin: 0 auto;
  :after {
    content: ' ';
    display: block;
    width: 30px;
    height: 30px;
    margin-top: 10px;
    border-radius: 50%;
    border: 4px solid;
    border-color: #fff transparent #fff transparent;
    animation: ring-animation 1s linear infinite;
  }
  @keyframes ring-animation {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }
`;
function ProgressIndicator() {
  return /* @__PURE__ */ jsx("div", {
    css: styles$1c
  });
}
function Provider$1(_e) {
  var _f = _e, {
    children,
    wrapperRef = null,
    offset = "5px",
    position = positions.BOTTOM_CENTER,
    timeout = 3e3,
    type,
    transition: transition2 = transitions.FADE
  } = _f, props = __objRest(_f, [
    "children",
    "wrapperRef",
    "offset",
    "position",
    "timeout",
    "type",
    "transition"
  ]);
  const root2 = react.exports.useRef(null);
  const timersId = react.exports.useRef([]);
  const [alerts, setAlerts] = react.exports.useState([]);
  react.exports.useEffect(() => {
    root2.current = document.createElement("div");
    const ref = root2.current;
    const timersIdRef = timersId.current;
    if (wrapperRef) {
      wrapperRef.appendChild(ref);
    }
    return () => {
      if (ref) {
        if (wrapperRef) {
          timersIdRef.forEach(clearTimeout);
          wrapperRef.removeChild(ref);
        }
      }
    };
  }, [wrapperRef]);
  const remove = react.exports.useCallback((alert2) => {
    setAlerts((currentAlerts) => {
      const lengthBeforeRemove = currentAlerts.length;
      const filteredAlerts = currentAlerts.filter((a) => a.id !== alert2.id);
      if (lengthBeforeRemove > filteredAlerts.length && alert2.options.onClose) {
        alert2.options.onClose();
      }
      return filteredAlerts;
    });
  }, []);
  const show = react.exports.useCallback((message = "", options2 = {}) => {
    const id2 = Math.random().toString(36).substr(2, 9);
    const alertOptions = __spreadValues({
      position: options2.position || position,
      timeout,
      type,
      backgroundColor: "black",
      color: "white"
    }, options2);
    const alert2 = {
      id: id2,
      message,
      options: alertOptions
    };
    alert2.close = () => remove(alert2);
    if (alert2.options.timeout) {
      const timerId = setTimeout(() => {
        remove(alert2);
        timersId.current.splice(timersId.current.indexOf(timerId), 1);
      }, alert2.options.timeout);
      timersId.current.push(timerId);
    }
    setAlerts((state) => state.concat(alert2));
    if (alert2.options.onOpen)
      alert2.options.onOpen();
    return alert2;
  }, [position, remove, timeout, type]);
  const success = react.exports.useCallback((message = "", options2 = {}) => {
    options2.type = types.SUCCESS;
    options2 = __spreadValues({
      backgroundColor: "#28ba62",
      color: "white"
    }, options2);
    return show(message, options2);
  }, [show]);
  const error = react.exports.useCallback((message = "", options2 = {}) => {
    options2.type = types.ERROR;
    options2 = __spreadValues({
      backgroundColor: "#cf3c4f",
      color: "white"
    }, options2);
    return show(message, options2);
  }, [show]);
  const info = react.exports.useCallback((message = "", options2 = {}) => {
    options2.type = types.INFO;
    options2.color = "#28ba62";
    return show(message, options2);
  }, [show]);
  const showLoading = react.exports.useCallback((message = "Process in progress", options2 = {}) => {
    options2.type = types.PROGRESS_INDICATOR;
    options2.timeout = 0;
    options2.backgroundColor = "#232323";
    return new Promise((resolve) => {
      const alert2 = show(message, options2);
      setTimeout(() => {
        resolve(() => remove(alert2));
      }, 500);
    });
  }, [remove, show]);
  const closeHandler = react.exports.useCallback((alert2) => {
    remove(alert2);
  }, [remove]);
  const alertsByPosition = groupBy(alerts, (alert2) => alert2.options.position);
  const parentStyle = react.exports.useMemo(() => {
    return wrapperRef ? wrapperRef.getBoundingClientRect() : {
      top: 0,
      left: 0,
      width: window.innerWidth,
      height: window.innerHeight
    };
  }, [wrapperRef]);
  const alertContextValue = react.exports.useMemo(() => ({
    show,
    success,
    error,
    info,
    showLoading
  }), [show, success, error, info, showLoading]);
  return /* @__PURE__ */ jsxs$1(AlertProvider$1, {
    value: alertContextValue,
    children: [children, root2.current && reactDom.exports.createPortal(/* @__PURE__ */ jsx$1(react.exports.Fragment, {
      children: Object.keys(positions).map((key) => {
        const position2 = positions[key];
        return /* @__PURE__ */ jsx$1(TransitionGroup, __spreadProps(__spreadValues({
          appear: true,
          options: {
            position: position2,
            zIndex: 999999
          },
          component: Wrapper,
          containerStyle: parentStyle
        }, props), {
          children: alertsByPosition[position2] ? alertsByPosition[position2].map((alert2) => /* @__PURE__ */ jsx$1(Transtion, {
            type: transition2,
            children: /* @__PURE__ */ jsxs$1("div", {
              style: {
                margin: offset,
                padding: "25px",
                borderRadius: "10px",
                pointerEvents: "all",
                backgroundColor: alert2.options.backgroundColor,
                color: alert2.options.color,
                minHeight: "60px",
                position: "relative"
              },
              children: [/* @__PURE__ */ jsx$1("button", {
                style: {
                  position: "absolute",
                  right: "5px",
                  top: "5px",
                  border: "none",
                  backgroundColor: "transparent",
                  color: "white"
                },
                type: "button",
                onClick: () => closeHandler(alert2),
                children: /* @__PURE__ */ jsx$1(FaTimes, {})
              }), /* @__PURE__ */ jsx$1("span", {
                children: alert2.message
              }), alert2.options.type === types.PROGRESS_INDICATOR && /* @__PURE__ */ jsx$1(ProgressIndicator, {})]
            }, alert2.id)
          }, alert2.id)) : null
        }), position2);
      })
    }), root2.current)]
  });
}
var AlertProvider = react.exports.memo(Provider$1);
var HighlightedSource = /* @__PURE__ */ ((HighlightedSource2) => {
  HighlightedSource2["PEAK"] = "PEAK";
  HighlightedSource2["INTEGRAL"] = "INTEGRAL";
  HighlightedSource2["SIGNAL"] = "SIGNAL";
  HighlightedSource2["RANGE"] = "RANGE";
  HighlightedSource2["ZONE"] = "ZONE";
  HighlightedSource2["EXCLUSION_ZONE"] = "EXCLUSION_ZONE";
  HighlightedSource2["DATABASE"] = "DATABASE";
  HighlightedSource2["UNKNOWN"] = "UNKNOWN";
  return HighlightedSource2;
})(HighlightedSource || {});
const emptyState = {
  highlight: {
    highlights: {},
    highlighted: [],
    highlightedPermanently: [],
    sourceData: null
  },
  dispatch: () => null,
  remove: () => null
};
const highlightContext = react.exports.createContext(emptyState);
function highlightReducer(state, action) {
  switch (action.type) {
    case "SHOW": {
      const {
        convertedHighlights,
        sourceData
      } = action.payload;
      const {
        type = "UNKNOWN",
        extra = null
      } = sourceData || {};
      const newState = __spreadProps(__spreadValues({}, state), {
        highlights: __spreadValues({}, state.highlights),
        sourceData: {
          type,
          extra
        }
      });
      for (const value of convertedHighlights) {
        if (!(value in newState.highlights)) {
          newState.highlights[value] = 1;
        }
      }
      newState.highlighted = Object.keys(newState.highlights);
      return newState;
    }
    case "HIDE": {
      const {
        convertedHighlights
      } = action.payload;
      const newState = __spreadProps(__spreadValues({}, state), {
        highlights: __spreadValues({}, state.highlights),
        sourceData: null
      });
      for (const value of convertedHighlights) {
        if (value in newState.highlights) {
          delete newState.highlights[value];
        }
      }
      newState.highlighted = Object.keys(newState.highlights);
      return newState;
    }
    case "SET_PERMANENT": {
      const newState = __spreadProps(__spreadValues({}, state), {
        highlightedPermanently: action.payload
      });
      return newState;
    }
    case "UNSET_PERMANENT": {
      const newState = __spreadProps(__spreadValues({}, state), {
        highlightedPermanently: []
      });
      return newState;
    }
    default: {
      throw new Error(`unknown action type: ${action.type}`);
    }
  }
}
function HighlightProvider(props) {
  const [highlight, dispatch] = react.exports.useReducer(highlightReducer, emptyState.highlight);
  const contextValue = react.exports.useMemo(() => {
    function remove() {
      dispatch({
        type: "HIDE",
        payload: {
          convertedHighlights: highlight.highlighted
        }
      });
    }
    return {
      highlight,
      dispatch,
      remove
    };
  }, [highlight]);
  return /* @__PURE__ */ jsx$1(highlightContext.Provider, {
    value: contextValue,
    children: props.children
  });
}
function useHighlightData() {
  return react.exports.useContext(highlightContext);
}
function useHighlight(highlights, sourceData = null) {
  if (!Array.isArray(highlights)) {
    throw new Error("highlights must be an array");
  }
  const {
    dispatch,
    highlight
  } = useHighlightData();
  const convertedHighlights = react.exports.useMemo(() => {
    const newHighlights = [];
    for (const highlight2 of highlights) {
      if (typeof highlight2 !== "string" && typeof highlight2 !== "number") {
        throw new Error(`highlight key must be a string or number`);
      }
      if (highlight2 !== "") {
        newHighlights.push(String(highlight2));
      }
    }
    return newHighlights;
  }, [highlights]);
  react.exports.useEffect(() => {
    return () => {
      dispatch({
        type: "HIDE",
        payload: {
          convertedHighlights: []
        }
      });
      dispatch({
        type: "UNSET_PERMANENT"
      });
    };
  }, [dispatch]);
  const isActive = react.exports.useMemo(() => {
    return highlight.highlighted.some((key) => convertedHighlights.includes(key));
  }, [convertedHighlights, highlight.highlighted]);
  const isActivePermanently = react.exports.useMemo(() => {
    return highlight.highlightedPermanently.some((key) => convertedHighlights.includes(key));
  }, [convertedHighlights, highlight.highlightedPermanently]);
  const show = react.exports.useCallback(() => {
    dispatch({
      type: "SHOW",
      payload: {
        convertedHighlights,
        sourceData
      }
    });
  }, [dispatch, convertedHighlights, sourceData]);
  const hide = react.exports.useCallback(() => {
    dispatch({
      type: "HIDE",
      payload: {
        convertedHighlights
      }
    });
  }, [convertedHighlights, dispatch]);
  const add = react.exports.useCallback((id2) => {
    dispatch({
      type: "SHOW",
      payload: {
        convertedHighlights: [],
        id: id2
      }
    });
  }, [dispatch]);
  const remove = react.exports.useCallback((id2) => {
    dispatch({
      type: "HIDE",
      payload: {
        convertedHighlights: [],
        id: id2
      }
    });
  }, [dispatch]);
  const click = react.exports.useCallback((e2) => {
    if (e2) {
      e2.preventDefault();
      e2.stopPropagation();
    }
    if (!isActivePermanently) {
      dispatch({
        type: "SET_PERMANENT",
        payload: convertedHighlights
      });
    } else {
      dispatch({
        type: "UNSET_PERMANENT"
      });
    }
  }, [convertedHighlights, dispatch, isActivePermanently]);
  return react.exports.useMemo(() => {
    return {
      isActive,
      onHover: {
        onMouseEnter: show,
        onMouseLeave: hide
      },
      onClick: click,
      show,
      hide,
      isActivePermanently,
      click,
      add,
      remove
    };
  }, [add, click, hide, isActive, isActivePermanently, remove, show]);
}
function getElements(activeTab) {
  const nuclei = activeTab.split(",");
  return nuclei.map((nucleus) => nucleus.replace(/[0-9]/g, ""));
}
function extractFromAtom(atom, activeTab, axis) {
  const elements = getElements(activeTab);
  if (elements.length > 0 && Object.keys(atom).length > 0) {
    const dim = axis === "x" ? 0 : axis === "y" ? 1 : null;
    switch (dim !== null && elements[dim]) {
      case atom.atomLabel: {
        return { oclIDs: [atom.oclID], nbAtoms: atom.nbAtoms };
      }
      case "H": {
        return {
          oclIDs: atom.hydrogenOCLIDs,
          nbAtoms: atom.nbAtoms * atom.nbHydrogens
        };
      }
      default:
        return {
          oclIDs: [atom.oclID].concat(atom.hydrogenOCLIDs),
          nbAtoms: atom.nbAtoms + atom.nbAtoms * atom.nbHydrogens
        };
    }
  }
  return { oclIDs: [], nbAtoms: 0 };
}
function findDatumAndSignalIndex(data, id2) {
  let datum = data.find((_datum) => _datum.id === id2);
  let signalIndex;
  if (!datum) {
    for (const record of data) {
      signalIndex = record.signals.findIndex((signal) => signal.id === id2);
      if (signalIndex >= 0) {
        datum = record;
        break;
      }
    }
  }
  return { datum, signalIndex };
}
function getHighlightsOnHover(assignments, oclIDs, data) {
  var _a;
  let highlights = [];
  const assignmentsByKey = assignments.data.assignments;
  for (const key in assignmentsByKey) {
    const assignments2 = assignmentsByKey[key];
    for (const axis in assignments2) {
      if ((_a = assignments2[axis]) == null ? void 0 : _a.some((oclKey) => oclIDs.includes(oclKey))) {
        highlights = highlights.concat(assignments2[axis]);
        const { datum, signalIndex } = findDatumAndSignalIndex(data, key);
        if (datum) {
          highlights.push(datum.id);
          if (signalIndex !== void 0) {
            highlights.push(datum.signals[signalIndex].id);
          }
        }
      }
    }
  }
  return highlights;
}
function getCurrentDiaIDsToHighlight(assignmentData) {
  const { highlighted, assignments } = assignmentData.data;
  const assignment = highlighted ? assignments[highlighted.id] : null;
  const axisHover = highlighted ? highlighted.axis : null;
  if (axisHover && assignment && assignment[axisHover]) {
    return assignment[axisHover];
  } else {
    return ((assignment == null ? void 0 : assignment.x) || []).concat((assignment == null ? void 0 : assignment.y) || []);
  }
}
function toggleDiaIDs(diaIDs, atomInformation) {
  let _diaIDs = diaIDs ? diaIDs.slice() : [];
  const { nbAtoms, oclIDs } = atomInformation;
  let tempNbAtoms = nbAtoms;
  oclIDs.forEach((_oclID) => {
    if (_diaIDs.includes(_oclID)) {
      tempNbAtoms *= -1;
      _diaIDs = _diaIDs.filter((_id) => _id !== _oclID);
    } else {
      _diaIDs.push(_oclID);
    }
  });
  return [_diaIDs, tempNbAtoms];
}
function useAtomAssignment({
  displayerMode,
  activeTab: nucleus,
  zones,
  ranges
}) {
  var _a;
  const alert2 = useAlert();
  const dispatch = useDispatch();
  const highlightData = useHighlightData();
  const assignments = useAssignmentData();
  const activeAssignment = useAssignment(assignments.data.activated ? assignments.data.activated.id : ConcatenationString);
  const [onAtomHoverHighlights, setOnAtomHoverHighlights] = react.exports.useState([]);
  const [onAtomHoverAction, setOnAtomHoverAction] = react.exports.useState(null);
  react.exports.useEffect(() => {
    if (onAtomHoverAction) {
      if (onAtomHoverAction === "show") {
        highlightData.dispatch({
          type: "SHOW",
          payload: {
            convertedHighlights: onAtomHoverHighlights
          }
        });
      } else if (onAtomHoverAction === "hide") {
        highlightData.dispatch({
          type: "HIDE",
          payload: {
            convertedHighlights: onAtomHoverHighlights
          }
        });
        setOnAtomHoverHighlights([]);
      }
      setOnAtomHoverAction(null);
    }
  }, [onAtomHoverAction, onAtomHoverHighlights, highlightData]);
  const data = react.exports.useMemo(() => {
    if (zones || ranges) {
      if (displayerMode === DISPLAYER_MODE.DM_1D && ranges && ranges.values) {
        return ranges.values;
      } else if (displayerMode === DISPLAYER_MODE.DM_2D && zones && zones.values) {
        return zones.values;
      }
    }
    return [];
  }, [displayerMode, ranges, zones]);
  const assignedDiaIDs = react.exports.useMemo(() => {
    const assignedDiaID = {
      x: [],
      y: []
    };
    const assignment = assignments.data.assignments;
    for (let id2 in assignment) {
      if (assignment[id2].x) {
        assignedDiaID.x.push(...assignment[id2].x);
      }
      if (assignment[id2].y) {
        assignedDiaID.y.push(...assignment[id2].y);
      }
    }
    return assignedDiaID;
  }, [assignments.data]);
  const assignedDiaIDsMerged = react.exports.useMemo(() => assignedDiaIDs.x.concat(assignedDiaIDs.y), [assignedDiaIDs.x, assignedDiaIDs.y]);
  const currentDiaIDsToHighlight = react.exports.useMemo(() => {
    let highlights = [];
    highlightData.highlight.highlighted.forEach((highlightID) => {
      var _a2;
      const temp = assignments.data.assignments[highlightID];
      if (temp) {
        const {
          datum
        } = findDatumAndSignalIndex(data, highlightID);
        const type = (_a2 = highlightData.highlight.sourceData) == null ? void 0 : _a2.type;
        if (datum && (type === HighlightedSource.ZONE || type === HighlightedSource.RANGE)) {
          highlights = highlights.concat(datum.signals.map((signal) => filterForIDsWithAssignment(assignments, [signal.id]).length > 0 ? signal.diaIDs : []).flat());
        }
      }
    });
    return getCurrentDiaIDsToHighlight(assignments).concat(highlights);
  }, [assignments, data, highlightData.highlight.highlighted, (_a = highlightData.highlight.sourceData) == null ? void 0 : _a.type]);
  const toggleAssignment = react.exports.useCallback((diaID, atomInformation) => {
    return toggleDiaIDs(diaID, atomInformation);
  }, []);
  const handleOnClickAtom = react.exports.useCallback((atom, event) => {
    var _a2, _b, _c;
    if (!checkModifierKeyActivated(event) && activeAssignment.activated) {
      const {
        axis,
        id: id2
      } = activeAssignment.activated;
      if (id2 && axis) {
        const atomInformation = extractFromAtom(atom, nucleus, axis);
        if (atomInformation.nbAtoms > 0) {
          const dimension = displayerMode === DISPLAYER_MODE.DM_1D ? "1D" : "2D";
          activeAssignment.toggle(atomInformation.oclIDs, dimension);
          const {
            datum,
            signalIndex
          } = findDatumAndSignalIndex(data, activeAssignment.id);
          if (datum) {
            if (displayerMode === DISPLAYER_MODE.DM_1D) {
              const range2 = datum;
              let _diaIDs = [];
              if (signalIndex === void 0) {
                _diaIDs = (range2 == null ? void 0 : range2.diaIDs) || [];
              } else {
                _diaIDs = ((_a2 = range2 == null ? void 0 : range2.signals[signalIndex]) == null ? void 0 : _a2.diaIDs) || [];
              }
              const [_diaID, nbAtoms] = toggleAssignment(_diaIDs, atomInformation);
              dispatch({
                type: SET_DIAID_RANGE,
                payload: {
                  nbAtoms,
                  rangeData: datum,
                  diaIDs: _diaID,
                  signalIndex
                }
              });
            } else {
              const zone = datum;
              let _diaIDs = [];
              if (signalIndex === void 0) {
                _diaIDs = ((_b = zone[axis]) == null ? void 0 : _b.diaIDs) || [];
              } else {
                _diaIDs = ((_c = zone == null ? void 0 : zone.signals[signalIndex][axis]) == null ? void 0 : _c.diaIDs) || [];
              }
              const [_diaID, nbAtoms] = toggleAssignment(_diaIDs, atomInformation);
              dispatch({
                type: SET_DIAID_ZONE,
                payload: {
                  nbAtoms,
                  zoneData: datum,
                  diaIDs: _diaID,
                  axis,
                  signalIndex
                }
              });
            }
          }
          activeAssignment.setActive(axis);
        } else {
          alert2.info("Not assigned! Different atom type or no attached hydrogens found!");
        }
      }
    }
  }, [activeAssignment, alert2, data, dispatch, displayerMode, nucleus, toggleAssignment]);
  const handleOnAtomHover = react.exports.useCallback((atom) => {
    const {
      oclIDs
    } = extractFromAtom(atom, nucleus);
    if (oclIDs.length > 0) {
      const highlights = getHighlightsOnHover(assignments, oclIDs, data);
      setOnAtomHoverHighlights(highlights);
      setOnAtomHoverAction("show");
    } else {
      setOnAtomHoverAction("hide");
    }
  }, [assignments, data, nucleus]);
  return {
    handleOnAtomHover,
    handleOnClickAtom,
    currentDiaIDsToHighlight,
    assignedDiaIDsMerged
  };
}
const colorPalettes = {
  success: {
    base: "#2dd36f",
    shade: "#28ba62",
    tint: "#42d77d"
  },
  danger: {
    base: "#eb445a",
    shade: "#cf3c4f",
    tint: "#ed576b"
  },
  warning: {
    base: "#ffc409",
    shade: "#e0ac08",
    tint: "#ffca22"
  },
  medium: {
    base: "#92949c",
    shade: "#808289",
    tint: "#9d9fa6"
  },
  light: {
    base: "#f4f5f8",
    shade: "#d7d8da",
    tint: "#f5f6f9"
  }
};
const sizeConfig = {
  xSmall: {
    fontSize: "0.75rem",
    padding: "0.15rem 0.3rem",
    borderRadius: "0.15rem"
  },
  small: {
    fontSize: "0.8rem",
    padding: "0.25rem 0.5rem",
    borderRadius: "0.2rem"
  },
  medium: {
    fontSize: "1rem",
    padding: "0.375rem 0.75rem",
    borderRadius: "0.25rem"
  },
  large: {
    fontSize: "1.25rem",
    padding: "0.5rem 1rem",
    borderRadius: "0.3rem"
  }
};
function getFillStyle(props) {
  const {
    borderColor,
    fill,
    backgroundColor,
    color
  } = props;
  switch (fill) {
    case "solid": {
      return css`
        border-color: transparent;
        background-color: ${backgroundColor.base};
        color: ${color.hover};
      `;
    }
    case "outline": {
      return css`
        border-style: solid;
        border-color: ${backgroundColor.base};
        background-color: transparent;
        color: ${color.base};
      `;
    }
    case "clear": {
      return css`
        border-color: transparent;
        background-color: transparent;
        color: ${color.base};
      `;
    }
    default:
      return css`
        background-color: ${backgroundColor.base};
        color: ${color.base};
        border-color: ${borderColor};
      `;
  }
}
const styles$1b = {
  button: (props) => {
    const {
      size,
      backgroundColor,
      color,
      borderRadius
    } = props;
    const basic2 = css`
      display: flex;
      flex-direction: row;
      border-width: 1px;
      align-items: center;
    `;
    const fillStyle = getFillStyle(props);
    const colorStyle = css`
      &:not([disabled]):hover {
        background-color: ${backgroundColor.hover};
        color: ${color.hover};
      }
      &:not([disabled]):active {
        background-color: ${(backgroundColor == null ? void 0 : backgroundColor.active) || backgroundColor.hover};
        color: ${(color == null ? void 0 : color.active) || color.hover};
      }

      &:disabled {
        opacity: 0.25;
      }
    `;
    return css([basic2, sizeConfig[size], fillStyle, colorStyle, {
      borderRadius
    }]);
  }
};
const Button = (props) => {
  const _a = props, {
    onClick,
    size = "small",
    color = {
      base: "black",
      hover: "white"
    },
    backgroundColor = {
      base: "white",
      hover: "black",
      active: "black"
    },
    borderColor = "transparent",
    fill,
    borderRadius,
    style: style2 = {}
  } = _a, restProps = __objRest(_a, [
    "onClick",
    "size",
    "color",
    "backgroundColor",
    "borderColor",
    "fill",
    "borderRadius",
    "style"
  ]);
  return /* @__PURE__ */ jsx("button", __spreadProps(__spreadValues({
    type: "button",
    onClick,
    css: [styles$1b.button({
      size,
      backgroundColor,
      color,
      borderColor,
      fill,
      borderRadius
    }), style2]
  }, restProps), {
    children: /* @__PURE__ */ jsxs("span", {
      style: {
        flex: 1,
        pointerEvents: "none"
      },
      children: [" ", props.children]
    })
  }));
};
function ThemeButton(props) {
  const _a = props, {
    colorTheme
  } = _a, buttonProps = __objRest(_a, [
    "colorTheme"
  ]);
  const {
    base: base2,
    shade,
    tint
  } = colorPalettes[props.colorTheme];
  const _b = buttonProps, {
    color = {
      base: shade,
      hover: "white"
    },
    backgroundColor = {
      base: base2,
      hover: shade,
      active: tint
    },
    fill = "solid"
  } = _b, restProps = __objRest(_b, [
    "color",
    "backgroundColor",
    "fill"
  ]);
  return /* @__PURE__ */ jsx(Button, __spreadProps(__spreadValues({
    fill
  }, restProps), {
    backgroundColor,
    color
  }));
}
Button.Done = (props) => {
  return /* @__PURE__ */ jsx(ThemeButton, __spreadProps(__spreadValues({}, props), {
    colorTheme: "success"
  }));
};
Button.Danger = (props) => {
  return /* @__PURE__ */ jsx(ThemeButton, __spreadProps(__spreadValues({}, props), {
    colorTheme: "danger"
  }));
};
Button.Action = (props) => {
  return /* @__PURE__ */ jsx(ThemeButton, __spreadProps(__spreadValues({}, props), {
    colorTheme: "medium"
  }));
};
function ActionsButton({
  onFloatBtnClick
}) {
  return /* @__PURE__ */ jsxs$1("div", {
    "data-no-export": "true",
    style: {
      display: "flex",
      zIndex: 0
    },
    children: [/* @__PURE__ */ jsx$1(Button.Action, {
      style: {
        fontSize: "14px"
      },
      fill: "clear",
      className: "handle",
      children: /* @__PURE__ */ jsx$1(BsArrowsMove, {})
    }), /* @__PURE__ */ jsx$1(Button.Danger, {
      style: {
        fontSize: "14px"
      },
      fill: "clear",
      onClick: onFloatBtnClick,
      children: /* @__PURE__ */ jsx$1(FaTimes, {})
    })]
  });
}
const style$b = css`
  border: 1px solid transparent;
  button {
    visibility: hidden;
  }

  &:hover {
    border: 1px solid #ebecf1;
    background-color: white;
    button {
      visibility: visible;
    }
  }
`;
function DraggableStructure(props) {
  const {
    zones,
    ranges,
    molecule,
    activeTab,
    displayerMode,
    index: index2
  } = props;
  const {
    viewerRef
  } = useGlobal();
  const dispatch = useDispatch();
  const {
    currentDiaIDsToHighlight,
    handleOnAtomHover,
    handleOnClickAtom,
    assignedDiaIDsMerged
  } = useAtomAssignment({
    zones,
    ranges,
    activeTab,
    displayerMode
  });
  const floatMoleculeHandler = react.exports.useCallback(() => {
    dispatch({
      type: FLOAT_MOLECULE_OVER_SPECTRUM,
      payload: {
        key: molecule.key
      }
    });
  }, [dispatch, molecule]);
  return /* @__PURE__ */ jsx(SVGDraggable, {
    width: 150,
    height: 100,
    initialPosition: {
      x: 100,
      y: 50
    },
    dragHandleClassName: "handle",
    parentElement: viewerRef,
    children: (width, height) => /* @__PURE__ */ jsxs("foreignObject", {
      width,
      height: height + 30,
      "data-replace-float-structure": "true",
      css: style$b,
      children: [/* @__PURE__ */ jsx(ActionsButton, {
        onFloatBtnClick: floatMoleculeHandler
      }), /* @__PURE__ */ jsx(OCLnmr, {
        OCL: full,
        autoCrop: true,
        id: `molSVG${index2 || ""}`,
        width: width - 20,
        height,
        molfile: molecule.molfile,
        setSelectedAtom: handleOnClickAtom,
        atomHighlightColor: (currentDiaIDsToHighlight == null ? void 0 : currentDiaIDsToHighlight.length) > 0 ? "red" : "#FFD700",
        atomHighlightOpacity: 0.35,
        highlights: (currentDiaIDsToHighlight == null ? void 0 : currentDiaIDsToHighlight.length) > 0 ? currentDiaIDsToHighlight : assignedDiaIDsMerged,
        setHoverAtom: handleOnAtomHover,
        setMolfile: () => null
      })]
    })
  }, molecule.key);
}
function FloatMoleculeStructuresInner(props) {
  const {
    zones,
    ranges,
    molecules,
    activeTab,
    displayerMode
  } = props;
  if (!molecules || molecules.length === 0)
    return null;
  return /* @__PURE__ */ jsx$1("g", {
    children: molecules.filter((molecule) => molecule.isFloat).map((molecule) => /* @__PURE__ */ jsx$1(DraggableStructure, {
      zones,
      ranges,
      activeTab,
      displayerMode,
      molecule
    }, molecule.key))
  });
}
const MemoizedFloatMoleculeStructures = react.exports.memo(FloatMoleculeStructuresInner);
const emptyData$d = {
  ranges: {},
  zones: {}
};
function FloatMoleculeStructures() {
  const {
    molecules,
    displayerMode,
    activeTab
  } = useChartData();
  const data = useSpectrum(emptyData$d);
  const ranges = (data == null ? void 0 : data.ranges) || {};
  const zones = (data == null ? void 0 : data.zones) || {};
  return /* @__PURE__ */ jsx$1(MemoizedFloatMoleculeStructures, {
    molecules,
    displayerMode,
    activeTab,
    ranges,
    zones
  });
}
function useStateWithLocalStorage(localStorageKey, key) {
  const [value, setValue] = react.exports.useState(localStorage.getItem(localStorageKey) || "{}");
  react.exports.useEffect(() => {
    localStorage.setItem(localStorageKey, value);
  }, [localStorageKey, value]);
  const setData2 = react.exports.useCallback((data, key2 = null) => {
    let castData = JSON.parse(value);
    if (key2) {
      set_1(castData, key2, data);
    } else {
      castData = __spreadValues(__spreadValues({}, castData), data);
    }
    setValue(JSON.stringify(castData));
  }, [value]);
  return react.exports.useMemo(() => {
    return [
      key ? get_1(JSON.parse(value), key, {}) : JSON.parse(value),
      setData2
    ];
  }, [key, setData2, value]);
}
function getLocalStorage(localStorageKey, isJson = true) {
  const settings = localStorage.getItem(localStorageKey);
  return settings && isJson ? JSON.parse(settings) : settings;
}
function storeData(localStorageKey, value) {
  localStorage.setItem(localStorageKey, value);
}
function removeData(localStorageKey) {
  localStorage.removeItem(localStorageKey);
}
function getValue(object, keyPath, defaultValue = null) {
  return get_1(object, keyPath, defaultValue);
}
const basic = {
  version: 1,
  label: "Default workspace",
  display: {
    general: {
      disableMultipletAnalysis: false,
      hideSetSumFromMolecule: false,
      hideGeneralSettings: false,
      experimentalFeatures: { display: true }
    },
    panels: {
      spectraPanel: { display: true, open: true },
      informationPanel: { display: true, open: false },
      peaksPanel: { display: true, open: false },
      integralsPanel: { display: true, open: false },
      rangesPanel: { display: true, open: false },
      structuresPanel: { display: true, open: false },
      filtersPanel: { display: true, open: false },
      zonesPanel: { display: true, open: false },
      summaryPanel: { display: false, open: false },
      multipleSpectraAnalysisPanel: { display: false, open: false },
      databasePanel: { display: false, open: false },
      predictionPanel: { display: false, open: false }
    }
  },
  controllers: {
    dimmedSpectraTransparency: 0.1
  },
  formatting: {
    nuclei: {
      "1h": { name: "1H", ppm: "0.00", hz: "0.00" },
      "13c": { name: "13C", ppm: "0.00", hz: "0.00" },
      "15n": { name: "15N", ppm: "0.00", hz: "0.00" },
      "19f": { name: "19F", ppm: "0.00", hz: "0.00" },
      "29si": { name: "29Si", ppm: "0.00", hz: "0.00" },
      "31p": { name: "31P", ppm: "0.00", hz: "0.00" }
    },
    panels: {}
  },
  databases: [
    {
      label: "Toc",
      url: "https://data.cheminfo.org/nmr/database/toc.json",
      enabled: true
    }
  ]
};
const embedded = {
  version: 1,
  label: "Embedded workspace",
  display: {
    general: {
      disableMultipletAnalysis: false,
      hideSetSumFromMolecule: false,
      hideGeneralSettings: false,
      experimentalFeatures: { display: true },
      hidePanelOnLoad: true
    },
    panels: {
      spectraPanel: { display: true, open: true },
      informationPanel: { display: true, open: false },
      peaksPanel: { display: true, open: false },
      integralsPanel: { display: true, open: false },
      rangesPanel: { display: true, open: false },
      structuresPanel: { display: true, open: false },
      filtersPanel: { display: true, open: false },
      zonesPanel: { display: true, open: false },
      summaryPanel: { display: false, open: false },
      multipleSpectraAnalysisPanel: { display: false, open: false },
      databasePanel: { display: false, open: false },
      predictionPanel: { display: false, open: false }
    }
  },
  controllers: basic.controllers,
  formatting: basic.formatting,
  databases: basic.databases
};
const exercise = {
  version: 1,
  label: "Exercise workspace",
  display: {
    general: {
      disableMultipletAnalysis: true,
      hideSetSumFromMolecule: true,
      hideGeneralSettings: true,
      experimentalFeatures: { hidden: true }
    },
    panels: {
      spectraPanel: { display: true, open: true },
      informationPanel: { hidden: true },
      peaksPanel: { hidden: true },
      integralsPanel: { display: true },
      rangesPanel: { hidden: true },
      structuresPanel: { hidden: true },
      filtersPanel: { hidden: true },
      zonesPanel: { hidden: true },
      summaryPanel: { hidden: true },
      multipleSpectraAnalysisPanel: { hidden: true },
      databasePanel: { hidden: true },
      predictionPanel: { hidden: true }
    },
    toolBarButtons: {
      zoomTool: true,
      zoomOutTool: true,
      import: false,
      exportAs: false,
      spectraStackAlignments: true,
      spectraCenterAlignments: true,
      realImaginary: false,
      peakTool: true,
      integralTool: true,
      zonePickingTool: false,
      slicingTool: false,
      autoRangesTool: false,
      zeroFillingTool: false,
      phaseCorrectionTool: false,
      baseLineCorrectionTool: false,
      FFTTool: false,
      multipleSpectraAnalysisTool: false,
      exclusionZonesTool: false
    }
  },
  controllers: basic.controllers,
  formatting: basic.formatting,
  databases: basic.databases
};
const prediction = {
  version: 1,
  label: "Prediction workspace",
  display: {
    general: {
      experimentalFeatures: { display: false }
    },
    panels: {
      spectraPanel: { display: true },
      rangesPanel: { display: true },
      zonesPanel: { display: true },
      predictionPanel: { display: true, open: true },
      informationPanel: { display: false },
      peaksPanel: { display: false },
      integralsPanel: { display: false },
      structuresPanel: { display: false },
      filtersPanel: { display: false },
      summaryPanel: { display: false },
      multipleSpectraAnalysisPanel: { display: false },
      databasePanel: { display: false }
    }
  },
  controllers: basic.controllers,
  formatting: basic.formatting,
  databases: basic.databases
};
const process1D = {
  version: 1,
  label: "Process 1D workspace",
  display: {
    general: {
      disableMultipletAnalysis: true
    },
    panels: {
      zonesPanel: { display: true },
      summaryPanel: { display: true },
      multipleSpectraAnalysisPanel: { display: true, open: true },
      spectraPanel: { display: true, open: true },
      informationPanel: { hidden: true },
      peaksPanel: { hidden: true },
      integralsPanel: { hidden: true },
      rangesPanel: { hidden: true },
      structuresPanel: { hidden: true },
      filtersPanel: { hidden: true },
      databasePanel: { hidden: true },
      predictionPanel: { hidden: true }
    },
    toolBarButtons: {
      import: false,
      exportAs: false,
      autoRangesTool: false,
      multipleSpectraAnalysisTool: false,
      exclusionZonesTool: false
    }
  },
  controllers: basic.controllers,
  formatting: basic.formatting,
  databases: basic.databases
};
var workspaces = { exercise, default: basic, process1D, prediction, embedded };
const LOCAL_STORAGE_VERSION = 7;
const WORKSPACES = [
  {
    key: "default",
    label: workspaces.default.label
  },
  {
    key: "process1D",
    label: workspaces.process1D.label
  },
  {
    key: "exercise",
    label: workspaces.exercise.label
  },
  {
    key: "prediction",
    label: workspaces.prediction.label
  },
  {
    key: "embedded",
    label: workspaces.embedded.label
  }
];
function getPreferencesByWorkspace(workspace) {
  return (workspaces == null ? void 0 : workspaces[workspace]) || {};
}
function getActiveWorkspace(draft) {
  return draft.workspaces[draft.workspace.current || "default"];
}
const preferencesInitialState = {
  version: LOCAL_STORAGE_VERSION,
  workspaces: {},
  dispatch: () => null,
  workspace: {
    current: "default",
    base: null
  }
};
function filterObject(data) {
  return JSON.parse(JSON.stringify(data), (key, value) => {
    if ((value == null ? void 0 : value.hidden) !== true) {
      return value;
    }
  });
}
function FlatObject(data) {
  let result = {};
  JSON.parse(JSON.stringify(data), (key, value) => {
    if ((value == null ? void 0 : value.hidden) !== true && key) {
      result[key] = result[key]++ || 1;
    }
  });
  return result;
}
function checkKeysExists(sourceObject, targetObject) {
  const source = FlatObject(sourceObject);
  const target = FlatObject(targetObject);
  if (Object.keys(target).length === 0) {
    return false;
  }
  for (const [key, value] of Object.entries(source)) {
    if (!target[key] || target[key] !== value) {
      return false;
    }
  }
  return true;
}
function mapNucleiFormatting(formatting) {
  const _a = formatting, { nuclei } = _a, res = __objRest(_a, ["nuclei"]);
  const _nuclei = Object.keys(nuclei).reduce((nucleusFormatting, key) => {
    nucleusFormatting[nuclei[key].name.trim().toLowerCase()] = nuclei[key];
    return nucleusFormatting;
  }, {});
  return __spreadValues({ nuclei: _nuclei }, res);
}
function initPreferencesState(state) {
  const nmrLocalStorageVersion = getLocalStorage("nmr-local-storage-version", false);
  let localData = getLocalStorage("nmr-general-settings");
  if (nmrLocalStorageVersion && (localData == null ? void 0 : localData.version)) {
    removeData("nmr-local-storage-version");
  }
  if (!(localData == null ? void 0 : localData.version) || (localData == null ? void 0 : localData.version) !== LOCAL_STORAGE_VERSION) {
    removeData("nmr-general-settings");
  }
  return __spreadProps(__spreadValues({}, state), {
    workspaces: (localData == null ? void 0 : localData.workspaces) || { default: workspaces.default }
  });
}
function handleInit(draft, action) {
  if (action.payload) {
    const localData = getLocalStorage("nmr-general-settings");
    const _a = action.payload, { dispatch, workspace } = _a, resProps = __objRest(_a, ["dispatch", "workspace"]);
    draft.workspace = !workspace && (localData == null ? void 0 : localData.currentWorkspace) ? { current: localData.currentWorkspace, base: null } : { current: workspace || "default", base: workspace };
    const workspacePreferences = merge_1({}, getPreferencesByWorkspace(draft.workspace.current), resProps);
    const currentWorkspacePreferences = getActiveWorkspace(draft);
    if (workspaces[draft.workspace.current] && (!currentWorkspacePreferences || (workspacePreferences == null ? void 0 : workspacePreferences.version) !== (currentWorkspacePreferences == null ? void 0 : currentWorkspacePreferences.version) || !checkKeysExists(workspacePreferences.display, currentWorkspacePreferences == null ? void 0 : currentWorkspacePreferences.display)) || !localData) {
      const {
        workspaces: workspaces2,
        version,
        workspace: { current }
      } = draft || {};
      const display = filterObject(workspacePreferences.display);
      const data = __spreadProps(__spreadValues({
        version
      }, (localData == null ? void 0 : localData.currentWorkspace) && {
        currentWorkspace: localData == null ? void 0 : localData.currentWorkspace
      }), {
        workspaces: __spreadProps(__spreadValues({}, workspaces2), {
          [current]: __spreadProps(__spreadValues({}, workspacePreferences), {
            display
          })
        })
      });
      draft.workspaces[current] = merge_1({}, currentWorkspacePreferences, workspacePreferences);
      storeData("nmr-general-settings", JSON.stringify(data));
    } else {
      currentWorkspacePreferences.display = merge_1({}, workspacePreferences.display, currentWorkspacePreferences.display);
    }
    draft.dispatch = dispatch;
  }
}
function handleSetPreferences(draft, action) {
  if (action.payload) {
    const currentWorkspacePreferences = getActiveWorkspace(draft);
    let { controllers, formatting, display, databases: databases2 } = action.payload;
    formatting = mapNucleiFormatting(formatting);
    let localData = getLocalStorage("nmr-general-settings");
    localData.currentWorkspace = draft.workspace.current;
    localData.workspaces = __spreadProps(__spreadValues({}, localData.workspaces), {
      [draft.workspace.current]: __spreadProps(__spreadValues({}, localData.workspaces[draft.workspace.current]), {
        controllers,
        formatting,
        display,
        databases: databases2
      })
    });
    storeData("nmr-general-settings", JSON.stringify(localData));
    currentWorkspacePreferences.controllers = controllers;
    currentWorkspacePreferences.formatting = formatting;
    currentWorkspacePreferences.databases = databases2;
    currentWorkspacePreferences.display = __spreadProps(__spreadValues({}, currentWorkspacePreferences.display), {
      panels: display.panels,
      general: __spreadProps(__spreadValues({}, currentWorkspacePreferences.display.general || {}), {
        experimentalFeatures: display.general.experimentalFeatures
      })
    });
  }
}
function handleSetPanelsPreferences(draft, action) {
  if (action.payload) {
    const currentWorkspacePreferences = getActiveWorkspace(draft);
    const { key, value } = action.payload;
    let localData = getLocalStorage("nmr-general-settings");
    localData.workspaces[draft.workspace.current].formatting.panels[key] = value;
    storeData("nmr-general-settings", JSON.stringify(localData));
    currentWorkspacePreferences.formatting.panels[key] = value;
  }
}
function handleResetPreferences(draft) {
  const currentWorkspacePreferences = getActiveWorkspace(draft);
  let localData = getLocalStorage("nmr-general-settings");
  const workSpaceDisplayPreferences = getPreferencesByWorkspace(draft.workspace.current).display;
  if (localData.workspaces[draft.workspace.current]) {
    localData.workspaces[draft.workspace.current].display = workSpaceDisplayPreferences;
    storeData("nmr-general-settings", JSON.stringify(localData));
  }
  currentWorkspacePreferences.display = workSpaceDisplayPreferences;
}
function handleSetWorkspace(draft, action) {
  const workspaceKey = action.payload.workspace;
  if (!draft.workspaces[workspaceKey]) {
    draft.workspaces[workspaceKey] = getPreferencesByWorkspace(workspaceKey);
  }
  draft.workspace.current = workspaceKey;
}
function handleAddWorkspace(draft, action) {
  const {
    workspace: workspaceName,
    data: { display, controllers, formatting, databases: databases2 }
  } = action.payload;
  const newWorkSpace = {
    version: 1,
    label: workspaceName,
    display,
    controllers,
    formatting,
    databases: databases2
  };
  const newWorkspaceKey = generateID();
  const localData = getLocalStorage("nmr-general-settings");
  localData.workspaces[newWorkspaceKey] = newWorkSpace;
  storeData("nmr-general-settings", JSON.stringify(localData));
  draft.workspaces[newWorkspaceKey] = newWorkSpace;
  draft.workspace.current = newWorkspaceKey;
}
function handleRemoveWorkspace(draft, action) {
  var _a;
  const { workspace } = action.payload;
  if (workspace === draft.workspace.current) {
    draft.workspace.current = "default";
  }
  let localData = getLocalStorage("nmr-general-settings");
  const storedWorkspaces = ((_a = e(draft)) == null ? void 0 : _a.workspaces) || {};
  const workspaces2 = Object.keys(storedWorkspaces).reduce((acc, key) => {
    if (key !== workspace) {
      acc[key] = storedWorkspaces[key];
    }
    return acc;
  }, {});
  draft.workspaces = workspaces2;
  localData.workspaces = filterObject(workspaces2);
  storeData("nmr-general-settings", JSON.stringify(localData));
}
function innerPreferencesReducer(draft, action) {
  switch (action.type) {
    case "INIT_PREFERENCES":
      return handleInit(draft, action);
    case "SET_PREFERENCES":
      return handleSetPreferences(draft, action);
    case "SET_PANELS_PREFERENCES":
      return handleSetPanelsPreferences(draft, action);
    case "RESET_PREFERENCES":
      return handleResetPreferences(draft);
    case "SET_WORKSPACE":
      return handleSetWorkspace(draft, action);
    case "ADD_WORKSPACE":
      return handleAddWorkspace(draft, action);
    case "REMOVE_WORKSPACE":
      return handleRemoveWorkspace(draft, action);
    default:
      return draft;
  }
}
const preferencesReducer = fn(innerPreferencesReducer);
const PreferencesContext = react.exports.createContext(preferencesInitialState);
const PreferencesProvider = PreferencesContext.Provider;
function usePreferences() {
  const context = react.exports.useContext(PreferencesContext);
  if (!context) {
    throw new Error("Preferences context was not found");
  }
  const {
    workspace,
    workspaces: workspaces2,
    dispatch
  } = context;
  return react.exports.useMemo(() => {
    return {
      current: workspaces2[workspace.current] || {},
      workspace,
      workspaces: workspaces2,
      dispatch
    };
  }, [dispatch, workspace, workspaces2]);
}
function useWorkspacesList() {
  const {
    workspaces: workspaces$1
  } = usePreferences();
  return react.exports.useMemo(() => {
    const currentWorkspaces = Object.keys(workspaces$1).reduce((acc, key) => {
      if (!workspaces[key]) {
        acc.push({
          key,
          label: workspaces$1[key].label
        });
      }
      return acc;
    }, []);
    return [...WORKSPACES, ...currentWorkspaces];
  }, [workspaces$1]);
}
class PathBuilder {
  constructor() {
    this.array = [];
  }
  moveTo(x, y) {
    this.array.push(`M ${x} ${y}`);
  }
  lineTo(x, y) {
    this.array.push(`L ${x} ${y}`);
  }
  closePath() {
    this.array.push("Z");
  }
  toString() {
    return this.array.join(" ");
  }
}
function ContoursPaths({
  id: spectrumID,
  sign,
  color,
  datum
}) {
  const {
    margin,
    width,
    height,
    xDomain,
    yDomain,
    contours,
    activeSpectrum
  } = useChartData();
  const preferences = usePreferences();
  const {
    xShift,
    yShift
  } = getShift(datum);
  const isActive = react.exports.useMemo(() => {
    return activeSpectrum === null ? true : spectrumID === activeSpectrum.id ? true : false;
  }, [activeSpectrum, spectrumID]);
  function buildContourPath(data2) {
    const _scaleX = get2DXScale({
      margin,
      width,
      xDomain
    });
    const _scaleY = get2DYScale({
      margin,
      height,
      yDomain
    });
    const path = new PathBuilder();
    for (const element of data2) {
      if (element.lines) {
        const lines = element.lines;
        if (lines.length < 1e6) {
          for (let i = 0; i < lines.length; i += 4) {
            path.moveTo(_scaleX(lines[i] + xShift), _scaleY(lines[i + 1] + yShift));
            path.lineTo(_scaleX(lines[i + 2] + xShift), _scaleY(lines[i + 3] + yShift));
          }
        }
      } else {
        path.moveTo(_scaleX(element[0].x + xShift), _scaleY(element[0].y + yShift));
        for (let j = 1; j < element.length; j++) {
          path.lineTo(_scaleX(element[j].x + xShift), _scaleY(element[j].y + yShift));
        }
      }
    }
    path.closePath();
    return path.toString();
  }
  const data = react.exports.useMemo(() => {
    return get_1(contours, `${spectrumID}.${sign}`, []);
  }, [contours, sign, spectrumID]);
  return /* @__PURE__ */ jsx$1("path", {
    fill: "none",
    "data-test-id": "spectrum-line",
    stroke: color,
    strokeWidth: "1",
    style: {
      opacity: isActive ? 1 : get_1(preferences.current, "controllers.dimmedSpectraTransparency", 0.1)
    },
    d: buildContourPath(data)
  });
}
function ContoursInner({
  data,
  displayerKey
}) {
  return /* @__PURE__ */ jsx$1("g", {
    clipPath: `url(#${displayerKey}clip-chart-2d)`,
    className: "contours",
    children: data == null ? void 0 : data.map((datum, index2) => /* @__PURE__ */ jsxs$1("g", {
      children: [datum.display.isPositiveVisible && /* @__PURE__ */ jsx$1(ContoursPaths, {
        id: datum.id,
        sign: "positive",
        datum,
        color: datum.display.positiveColor
      }), datum.display.isNegativeVisible && /* @__PURE__ */ jsx$1(ContoursPaths, {
        id: datum.id,
        sign: "negative",
        datum,
        color: datum.display.negativeColor
      })]
    }, `${datum.id + index2}`))
  });
}
const MemoizedContours = react.exports.memo(ContoursInner);
function Contours() {
  const {
    data: spectra,
    displayerKey
  } = useChartData();
  const data = react.exports.useMemo(() => {
    return spectra.filter((datum) => datum.info.dimension === 2 && datum.info.isFt);
  }, [spectra]);
  return /* @__PURE__ */ jsx$1(MemoizedContours, {
    data,
    displayerKey
  });
}
var XYReducerDomainAxis = /* @__PURE__ */ ((XYReducerDomainAxis2) => {
  XYReducerDomainAxis2["XAxis"] = "XAxis";
  XYReducerDomainAxis2["YAxis"] = "YAxis";
  return XYReducerDomainAxis2;
})(XYReducerDomainAxis || {});
function useXYReduce(domainAxis) {
  const { width, xDomain, yDomain } = useChartData();
  return react.exports.useCallback((data) => {
    const { x, y } = data;
    const [from, to] = domainAxis === "XAxis" ? xDomain : yDomain;
    return xyReduce({ x, y }, { from, to, nbPoints: width * 4, optimize: true });
  }, [domainAxis, width, xDomain, yDomain]);
}
function Left1DChart({
  margin: marignValue = 10,
  data: spectrum
}) {
  const {
    height: originHeight,
    margin,
    yDomain,
    yDomains,
    displayerKey
  } = useChartData();
  const xyReduce2 = useXYReduce(XYReducerDomainAxis.YAxis);
  const height = margin.left;
  const paths = react.exports.useMemo(() => {
    if (spectrum) {
      const scaleX = get2DYScale({
        height: originHeight,
        yDomain: [yDomain[0], yDomain[1]],
        margin
      });
      const scaleY = get1DYScale(yDomains[spectrum.id], height, marignValue);
      const {
        x,
        re: y
      } = spectrum.data;
      const pathPoints = xyReduce2({
        x,
        y
      });
      const pathBuilder = new PathBuilder();
      pathBuilder.moveTo(scaleY(pathPoints.y[pathPoints.y.length - 1]), scaleX(pathPoints.x.length - 1));
      for (let i = pathPoints.x.length - 2; i >= 0; i--) {
        pathBuilder.lineTo(scaleY(pathPoints.y[i]), scaleX(pathPoints.x[i]));
      }
      return pathBuilder.toString();
    } else {
      return void 0;
    }
  }, [height, margin, marignValue, originHeight, spectrum, xyReduce2, yDomain, yDomains]);
  const mainHeight = originHeight - margin.bottom - margin.top;
  if (!mainHeight || !height)
    return null;
  return /* @__PURE__ */ jsxs$1("svg", {
    viewBox: `0 0 ${height} ${mainHeight + margin.top}`,
    width: height,
    height: mainHeight + margin.top,
    children: [/* @__PURE__ */ jsx$1("defs", {
      children: /* @__PURE__ */ jsx$1("clipPath", {
        id: `${displayerKey}clip-left`,
        children: /* @__PURE__ */ jsx$1("rect", {
          width: height,
          height: mainHeight,
          x: "0",
          y: margin.top
        })
      })
    }), /* @__PURE__ */ jsx$1("g", {
      clipPath: `url(#${displayerKey}clip-left)`,
      children: /* @__PURE__ */ jsx$1("path", {
        className: "line",
        stroke: "black",
        fill: "none",
        d: paths
      })
    })]
  });
}
var Left1DChart$1 = react.exports.memo(Left1DChart);
function Top1DChart({
  margin: marginProps = 10,
  data: spectrum
}) {
  const {
    width,
    margin: originMargin,
    xDomain,
    yDomains,
    displayerKey
  } = useChartData();
  const xyReduce2 = useXYReduce(XYReducerDomainAxis.XAxis);
  const height = originMargin.top;
  const paths = react.exports.useMemo(() => {
    if (spectrum) {
      const scaleX = get2DXScale({
        width,
        xDomain,
        margin: originMargin
      });
      const scaleY = get1DYScale(yDomains[spectrum.id], height, marginProps);
      const {
        x,
        re: y
      } = spectrum.data;
      const pathPoints = xyReduce2({
        x,
        y
      });
      const pathBuilder = new PathBuilder();
      pathBuilder.moveTo(scaleX(pathPoints.x[0]), scaleY(pathPoints.y[0]));
      for (let i = 1; i < pathPoints.x.length; i++) {
        pathBuilder.lineTo(scaleX(pathPoints.x[i]), scaleY(pathPoints.y[i]));
      }
      return pathBuilder.toString();
    } else {
      return void 0;
    }
  }, [height, marginProps, originMargin, spectrum, width, xDomain, xyReduce2, yDomains]);
  if (!width || !height) {
    return null;
  }
  return /* @__PURE__ */ jsxs$1("svg", {
    viewBox: `0 0 ${width} ${height}`,
    width,
    height,
    children: [/* @__PURE__ */ jsx$1("defs", {
      children: /* @__PURE__ */ jsx$1("clipPath", {
        id: `${displayerKey}clip-top`,
        children: /* @__PURE__ */ jsx$1("rect", {
          width: width - originMargin.left - originMargin.right,
          height,
          x: originMargin.left,
          y: `${0}`
        })
      })
    }), /* @__PURE__ */ jsx$1("g", {
      clipPath: `url(#${displayerKey}clip-top)`,
      children: /* @__PURE__ */ jsx$1("path", {
        className: "line",
        stroke: "red",
        fill: "none",
        strokeWidth: "1px",
        d: paths
      })
    })]
  });
}
var Top1DChart$1 = react.exports.memo(Top1DChart);
const axisStyles$2 = css`
  user-select: none;

  path,
  line {
    fill: none;
    stroke: black;
    stroke-width: 1;
    shape-rendering: crispEdges;
    user-select: none;
  }
`;
const defaultMargin$1 = {
  right: 100,
  top: 0,
  left: 0,
  bottom: 0
};
function XAxis$1(props) {
  const {
    show = true,
    label = "\u03B4 [ppm]",
    margin: marginProps = defaultMargin$1
  } = props;
  const state = useChartData();
  const {
    xDomain,
    height,
    width,
    margin,
    tabActiveSpectrum,
    activeTab
  } = state;
  const refAxis = react.exports.useRef(null);
  react.exports.useEffect(() => {
    if (!show)
      return;
    const scaleX = get2DXScale({
      width,
      margin,
      xDomain
    });
    const xAxis = axisBottom(scaleX).ticks(8).tickFormat(format("0"));
    select(refAxis.current).call(xAxis);
  }, [activeTab, height, margin, margin.bottom, margin.left, margin.right, margin.top, show, tabActiveSpectrum, width, xDomain]);
  if (!width || !height) {
    return null;
  }
  return /* @__PURE__ */ jsx(Fragment, {
    children: show && /* @__PURE__ */ jsx("g", {
      className: "x",
      css: axisStyles$2,
      transform: `translate(0,${height - (margin.bottom + marginProps.bottom)})`,
      ref: refAxis,
      children: /* @__PURE__ */ jsx("text", {
        fill: "#000",
        x: width - 60,
        y: "20",
        dy: "0.71em",
        textAnchor: "end",
        children: label
      })
    })
  });
}
var XAxis$2 = react.exports.memo(XAxis$1);
const axisStyles$1 = css`
  user-select: 'none';
  -webkit-user-select: none; /* Chrome all / Safari all */
  -moz-user-select: none; /* Firefox all */

  path,
  line {
    fill: none;
    stroke: black;
    stroke-width: 1;
    shape-rendering: crispEdges;
    user-select: 'none';
    -webkit-user-select: none; /* Chrome all / Safari all */
    -moz-user-select: none; /* Firefox all */
  }
`;
const defaultMargin = {
  right: 50,
  top: 0,
  bottom: 0,
  left: 0
};
function YAxis(props) {
  const {
    show = true,
    label = "",
    margin: marginProps = defaultMargin
  } = props;
  const refAxis = react.exports.useRef(null);
  const state = useChartData();
  const {
    yDomain,
    width,
    height,
    activeTab,
    tabActiveSpectrum,
    margin
  } = state;
  react.exports.useEffect(() => {
    if (!show || !yDomain)
      return;
    const scaleY = get2DYScale({
      height,
      yDomain,
      margin
    });
    const axis = axisRight(scaleY).ticks(8).tickFormat(format("0"));
    select(refAxis.current).call(axis);
  }, [show, yDomain, activeTab, tabActiveSpectrum, height, margin]);
  if (!width || !height) {
    return null;
  }
  return /* @__PURE__ */ jsx(Fragment, {
    children: /* @__PURE__ */ jsx("g", {
      className: "y",
      css: axisStyles$1,
      transform: `translate(${width - marginProps.right})`,
      ref: refAxis,
      children: /* @__PURE__ */ jsx("text", {
        fill: "#000",
        x: -marginProps.top,
        y: -(marginProps.right - 5),
        dy: "0.71em",
        transform: "rotate(-90)",
        textAnchor: "end",
        children: label
      })
    })
  });
}
var YAxis$1 = react.exports.memo(YAxis);
const lineStyle$1 = css`
  stroke: lightgrey;
  opacity: 0.7;
`;
function IndicationLines({
  axis,
  show
}) {
  const {
    data,
    activeTab,
    margin,
    width,
    height,
    xDomain,
    yDomain,
    displayerMode
  } = useChartData();
  const [deltas1D, setDeltas1D] = react.exports.useState([]);
  const scaleX = get2DXScale({
    margin,
    width,
    xDomain
  });
  const scaleY = get2DYScale({
    margin,
    height,
    yDomain
  });
  react.exports.useEffect(() => {
    const split = activeTab.split(",");
    const nucleus = axis === "X" ? split[0] : axis === "Y" ? split[1] : null;
    if (nucleus !== null) {
      const ranges = data.filter((_datum) => _datum.display.isVisible === true && _datum.info.nucleus === nucleus).filter(isSpectrum1D).map((_datum) => _datum.ranges.values).flat();
      const deltas = ranges.map((_range) => _range.signals.filter((_signal) => SignalKindsToInclude.some((_kind) => _signal.kind === _kind)).map((_signal) => _signal.delta)).flat();
      setDeltas1D(deltas);
    } else {
      setDeltas1D([]);
    }
  }, [activeTab, axis, data, displayerMode]);
  const indicationLines = react.exports.useMemo(() => {
    if (show === true && deltas1D.length > 0) {
      const lines = deltas1D.map((_delta, i) => {
        return axis === "X" ? /* @__PURE__ */ jsx("line", {
          css: lineStyle$1,
          x1: scaleX(_delta),
          x2: scaleX(_delta),
          y1: scaleY(yDomain[0]),
          y2: scaleY(yDomain[1])
        }, `indicationLine${axis}${i}`) : axis === "Y" ? /* @__PURE__ */ jsx("line", {
          css: lineStyle$1,
          x1: scaleX(xDomain[0]),
          x2: scaleX(xDomain[1]),
          y1: scaleY(_delta),
          y2: scaleY(_delta)
        }, `indicationLine${axis}${i}`) : null;
      });
      return lines;
    }
  }, [axis, deltas1D, scaleX, scaleY, show, xDomain, yDomain]);
  return /* @__PURE__ */ jsx("g", {
    children: indicationLines
  });
}
const eventEmitter = new EventEmitter();
const Emitter = {
  on: (event, fn2) => eventEmitter.on(event, fn2),
  once: (event, fn2) => eventEmitter.once(event, fn2),
  off: (event, fn2) => eventEmitter.off(event, fn2),
  emit: (event, payload) => eventEmitter.emit(event, payload)
};
Object.freeze(Emitter);
const lineStyle = css`
  stroke: green;
  stroke-width: 2;
  opacity: 0.5;
`;
function SignalDeltaLine({
  delta,
  axis,
  show
}) {
  const {
    margin,
    width,
    height,
    xDomain,
    yDomain
  } = useChartData();
  const scaleX = get2DXScale({
    margin,
    width,
    xDomain
  });
  const scaleY = get2DYScale({
    margin,
    height,
    yDomain
  });
  const line = react.exports.useMemo(() => {
    return show === true ? axis === "X" ? /* @__PURE__ */ jsx("line", {
      css: lineStyle,
      x1: scaleX(delta),
      x2: scaleX(delta),
      y1: scaleY(yDomain[0]),
      y2: scaleY(yDomain[1])
    }, `signalLine_${delta}_X`) : axis === "Y" ? /* @__PURE__ */ jsx("line", {
      css: lineStyle,
      x1: scaleX(xDomain[0]),
      x2: scaleX(xDomain[1]),
      y1: scaleY(delta),
      y2: scaleY(delta)
    }, `signalLine_${delta}_Y`) : null : null;
  }, [axis, delta, scaleX, scaleY, show, xDomain, yDomain]);
  return /* @__PURE__ */ jsx("g", {
    children: line
  });
}
function SignalCrosshair({
  signal
}) {
  var _a, _b;
  const highlightIDsX = react.exports.useMemo(() => {
    return [buildID(signal.id, "Crosshair"), buildID(signal.id, "Crosshair_X")];
  }, [signal.id]);
  const highlightIDsY = react.exports.useMemo(() => {
    return [buildID(signal.id, "Crosshair"), buildID(signal.id, "Crosshair_Y")];
  }, [signal.id]);
  const highlightX = useHighlight(highlightIDsX);
  const highlightY = useHighlight(highlightIDsY);
  const highlight = useHighlight([signal.id]);
  if (!((_a = signal == null ? void 0 : signal.x) == null ? void 0 : _a.delta) || !((_b = signal == null ? void 0 : signal.y) == null ? void 0 : _b.delta))
    return null;
  return /* @__PURE__ */ jsxs("g", {
    children: [/* @__PURE__ */ jsx(SignalDeltaLine, {
      delta: signal.x.delta,
      axis: "X",
      show: highlightX.isActive || highlight.isActive
    }), /* @__PURE__ */ jsx(SignalDeltaLine, {
      delta: signal.y.delta,
      axis: "Y",
      show: highlightY.isActive || highlight.isActive
    })]
  });
}
const Signal = react.exports.memo(({
  signal,
  isVisible
}) => {
  const {
    margin,
    width,
    height,
    xDomain,
    yDomain
  } = useChartData();
  const scaleX = get2DXScale({
    margin,
    width,
    xDomain
  });
  const scaleY = get2DYScale({
    margin,
    height,
    yDomain
  });
  const buildIDs = react.exports.useCallback((id2) => {
    return [id2].concat(buildID(id2, "X"), buildID(id2, "Y"));
  }, []);
  const assignment = useAssignment(signal.id);
  const highlight = useHighlight(buildIDs(assignment.id));
  const highlightData = useHighlightData();
  const [isHighlighted, setIsHighlighted] = react.exports.useState(false);
  react.exports.useEffect(() => {
    if (highlightData.highlight.highlighted.some((_highlighted) => buildIDs(signal.id).includes(_highlighted)) || assignment.isActive) {
      setIsHighlighted(true);
    } else {
      setIsHighlighted(false);
    }
  }, [assignment.isActive, buildIDs, highlightData.highlight.highlighted, signal.id]);
  if (!signal)
    return null;
  return /* @__PURE__ */ jsxs("g", {
    className: "zone-signal",
    children: [isVisible.signals && /* @__PURE__ */ jsxs("g", {
      children: [/* @__PURE__ */ jsx(SignalCrosshair, {
        signal
      }), /* @__PURE__ */ jsx("circle", {
        onMouseEnter: () => {
          assignment.show();
          highlight.show();
        },
        onMouseLeave: () => {
          assignment.hide();
          highlight.hide();
        },
        cx: scaleX(signal.x.delta || 0),
        cy: scaleY(signal.y.delta || 0),
        r: isHighlighted ? 6 : 4,
        fill: isHighlighted ? "green" : "darkgreen"
      }, signal.id)]
    }), /* @__PURE__ */ jsx("g", {
      className: "zone-signal-peak",
      style: {
        pointerEvents: "none"
      },
      children: isVisible.peaks && signal.peaks && signal.peaks.map((peak, i) => /* @__PURE__ */ jsx("circle", {
        cx: scaleX(peak.x),
        cy: scaleY(peak.y),
        r: 2,
        fill: "black"
      }, `${signal.id + i}`))
    })]
  });
});
const stylesOnHover$2 = css`
  pointer-events: bounding-box;
  @-moz-document url-prefix() {
    pointer-events: fill;
  }
  user-select: 'none';
  -webkit-user-select: none; /* Chrome all / Safari all */
  -moz-user-select: none; /* Firefox all */

  .delete-button {
    visibility: hidden;
  }
`;
const stylesHighlighted$2 = css`
  pointer-events: bounding-box;

  @-moz-document url-prefix() {
    pointer-events: fill;
  }
  .Integral-area {
    fill: #ff6f0057;
  }
  .delete-button {
    visibility: visible;
    cursor: pointer;
  }
`;
const Zone = ({
  zoneData,
  isVisible
}) => {
  const {
    x,
    y,
    id: id2,
    signals
  } = zoneData;
  const assignmentZone = useAssignment(id2);
  const highlightZone = useHighlight([assignmentZone.id], {
    type: HighlightedSource.ZONE,
    extra: {
      id: assignmentZone.id
    }
  });
  const {
    margin,
    width,
    height,
    xDomain,
    yDomain
  } = useChartData();
  const scaleX = get2DXScale({
    margin,
    width,
    xDomain
  });
  const scaleY = get2DYScale({
    margin,
    height,
    yDomain
  });
  const {
    from: x1 = 0,
    to: x2 = 0
  } = x;
  const {
    from: y1 = 0,
    to: y2 = 0
  } = y;
  const [reduceOpacity, setReduceOpacity] = react.exports.useState(false);
  react.exports.useEffect(() => {
    setReduceOpacity(!checkZoneKind(zoneData));
  }, [zoneData]);
  return /* @__PURE__ */ jsxs("g", {
    css: highlightZone.isActive || assignmentZone.isActive ? stylesHighlighted$2 : stylesOnHover$2,
    onMouseEnter: () => {
      assignmentZone.show();
      highlightZone.show();
    },
    onMouseLeave: () => {
      assignmentZone.hide();
      highlightZone.hide();
    },
    children: [isVisible.zones && /* @__PURE__ */ jsx("g", {
      transform: `translate(${scaleX(x2)},${scaleY(y1)})`,
      children: /* @__PURE__ */ jsx("rect", {
        x: "0",
        width: scaleX(x1) - scaleX(x2),
        height: scaleY(y2) - scaleY(y1),
        className: "Integral-area",
        fill: "#0000000f",
        stroke: reduceOpacity ? "#343a40" : "darkgreen",
        strokeWidth: reduceOpacity ? "0" : "1"
      })
    }), signals.map((_signal, i) => /* @__PURE__ */ jsx(Signal, {
      signal: _signal,
      isVisible
    }, `${id2 + i}`))]
  }, id2);
};
function ZonesInner({
  zones,
  display,
  displayerKey
}) {
  const [isVisible, setVisibility] = react.exports.useState({
    zones: true,
    signals: true,
    peaks: true
  });
  react.exports.useEffect(() => {
    Emitter.on("onZonesVisibilityChange", ({
      key
    }) => {
      setVisibility((prevVisiblity) => __spreadProps(__spreadValues({}, prevVisiblity), {
        [key]: !prevVisiblity[key]
      }));
    });
  }, []);
  return /* @__PURE__ */ jsx$1("g", {
    clipPath: `url(#${displayerKey}clip-chart-2d)`,
    className: "2D-Zones",
    children: display.isVisible && zones.values.map((zone) => /* @__PURE__ */ jsx$1("g", {
      className: "zone",
      children: /* @__PURE__ */ jsx$1(Zone, {
        zoneData: zone,
        isVisible
      })
    }, zone.id))
  });
}
const MemoizedZones = react.exports.memo(ZonesInner);
const emptyData$c = {
  zones: {},
  display: {}
};
function Zones() {
  const {
    displayerKey
  } = useChartData();
  const {
    zones,
    display
  } = useSpectrum(emptyData$c);
  return /* @__PURE__ */ jsx$1(MemoizedZones, {
    zones,
    display,
    displayerKey
  });
}
function chart2DInner({
  spectra,
  width,
  height,
  margin,
  displayerKey
}) {
  return /* @__PURE__ */ jsxs$1("svg", {
    viewBox: `0 0 ${width} ${height}`,
    width,
    height,
    id: "nmrSVG",
    children: [/* @__PURE__ */ jsx$1("defs", {
      children: /* @__PURE__ */ jsx$1("clipPath", {
        id: `${displayerKey}clip-chart-2d`,
        children: /* @__PURE__ */ jsx$1("rect", {
          width: width - margin.left - margin.right,
          height: height - margin.top - margin.bottom,
          x: margin.left,
          y: margin.top
        })
      })
    }), /* @__PURE__ */ jsx$1("rect", {
      width: width - margin.left - margin.right,
      height: height - margin.top - margin.bottom,
      x: margin.left,
      y: margin.top,
      stroke: "black",
      strokeWidth: "1",
      fill: "transparent"
    }), (spectra == null ? void 0 : spectra[0]) && /* @__PURE__ */ jsx$1(Top1DChart$1, {
      data: spectra[0]
    }), (spectra == null ? void 0 : spectra[1]) && /* @__PURE__ */ jsx$1(Left1DChart$1, {
      data: spectra[1]
    }), /* @__PURE__ */ jsx$1(Contours, {}), /* @__PURE__ */ jsx$1(Zones, {}), /* @__PURE__ */ jsx$1(IndicationLines, {
      axis: "X",
      show: true
    }), /* @__PURE__ */ jsx$1(IndicationLines, {
      axis: "Y",
      show: true
    }), /* @__PURE__ */ jsxs$1("g", {
      className: "container",
      style: {
        pointerEvents: "none"
      },
      children: [/* @__PURE__ */ jsx$1(XAxis$2, {}), /* @__PURE__ */ jsx$1(YAxis$1, {})]
    }), /* @__PURE__ */ jsx$1(FloatMoleculeStructures, {})]
  });
}
const MemoizedChart2D = react.exports.memo(chart2DInner);
function Chart2D({
  spectra
}) {
  const {
    width,
    height,
    margin,
    displayerKey
  } = useChartData();
  return /* @__PURE__ */ jsx$1(MemoizedChart2D, {
    spectra,
    width,
    height,
    margin,
    displayerKey
  });
}
function FormatNumber(value, format2, prefix = "", suffix = "") {
  return prefix + Numeral(value).format(format2) + suffix;
}
function useFormatNumberByNucleus(nucleus) {
  const preferences = usePreferences();
  const nucleusByKey = get_1(preferences.current, `formatting.nuclei`, {
    ppm: "0.0",
    hz: "0.0"
  });
  return react.exports.useMemo(() => {
    function formatFun(n) {
      return (value, formatKey = "ppm", prefix = "", suffix = "") => {
        return prefix + Numeral(Number(value)).format(get_1(nucleusByKey, `${n.toLowerCase()}.${formatKey}`, "0.0")) + suffix;
      };
    }
    if (!nucleus) {
      return () => void 0;
    }
    if (typeof nucleus === "string") {
      return formatFun(nucleus);
    } else if (Array.isArray(nucleus)) {
      return nucleus.map((n) => formatFun(n));
    } else {
      throw Error("nuclus must be string or array of string");
    }
  }, [nucleus, nucleusByKey]);
}
function getNumberOfDecimals(value) {
  value = String(value).trim();
  const lastIndex = value.lastIndexOf(".");
  return lastIndex > 0 ? value.substr(lastIndex).split("").length - 1 : 0;
}
const styles$1a = css`
  display: flex;
  flex-firection: row;
  align-items: center;
  pointer-events: bounding-box;
  user-select: 'none';
  -webkit-user-select: none; /* Chrome all / Safari all */
  -moz-user-select: none; /* Firefox all */
  background-color: #f7f7f7;
  height: 30px;
  padding: 6px;
  color: #8d0018;
  position: absolute;
  width: 100%;
  bottom: 0;
  div {
    margin: 0px 10px;
    display: inline-block;

    .label {
      font-size: 12px;
      color: #4d4d4d;
      font-weight: bold;
    }
    .value {
      font-weight: bold;
      font-size: 14px;
    }
    .unit {
      font-weight: bold;
      font-size: 10px;
    }
  }
`;
function FooterBanner$1({
  layout,
  data1D
}) {
  const position = react.exports.useContext(MouseContext);
  const {
    startX,
    endX,
    startY,
    endY,
    step
  } = react.exports.useContext(BrushContext);
  const {
    margin,
    width,
    height,
    activeSpectrum,
    xDomain,
    yDomain,
    yDomains,
    activeTab,
    data,
    toolOptions: {
      selectedTool
    }
  } = useChartData();
  const trackID = position && getLayoutID(layout, {
    startX: position.x,
    startY: position.y
  });
  const nucleuses = activeTab.split(",");
  const [formatX, formatY] = useFormatNumberByNucleus(nucleuses);
  const scaleX = react.exports.useMemo(() => {
    if (!data1D || data1D.length === 0) {
      return get2DXScale({
        width,
        margin,
        xDomain
      });
    }
    if (selectedTool !== options.slicingTool.id) {
      switch (trackID) {
        case LAYOUT.TOP_1D:
        case LAYOUT.CENTER_2D: {
          return get2DXScale({
            width,
            margin,
            xDomain
          });
        }
        case LAYOUT.LEFT_1D: {
          return get2DYScale({
            height,
            margin,
            yDomain
          });
        }
        default:
          return null;
      }
    }
    return null;
  }, [data1D, height, margin, selectedTool, trackID, width, xDomain, yDomain]);
  const scaleY = react.exports.useMemo(() => {
    if (!data1D || data1D.length === 0) {
      return get2DYScale({
        height,
        margin,
        yDomain
      });
    }
    if (selectedTool !== options.slicingTool.id) {
      switch (trackID) {
        case LAYOUT.CENTER_2D: {
          return get2DYScale({
            height,
            margin,
            yDomain
          });
        }
        case LAYOUT.TOP_1D: {
          return data1D[0] ? get1DYScale(yDomains[data1D[0].id], margin.top) : null;
        }
        case LAYOUT.LEFT_1D: {
          return data1D[1] ? get1DYScale(yDomains[data1D[1].id], margin.left) : null;
        }
        default:
          return null;
      }
    }
    return null;
  }, [data1D, height, margin, selectedTool, trackID, yDomain, yDomains]);
  if (!activeSpectrum || !position || position.y < 10 || position.x < 10 || position.x > width - margin.right || position.y > height - margin.bottom) {
    return /* @__PURE__ */ jsx("div", {
      css: styles$1a
    });
  }
  const getRealYValue = (cordinate) => {
    let index2 = null;
    if (trackID === LAYOUT.TOP_1D) {
      index2 = 0;
    } else if (trackID === LAYOUT.LEFT_1D) {
      index2 = 1;
    }
    if (index2 != null && scaleX != null) {
      const datum = get1DDataXY(data1D[index2]);
      const xIndex = xFindClosestIndex(datum.x, scaleX.invert(cordinate));
      return datum.y[xIndex];
    }
    return 1;
  };
  const getXValue = (x = null) => {
    if (scaleX != null) {
      switch (trackID) {
        case LAYOUT.CENTER_2D:
        case LAYOUT.TOP_1D: {
          return scaleX.invert(x ? x : position.x);
        }
        case LAYOUT.LEFT_1D: {
          return scaleX.invert(x ? x : position.y);
        }
        default:
          return 0;
      }
    }
    return 0;
  };
  const getYValue = () => {
    if (scaleY != null) {
      switch (trackID) {
        case LAYOUT.CENTER_2D:
        case LAYOUT.TOP_1D: {
          return scaleY.invert(position.y);
        }
        case LAYOUT.LEFT_1D: {
          return scaleY.invert(position.x);
        }
        default:
          return 0;
      }
    }
    return 0;
  };
  const getRation = () => {
    switch (trackID) {
      case LAYOUT.TOP_1D: {
        return (getRealYValue(startX) / (getRealYValue(endX) || Number.MIN_VALUE) * 100).toFixed(2);
      }
      case LAYOUT.LEFT_1D: {
        return (getRealYValue(startY) / (getRealYValue(endY) || Number.MIN_VALUE) * 100).toFixed(2);
      }
      default:
        return 0;
    }
  };
  const getDeltaX = () => {
    switch (trackID) {
      case LAYOUT.TOP_1D: {
        return (getXValue(startX) - getXValue(endX)).toPrecision(6);
      }
      case LAYOUT.LEFT_1D: {
        return (getXValue(startY) - getXValue(endY)).toPrecision(6);
      }
      default:
        return 0;
    }
  };
  const getLabel2 = (label2d, labelld, nucleus) => {
    return trackID === LAYOUT.CENTER_2D ? /* @__PURE__ */ jsxs(react.exports.Fragment, {
      children: [label2d, " ( ", /* @__PURE__ */ jsx(MF, {
        mf: nucleus
      }), " )"]
    }) : labelld;
  };
  const getZValue = () => {
    if (trackID === LAYOUT.CENTER_2D) {
      const {
        maxX,
        maxY,
        minX,
        minY,
        z
      } = data[activeSpectrum.index].data;
      const xStep = (maxX - minX) / (z[0].length - 1);
      const yStep = (maxY - minY) / (z.length - 1);
      const xIndex = Math.floor((getXValue() - minX) / xStep);
      const yIndex = Math.floor((getYValue() - minY) / yStep);
      if (xIndex < 0 || xIndex >= z[0].length)
        return 0;
      if (yIndex < 0 || yIndex >= z.length)
        return 0;
      return z[yIndex][xIndex];
    }
    return 0;
  };
  return /* @__PURE__ */ jsxs("div", {
    css: styles$1a,
    children: [/* @__PURE__ */ jsxs("div", {
      children: [/* @__PURE__ */ jsxs("span", {
        className: "label",
        children: [getLabel2("F2", "X", nucleuses[0]), " :"]
      }), /* @__PURE__ */ jsx("span", {
        className: "value",
        children: formatX(getXValue())
      }), /* @__PURE__ */ jsx("span", {
        className: "unit",
        children: "ppm"
      })]
    }), /* @__PURE__ */ jsxs("div", {
      children: [/* @__PURE__ */ jsxs("span", {
        className: "label",
        children: [getLabel2("F1", "Y", nucleuses[1]), " :"]
      }), /* @__PURE__ */ jsx("span", {
        className: "value",
        children: formatY(getYValue())
      }), /* @__PURE__ */ jsx("span", {
        className: "unit",
        children: "ppm"
      })]
    }), /* @__PURE__ */ jsxs("div", {
      children: [/* @__PURE__ */ jsx("span", {
        className: "label",
        children: "Intensity :"
      }), /* @__PURE__ */ jsx("span", {
        className: "value",
        children: getZValue()
      })]
    }), step === "brushing" && /* @__PURE__ */ jsxs("div", {
      children: [/* @__PURE__ */ jsx("span", {
        className: "label",
        children: " \u0394ppm :"
      }), /* @__PURE__ */ jsx("span", {
        className: "value",
        children: getDeltaX()
      })]
    }), step === "brushing" && /* @__PURE__ */ jsxs("div", {
      children: [/* @__PURE__ */ jsx("span", {
        className: "label",
        children: " ratio :"
      }), /* @__PURE__ */ jsxs("span", {
        className: "value",
        children: [getRation(), "%"]
      })]
    })]
  });
}
const style$a = {
  cursor: "crosshair",
  transformOrigin: "bottom right",
  position: "absolute",
  top: "-18px",
  left: "-88px",
  fontWeight: "bold",
  pointerEvents: "none",
  overflow: "visible",
  userSelect: "none",
  width: "85px",
  textAlign: "right"
};
function XYLabelPointer({
  layout,
  data1D
}) {
  const position = react.exports.useContext(MouseContext);
  const {
    step
  } = react.exports.useContext(BrushContext);
  const {
    margin,
    width,
    height,
    xDomain,
    yDomain,
    yDomains,
    activeTab,
    activeSpectrum
  } = useChartData();
  const trackID = position && getLayoutID(layout, {
    startX: position.x,
    startY: position.y
  });
  const nucleuses = activeTab.split(",");
  const [formatX, formatY] = useFormatNumberByNucleus(nucleuses);
  const scaleX = react.exports.useMemo(() => {
    if (!activeSpectrum || !data1D || data1D.length === 0) {
      return get2DXScale({
        width,
        margin,
        xDomain
      });
    }
    switch (trackID) {
      case LAYOUT.TOP_1D:
      case LAYOUT.CENTER_2D: {
        return get2DXScale({
          width,
          margin,
          xDomain
        });
      }
      case LAYOUT.LEFT_1D: {
        return get2DYScale({
          height,
          margin,
          yDomain
        });
      }
      default:
        return null;
    }
  }, [activeSpectrum, data1D, height, margin, trackID, width, xDomain, yDomain]);
  const scaleY = react.exports.useMemo(() => {
    if (!activeSpectrum || !data1D || data1D.length === 0) {
      return get2DYScale({
        height,
        margin,
        yDomain
      });
    }
    switch (trackID) {
      case LAYOUT.CENTER_2D: {
        return get2DYScale({
          height,
          margin,
          yDomain
        });
      }
      case LAYOUT.TOP_1D: {
        return data1D[0] ? get1DYScale(yDomains[data1D[0].id], margin.top) : null;
      }
      case LAYOUT.LEFT_1D: {
        return data1D[1] ? get1DYScale(yDomains[data1D[1].id], margin.left) : null;
      }
      default:
        return null;
    }
  }, [activeSpectrum, data1D, height, margin, trackID, yDomain, yDomains]);
  if (step === "brushing" || !position || position.y < margin.top || position.x < margin.left || position.x > width - margin.right || position.y > height - margin.bottom) {
    return null;
  }
  const getXValue = (x = null) => {
    switch (trackID) {
      case LAYOUT.CENTER_2D:
      case LAYOUT.TOP_1D: {
        return scaleX == null ? void 0 : scaleX.invert(x ? x : position.x);
      }
      case LAYOUT.LEFT_1D: {
        return scaleX == null ? void 0 : scaleX.invert(x ? x : position.y);
      }
      default:
        return 0;
    }
  };
  const getYValue = () => {
    switch (trackID) {
      case LAYOUT.CENTER_2D:
      case LAYOUT.TOP_1D: {
        return scaleY == null ? void 0 : scaleY.invert(position.y);
      }
      case LAYOUT.LEFT_1D: {
        return scaleY == null ? void 0 : scaleY.invert(position.x);
      }
      default:
        return 0;
    }
  };
  return /* @__PURE__ */ jsxs$1("div", {
    style: __spreadProps(__spreadValues({}, style$a), {
      transform: `translate(${position.x}px, ${position.y}px)`
    }),
    children: [/* @__PURE__ */ jsx$1("span", {
      children: formatY(getYValue())
    }), /* @__PURE__ */ jsx$1("span", {
      style: {
        color: "gray"
      },
      children: ","
    }), /* @__PURE__ */ jsx$1("span", {
      style: {
        color: "red"
      },
      children: formatX(getXValue())
    })]
  }, "xLabelPointer");
}
function getYScale(height, y, margin = 10) {
  return linear(extent(y), [height - margin, margin]);
}
function HorizontalSliceChart({
  margin: marginProps = 10,
  data
}) {
  const {
    width,
    margin: originMargin,
    xDomain,
    displayerKey
  } = useChartData();
  const xyReduce2 = useXYReduce(XYReducerDomainAxis.XAxis);
  const height = originMargin.top;
  const paths = react.exports.useMemo(() => {
    if (data) {
      const {
        x,
        re: y
      } = data;
      const scaleX = get2DXScale({
        margin: originMargin,
        width,
        xDomain
      });
      const scaleY = getYScale(height, y, marginProps);
      const pathPoints = xyReduce2({
        x,
        y
      });
      const pathBuilder = new PathBuilder();
      pathBuilder.moveTo(scaleX(pathPoints.x[0]), scaleY(pathPoints.y[0]));
      for (let i = 1; i < pathPoints.x.length; i++) {
        pathBuilder.lineTo(scaleX(pathPoints.x[i]), scaleY(pathPoints.y[i]));
      }
      return pathBuilder.toString();
    } else {
      return void 0;
    }
  }, [data, height, marginProps, originMargin, width, xDomain, xyReduce2]);
  if (!width || !height) {
    return null;
  }
  return /* @__PURE__ */ jsxs$1("svg", {
    viewBox: `0 0 ${width} ${height}`,
    width,
    height,
    children: [/* @__PURE__ */ jsx$1("defs", {
      children: /* @__PURE__ */ jsx$1("clipPath", {
        id: `${displayerKey}clip-top`,
        children: /* @__PURE__ */ jsx$1("rect", {
          width: width - originMargin.left - originMargin.right,
          height,
          x: originMargin.left,
          y: `${0}`
        })
      })
    }), /* @__PURE__ */ jsxs$1("g", {
      clipPath: `url(#${displayerKey}clip-top)`,
      children: [/* @__PURE__ */ jsx$1("rect", {
        width: width - originMargin.left - originMargin.right,
        height,
        x: originMargin.left,
        y: `${0}`,
        fillOpacity: "0"
      }), /* @__PURE__ */ jsx$1("path", {
        className: "line",
        stroke: "red",
        fill: "none",
        d: paths
      })]
    })]
  });
}
var HorizontalSliceChart$1 = react.exports.memo(HorizontalSliceChart);
function VerticalSliceChart({
  margin: marignValue = 10,
  data
}) {
  const {
    height: originHeight,
    margin,
    yDomain,
    displayerKey
  } = useChartData();
  const xyReduce2 = useXYReduce(XYReducerDomainAxis.YAxis);
  const height = margin.left;
  const paths = react.exports.useMemo(() => {
    if (data) {
      const {
        x,
        re: y
      } = data;
      const scaleX = get2DYScale({
        height: originHeight,
        margin,
        yDomain
      });
      const scaleY = getYScale(height, y, marignValue);
      const pathPoints = xyReduce2({
        x,
        y
      });
      const pathBuilder = new PathBuilder();
      pathBuilder.moveTo(scaleY(pathPoints.y[pathPoints.y.length - 1]), scaleX(pathPoints.x.length - 1));
      for (let i = pathPoints.x.length - 2; i >= 0; i--) {
        pathBuilder.lineTo(scaleY(pathPoints.y[i]), scaleX(pathPoints.x[i]));
      }
      return pathBuilder.toString();
    } else {
      return void 0;
    }
  }, [data, height, margin, marignValue, originHeight, xyReduce2, yDomain]);
  const mainHeight = originHeight - margin.bottom - margin.top;
  if (!mainHeight || !height)
    return null;
  return /* @__PURE__ */ jsxs$1("svg", {
    viewBox: `0 0 ${height} ${mainHeight + margin.top}`,
    width: height,
    height: mainHeight + margin.top,
    children: [/* @__PURE__ */ jsx$1("defs", {
      children: /* @__PURE__ */ jsx$1("clipPath", {
        id: `${displayerKey}clip-left`,
        children: /* @__PURE__ */ jsx$1("rect", {
          width: height,
          height: mainHeight,
          x: "0",
          y: margin.top
        })
      })
    }), /* @__PURE__ */ jsx$1("g", {
      clipPath: `url(#${displayerKey}clip-left)`,
      children: /* @__PURE__ */ jsx$1("path", {
        className: "line",
        stroke: "red",
        fill: "none",
        d: paths
      })
    })]
  });
}
var VerticalSliceChart$1 = react.exports.memo(VerticalSliceChart);
function SlicingView() {
  const {
    width,
    height,
    margin,
    activeSpectrum,
    data: spectra,
    xDomain,
    yDomain
  } = useChartData();
  const position = useMouseTracker();
  const chart2d = react.exports.useMemo(() => {
    if (position && activeSpectrum && activeSpectrum.id) {
      const {
        x,
        y
      } = position;
      const scale2dX = get2DXScale({
        margin,
        width,
        xDomain
      });
      const scale2dY = get2DYScale({
        margin,
        height,
        yDomain
      });
      const data = getSlice(spectra[activeSpectrum.index], {
        x: scale2dX.invert(x),
        y: scale2dY.invert(y)
      });
      return /* @__PURE__ */ jsxs$1("svg", {
        viewBox: `0 0 ${width} ${height}`,
        width,
        height,
        style: {
          position: "absolute",
          backgroundColor: "rgba(255,255,255,0.8)"
        },
        children: [(data == null ? void 0 : data.horizontal) && /* @__PURE__ */ jsx$1(HorizontalSliceChart$1, {
          data: data.horizontal.data
        }), (data == null ? void 0 : data.vertical) && /* @__PURE__ */ jsx$1(VerticalSliceChart$1, {
          data: data.vertical.data
        })]
      });
    }
    return null;
  }, [position, activeSpectrum, margin, width, xDomain, height, yDomain, spectra]);
  if (!position) {
    return null;
  }
  return chart2d;
}
function Viewer2D({
  emptyText = void 0
}) {
  const state = useChartData();
  const {
    toolOptions: {
      selectedTool
    },
    isLoading,
    data,
    margin,
    tabActiveSpectrum,
    activeTab
  } = state;
  const dispatch = useDispatch();
  const {
    info
  } = useSpectrum({
    info: {}
  });
  const isVisible = info.isFt || !("isFt" in info);
  const spectrumData = react.exports.useMemo(() => {
    const nucleuses = activeTab.split(",");
    return nucleuses.reduce((acc, n) => {
      var _a, _b;
      if ((_a = tabActiveSpectrum[n]) == null ? void 0 : _a.id) {
        const id2 = (_b = tabActiveSpectrum[n]) == null ? void 0 : _b.id;
        const spectrum = data.find((datum) => datum.id === id2 && !datum.info.isFid);
        if (spectrum) {
          acc.push(spectrum);
        }
      } else {
        acc.push(null);
      }
      return acc;
    }, []);
  }, [activeTab, data, tabActiveSpectrum]);
  const DIMENSION = get2DDimensionLayout(state);
  const handelBrushEnd = react.exports.useCallback((brushData) => {
    const trackID = getLayoutID(DIMENSION, brushData);
    if (trackID) {
      if (brushData.altKey)
        ;
      else if (brushData.shiftKey) {
        switch (selectedTool) {
          case options.zone2D.id:
            dispatch(__spreadValues({
              type: ADD_2D_ZONE
            }, brushData));
            break;
        }
      } else {
        switch (selectedTool) {
          default:
            if (selectedTool != null) {
              return dispatch(__spreadProps(__spreadValues({
                type: BRUSH_END
              }, brushData), {
                trackID: getLayoutID(DIMENSION, brushData)
              }));
            }
        }
      }
    }
  }, [selectedTool, dispatch, DIMENSION]);
  const handelOnDoubleClick = react.exports.useCallback((e2) => {
    const {
      x: startX,
      y: startY
    } = e2;
    const trackID = getLayoutID(DIMENSION, {
      startX,
      startY
    });
    if (trackID) {
      dispatch({
        type: FULL_ZOOM_OUT,
        trackID
      });
    }
  }, [DIMENSION, dispatch]);
  const handleZoom2 = (event) => {
    const {
      x: startX,
      y: startY
    } = event;
    const trackID = getLayoutID(DIMENSION, {
      startX,
      startY
    });
    if (trackID) {
      if (trackID === "CENTER_2D") {
        dispatch(__spreadValues({
          type: SET_2D_LEVEL
        }, event));
      } else {
        dispatch({
          type: SET_ZOOM,
          event,
          trackID
        });
      }
    }
  };
  const mouseClick = react.exports.useCallback((position) => {
  }, [selectedTool]);
  if (!isVisible) {
    return /* @__PURE__ */ jsx$1(NoData, {
      emptyText: "Currently FID can not be displayed for 2D spectra",
      canOpenLoader: false
    });
  }
  return /* @__PURE__ */ jsx$1(ResponsiveChart, {
    children: ({
      width,
      height
    }) => /* @__PURE__ */ jsxs$1(ViewerResponsiveWrapper, {
      width,
      height,
      children: [/* @__PURE__ */ jsx$1(Spinner, {
        isLoading,
        emptyText
      }), data && data.length > 0 && /* @__PURE__ */ jsx$1(BrushTracker, {
        onBrush: handelBrushEnd,
        onDoubleClick: handelOnDoubleClick,
        onClick: mouseClick,
        onZoom: handleZoom2,
        style: {
          width: "100%",
          height: "100%",
          margin: "auto",
          position: "relative",
          overflow: "hidden"
        },
        children: /* @__PURE__ */ jsxs$1(MouseTracker, {
          style: {
            width: "100%",
            height: `100%`,
            position: "absolute"
          },
          children: [selectedTool && selectedTool === options.slicingTool.id && /* @__PURE__ */ jsx$1(SlicingView, {}), /* @__PURE__ */ jsx$1(CrossLinePointer, {}), spectrumData && /* @__PURE__ */ jsx$1(XYLabelPointer, {
            data1D: spectrumData,
            layout: DIMENSION
          }), /* @__PURE__ */ jsx$1(BrushXY, {
            brushType: BRUSH_TYPE.XY,
            dimensionBorder: DIMENSION.CENTER_2D
          }), /* @__PURE__ */ jsxs$1(Fragment$1, {
            children: [(spectrumData == null ? void 0 : spectrumData[0]) && /* @__PURE__ */ jsx$1(BrushXY, {
              brushType: BRUSH_TYPE.X,
              dimensionBorder: DIMENSION.TOP_1D,
              height: margin.top
            }), (spectrumData == null ? void 0 : spectrumData[1]) && /* @__PURE__ */ jsx$1(BrushXY, {
              brushType: BRUSH_TYPE.Y,
              dimensionBorder: DIMENSION.LEFT_1D,
              width: margin.left
            })]
          }), spectrumData && /* @__PURE__ */ jsx$1(FooterBanner$1, {
            data1D: spectrumData,
            layout: DIMENSION
          }), /* @__PURE__ */ jsx$1(Chart2D, {
            spectra: spectrumData
          })]
        })
      })]
    })
  });
}
function ViewerResponsiveWrapper(props) {
  const dispatch = useDispatch();
  const {
    width,
    height,
    children
  } = props;
  react.exports.useEffect(() => {
    dispatch(__spreadValues({
      type: SET_DIMENSIONS
    }, {
      width,
      height
    }));
  }, [width, height, dispatch]);
  return children;
}
const SET_X_SCALE = "SET_X_SCALE";
const SET_Y_SCALE = "SET_Y_SCALE";
const SET_SCALE = "SET_SCALE";
const scaleInitialState = {
  scaleX: null,
  scaleY: null
};
function innerScaleReducer(draft, action) {
  switch (action.type) {
    case SET_X_SCALE:
      draft.scaleX = (spectrumId = null) => getXScale(action, spectrumId);
      break;
    case SET_Y_SCALE:
      draft.scaleY = (spectrumId = null) => getYScale$1(action, spectrumId);
      break;
    case SET_SCALE: {
      draft.scaleX = (spectrumId = null) => getXScale(action.payload, spectrumId);
      draft.scaleY = (spectrumId = null) => getYScale$1(action.payload, spectrumId);
      break;
    }
    default:
      return draft;
  }
}
const scaleReducer = fn(innerScaleReducer);
const scaleContext = react.exports.createContext(scaleInitialState);
const ScaleProvider = scaleContext.Provider;
function useScale() {
  return react.exports.useContext(scaleContext);
}
function useScaleChecked() {
  const scale = useScale();
  if (!scale.scaleX || !scale.scaleY) {
    throw new Error("scale cannot be null");
  }
  return scale;
}
const ModalContext = react.exports.createContext({});
const ModalProvider = ModalContext.Provider;
function useModal() {
  return react.exports.useContext(ModalContext);
}
const styles$19 = css`
  display: block;
  border-radius: 5px;
  overflow: hidden;
  width: 300px;
  border-top: 10px solid #ed0000;

  .message {
    font-weight: bold;
    font-size: 14px;
    text-align: center;
    color: #af0000;
    text-align: center;
    padding: 25px;
    display: block;
  }
  .buttons-container {
    display: flex;
    flex-direction: row-reverse;
    align-items: flex-end;
    padding: 5px;
    border-top: 1px solid #efefef;

    button:last-of-type {
      border-radius: 5px 0 0 5px;
    }
    button:first-of-type {
      border-radius: 0px 5px 5px 0px;
      border-width: 1px;
    }
    button {
      border-color: #dcdcdc;
      border-width: 1px 0px 1px 1px;
      background-color: white;
      display: inline-block;
      cursor: pointer;
      color: #363636;
      font-weight: bold;
      padding: 6px 24px;
      text-decoration: none;
    }
    button:hover {
      background: -webkit-gradient(
        linear,
        left top,
        left bottom,
        color-stop(0.05, #f6f6f6),
        color-stop(1, #ffffff)
      );
      background: -moz-linear-gradient(top, #f6f6f6 5%, #ffffff 100%);
      background: -webkit-linear-gradient(top, #f6f6f6 5%, #ffffff 100%);
      background: -o-linear-gradient(top, #f6f6f6 5%, #ffffff 100%);
      background: -ms-linear-gradient(top, #f6f6f6 5%, #ffffff 100%);
      background: linear-gradient(to bottom, #f6f6f6 5%, #ffffff 100%);
      filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#f6f6f6', endColorstr='#ffffff',GradientType=0);
      background-color: #f6f6f6;
    }
  }
`;
function ConfirmationDialog({
  style: style2 = {},
  buttons = [],
  onClose,
  message
}) {
  const optionsHandler = react.exports.useCallback((e2, {
    handler = () => null
  }) => {
    handler(e2);
    onClose();
  }, [onClose]);
  return /* @__PURE__ */ jsxs("div", {
    style: style2,
    css: styles$19,
    children: [/* @__PURE__ */ jsx("p", {
      className: "message",
      children: message
    }), /* @__PURE__ */ jsx("div", {
      className: "buttons-container",
      children: buttons.map((option) => /* @__PURE__ */ jsx("button", {
        type: "button",
        onClick: (e2) => optionsHandler(e2, option),
        style: option.style && option.style,
        children: option.text
      }, option.text))
    })]
  });
}
const ModalContent = ({
  modal,
  onClose,
  onLayout
}) => {
  const contentSize = react.exports.useRef();
  const [Content, {
    width,
    height
  }] = useSize(() => {
    return /* @__PURE__ */ jsx$1("div", {
      style: {
        height: "100%",
        display: "block",
        overflow: "auto"
      },
      children: react.exports.cloneElement(modal.component, __spreadProps(__spreadValues({}, modal.options), {
        onClose,
        style: {
          cursor: "default"
        }
      }))
    });
  });
  react.exports.useEffect(() => {
    if (isFinite(height) && isFinite(width) && !contentSize.current) {
      contentSize.current = {
        width,
        height
      };
      onLayout({
        modal,
        layout: {
          width,
          height
        }
      });
    }
  }, [width, height, contentSize, onLayout, modal]);
  return Content;
};
const transitionStyles = {
  [transitions.FADE]: {
    entering: {
      opacity: 0
    },
    entered: {
      opacity: 1
    }
  },
  [transitions.SCALE]: {
    entering: {
      transform: "scale(0)"
    },
    entered: {
      transform: "scale(1)"
    },
    exiting: {
      transform: "scale(0)"
    },
    exited: {
      transform: "scale(0)"
    }
  }
};
function Provider({
  children,
  style: style2 = void 0,
  offset = "0px",
  position = positions.MIDDLE,
  transition: transition2 = transitions.SCALE,
  wrapperRef = null
}) {
  const root2 = react.exports.useRef();
  const modalRef = react.exports.useRef();
  const [modal, setModal] = react.exports.useState();
  react.exports.useEffect(() => {
    root2.current = document.createElement("div");
    const ref = root2.current;
    if (wrapperRef) {
      wrapperRef.appendChild(ref);
    }
    return () => {
      if (ref) {
        if (wrapperRef) {
          wrapperRef.removeChild(ref);
        }
      }
    };
  }, [wrapperRef]);
  const close = react.exports.useCallback(function close2() {
    setModal(null);
  }, [setModal]);
  const parentStyle = react.exports.useMemo(() => {
    return wrapperRef ? wrapperRef.getBoundingClientRect() : {
      top: 0,
      left: 0,
      width: window.innerWidth,
      height: window.innerHeight
    };
  }, [wrapperRef]);
  const show = react.exports.useCallback((component, options2 = {}) => {
    const _modal = {
      component,
      options: __spreadValues({
        isBackgroundBlur: true,
        enableResizing: false
      }, options2)
    };
    _modal.close = close;
    setModal(_modal);
    if (_modal.options.onOpen)
      _modal.options.onOpen();
    return _modal;
  }, [close]);
  const showConfirmDialog = react.exports.useCallback((dialogOptions, options2 = {
    enableResizing: false
  }) => {
    const _modal = {
      component: /* @__PURE__ */ jsx(ConfirmationDialog, __spreadValues({}, dialogOptions)),
      options: __spreadValues({
        isBackgroundBlur: true
      }, options2)
    };
    _modal.close = close;
    setModal(_modal);
    if (_modal.options.onOpen)
      _modal.options.onOpen();
    return _modal;
  }, [close]);
  react.exports.useEffect(() => {
    function keyHandler(e2) {
      if (["Escape", "Esc"].includes(e2.key)) {
        close();
      }
    }
    document.addEventListener("keydown", keyHandler, false);
    return () => document.removeEventListener("keydown", keyHandler, false);
  }, [close]);
  const styles2 = css`
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    right: 0;
    z-index: 0;
    pointer-events: all;
    .handle {
      cursor: move;
    }

    .rnd-container {
      box-sizing: initial;
      background-color: #fff;
      box-shadow: 0 0 0 0, 0 8px 16px rgba(0, 0, 0, 0.3);
      border-radius: 5px;
    }
  `;
  const outerStyle = (modal == null ? void 0 : modal.options.isBackgroundBlur) ? {
    backgroundColor: "rgba(255,255,255,0.8)"
  } : {
    pointerEvents: "none"
  };
  const modalContextValue = react.exports.useMemo(() => ({
    show,
    close,
    showConfirmDialog
  }), [show, close, showConfirmDialog]);
  const contentLayoutHandler = react.exports.useCallback(({
    modal: modal2,
    layout
  }) => {
    const width = modal2.options.width ? modal2.options.width : layout.width > parentStyle.width ? parentStyle.width : layout.width;
    const height = modal2.options.height ? modal2.options.height : layout.height > parentStyle.height ? parentStyle.height : layout.height;
    modalRef.current.updateSize({
      width,
      height
    });
  }, [parentStyle.height, parentStyle.width]);
  return /* @__PURE__ */ jsxs(ModalProvider, {
    value: modalContextValue,
    children: [children, root2.current && reactDom.exports.createPortal(/* @__PURE__ */ jsx(react.exports.Fragment, {
      children: modal ? /* @__PURE__ */ jsx("div", {
        css: styles2,
        style: __spreadValues({}, outerStyle),
        children: /* @__PURE__ */ jsx(TransitionGroup, {
          appear: true,
          options: {
            position: modal.options.position ? modal.options.position : position
          },
          containerStyle: parentStyle,
          component: Wrapper,
          children: /* @__PURE__ */ jsx(Transtion, {
            type: modal.options.transition ? modal.options.transition : transition2,
            transitionStyles: __spreadProps(__spreadValues({}, transitionStyles), {
              default: {
                width: modal.options.width ? `${modal.options.width}px` : "auto"
              },
              height: modal.options.height ? `${modal.options.height}px` : "auto"
            }),
            children: /* @__PURE__ */ jsx(Rnd, {
              maxWidth: parentStyle.width,
              maxHeight: parentStyle.height,
              ref: modalRef,
              default: {
                width: modal.options.width ? modal.options.width : "auto",
                height: modal.options.height ? modal.options.height : "auto",
                x: 0,
                y: 0
              },
              className: "rnd-container",
              style: __spreadProps(__spreadValues({}, style2), {
                margin: offset,
                position: "static",
                pointerEvents: "all",
                userSelect: "none"
              }),
              enableResizing: modal.options.enableResizing,
              dragHandleClassName: "handle",
              enableUserSelectHack: false,
              children: /* @__PURE__ */ jsx(ModalContent, {
                modal,
                onClose: close,
                onLayout: contentLayoutHandler
              })
            })
          }, modal.id)
        }, positions[modal.options.transition ? modal.options.transition : transition2])
      }) : null
    }), root2.current)]
  });
}
const styles$18 = {
  popup: {
    position: "fixed",
    top: 0,
    left: 0,
    pointerEvents: "none",
    backgroundColor: "gray",
    padding: "3px",
    borderRadius: "2px",
    color: "white",
    whiteSpace: "nowrap",
    fontSize: "10px",
    fontFamily: "tahoma",
    textShadow: "none"
  }
};
function ToolTip({
  style: style2 = {
    popup: {},
    mainContainer: {}
  },
  className = "",
  popupPlacement = "right",
  children,
  title,
  offset = {
    x: 0,
    y: 0
  }
}) {
  const refChild = react.exports.useRef(null);
  const refContent = react.exports.useRef(null);
  const [placement, setPlacement] = react.exports.useState({
    x: 0,
    y: 0
  });
  const [show, showToolTip] = react.exports.useState(false);
  const {
    elementsWrapperRef
  } = useGlobal();
  react.exports.useLayoutEffect(() => {
    const getPopupPlacement = () => {
      let x;
      let y;
      if (refChild.current === null || refContent.current === null) {
        return null;
      }
      const childBounding = refChild.current.getBoundingClientRect();
      const contentBounding = refContent.current.getBoundingClientRect();
      switch (popupPlacement) {
        case "left":
          x = -contentBounding.width;
          y = childBounding.height / 2 - childBounding.height / 2 * contentBounding.height / childBounding.height;
          break;
        case "right":
          x = childBounding.width;
          y = childBounding.height / 2 - childBounding.height / 2 * contentBounding.height / childBounding.height;
          break;
        case "top":
          x = childBounding.width / 2 - childBounding.width / 2 * contentBounding.width / childBounding.width;
          y = -childBounding.height;
          break;
        case "bottom":
          x = childBounding.width / 2 - childBounding.width / 2 * contentBounding.width / childBounding.width;
          y = childBounding.height;
          break;
        default:
          x = 0;
          y = 0;
          break;
      }
      return {
        x: x + childBounding.x,
        y: y + childBounding.y
      };
    };
    if (show) {
      const pl = getPopupPlacement();
      if (pl) {
        setPlacement(pl);
      }
    }
  }, [popupPlacement, show]);
  const mouseOverHandler = react.exports.useCallback(() => {
    showToolTip(true);
  }, []);
  const mouseLeaveHandler = react.exports.useCallback(() => {
    showToolTip(false);
  }, []);
  return /* @__PURE__ */ jsxs$1(react.exports.Fragment, {
    children: [/* @__PURE__ */ jsx$1("div", {
      style: __spreadValues({
        position: "relative",
        height: "100%",
        display: "flex",
        justifyContent: "center",
        alignItems: "center"
      }, style2.mainContainer),
      ref: refChild,
      onMouseOver: mouseOverHandler,
      onMouseOut: mouseLeaveHandler,
      children
    }), show && elementsWrapperRef && reactDom.exports.createPortal(/* @__PURE__ */ jsx$1("div", {
      ref: refContent,
      style: __spreadValues(__spreadProps(__spreadValues({}, styles$18.popup), {
        transform: `translate(${placement.x + offset.x}px,${placement.y + offset.y}px)`,
        zIndex: 999999999
      }), style2.popup),
      className,
      children: /* @__PURE__ */ jsx$1("span", {
        style: {
          pointerEvents: "none"
        },
        children: title
      })
    }), elementsWrapperRef)]
  });
}
var ToolTip$1 = react.exports.memo(ToolTip);
const styles$17 = {
  button: {
    backgroundColor: "transparent",
    border: "none",
    height: "100%",
    display: "flex",
    justifyContent: "center",
    alignItems: "center"
  },
  svg: {
    fill: "#ca0000",
    fontSize: "16px"
  }
};
function CloseButton(props) {
  const {
    onClick = () => null,
    popupTitle = "Close",
    popupPlacement = "left",
    className = ""
  } = props;
  return /* @__PURE__ */ jsx$1("div", {
    className,
    children: /* @__PURE__ */ jsx$1(ToolTip$1, {
      title: popupTitle,
      popupPlacement,
      children: /* @__PURE__ */ jsx$1("button", {
        style: styles$17.button,
        type: "button",
        onClick,
        children: /* @__PURE__ */ jsx$1(FaTimes, {
          style: styles$17.svg
        })
      })
    })
  });
}
var CloseButton$1 = react.exports.memo(CloseButton);
const styles$16 = css`
  display: flex;
  flex-direction: column;
  width: 900px;
  height: 400px;
  padding: 5px;
  button:focus {
    outline: none;
  }
  .header {
    height: 24px;
    border-bottom: 1px solid #f0f0f0;
    display: flex;
    span {
      color: #464646;
      font-size: 15px;
      flex: 1;
    }

    button {
      background-color: transparent;
      border: none;
      svg {
        height: 16px;
      }
    }
  }
  .container {
    overflow-y: auto;
    background-color: white;
    padding-top: 10px;

    .row {
      outline: none;
      display: flex !important;
      flex-direction: row;
      margin: 0;
      div {
        flex: 4;
      }
      .multiplicity {
        flex: 2;
        display: flex;
        align-items: center;
        justify-content: center;
      }
    }

    .row:nth-child(odd) {
      background: #fafafa;
    }
  }
`;
const loaderStyles = css`
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  user-select: none;
  width: 900px;
  height: 400px;

  svg {
    animation-duration: 0.5s;
    animation-name: spinAnimation;
    animation-iteration-count: infinite;
    animation-fill-mode: forwards;
    animation-direction: inherit;
    animation-timing-function: linear;
    animation-duration: 1s;
    width: 100px;
    height: 100px;
  }

  @keyframes spinAnimation {
    from {
      transform: rotate(0deg);
    }

    to {
      transform: rotate(360deg);
    }
  }
`;
function MultipletAnalysisModal({
  data,
  activeSpectrum,
  scaleX,
  startX,
  endX,
  onClose
}) {
  var _a;
  const [analysisData, setAnalysisData] = react.exports.useState();
  const [calcStart, setCalcStartStatus] = react.exports.useState(false);
  const [isCalcFinished, setCalcFinished] = react.exports.useState(false);
  react.exports.useEffect(() => {
    setTimeout(() => {
      setCalcStartStatus(true);
    }, 400);
  }, []);
  react.exports.useEffect(() => {
    if (activeSpectrum && startX && endX && calcStart) {
      const spectrum = data[activeSpectrum.index];
      if (isSpectrum2D(spectrum)) {
        throw new Error("unreachable");
      }
      const {
        data: {
          x,
          re
        },
        info
      } = spectrum;
      const from = scaleX().invert(startX);
      const to = scaleX().invert(endX);
      const {
        fromIndex,
        toIndex
      } = xGetFromToIndex(x, {
        from,
        to
      });
      const analysesProps = {
        x: x.slice(fromIndex, toIndex),
        y: re.slice(fromIndex, toIndex)
      };
      try {
        const result = analyseMultiplet(analysesProps, {
          frequency: info.originFrequency,
          takeBestPartMultiplet: true,
          symmetrizeEachStep: true,
          debug: true
        });
        setCalcFinished(true);
        setAnalysisData(result);
      } catch (err) {
        console.log(err);
      }
    }
  }, [startX, endX, data, scaleX, activeSpectrum, calcStart]);
  if (!isCalcFinished) {
    return /* @__PURE__ */ jsxs("div", {
      css: loaderStyles,
      children: [/* @__PURE__ */ jsx("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 841.9 595.3",
        children: /* @__PURE__ */ jsxs("g", {
          fill: "#61DAFB",
          children: [/* @__PURE__ */ jsx("path", {
            d: "M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"
          }), /* @__PURE__ */ jsx("path", {
            d: "M520.5 78.1z"
          })]
        })
      }), /* @__PURE__ */ jsx("p", {
        children: "Analyse Multiplet in progress. Please wait ..."
      })]
    });
  }
  return /* @__PURE__ */ jsxs("div", {
    css: styles$16,
    children: [/* @__PURE__ */ jsxs("div", {
      className: "header handle",
      children: [/* @__PURE__ */ jsx("span", {
        children: "Analyse Multiplet"
      }), /* @__PURE__ */ jsx(CloseButton$1, {
        onClick: onClose
      })]
    }), /* @__PURE__ */ jsx("div", {
      className: "container",
      children: (_a = analysisData == null ? void 0 : analysisData.debug) == null ? void 0 : _a.steps.map((d, index2) => {
        var _a2, _b;
        return /* @__PURE__ */ jsxs("div", {
          className: "row",
          children: [/* @__PURE__ */ jsxs(Plot, {
            width: 400,
            height: 200,
            svgStyle: {
              overflow: "visible"
            },
            seriesViewportStyle: {
              stroke: "black"
            },
            children: [/* @__PURE__ */ jsx(LineSeries, {
              data: xyToXYObject(d.multiplet)
            }), /* @__PURE__ */ jsx(Axis, {
              id: "y",
              position: "left",
              tickPosition: "inner",
              displayPrimaryGridLines: true,
              hiddenTicks: true,
              paddingStart: 0.1,
              paddingEnd: 0.1
            }), /* @__PURE__ */ jsx(Axis, {
              id: "x",
              position: "bottom",
              tickPosition: "inner",
              displayPrimaryGridLines: true
            })]
          }), /* @__PURE__ */ jsx("div", {
            className: "multiplicity",
            children: /* @__PURE__ */ jsx("p", {
              children: analysisData.js[index2] ? `${(_a2 = analysisData.js[index2]) == null ? void 0 : _a2.multiplicity}: ${(_b = analysisData.js[index2]) == null ? void 0 : _b.coupling.toFixed(3)} Hz` : ""
            })
          }), /* @__PURE__ */ jsxs(Plot, {
            width: 400,
            height: 200,
            seriesViewportStyle: {
              stroke: "black"
            },
            children: [/* @__PURE__ */ jsx(LineSeries, {
              data: xyToXYObject(d.errorFunction),
              lineStyle: {
                strokeWidth: 1
              }
            }), /* @__PURE__ */ jsx(Axis, {
              id: "y",
              position: "left",
              tickPosition: "inner",
              displayPrimaryGridLines: true,
              hiddenTicks: true,
              paddingStart: 0.1,
              paddingEnd: 0.1
            }), /* @__PURE__ */ jsx(Axis, {
              id: "x",
              position: "bottom",
              tickPosition: "inner",
              displayPrimaryGridLines: true
            })]
          })]
        }, index2);
      })
    })]
  });
}
function useSpectraByActiveNucleus() {
  const { data, activeTab } = useChartData();
  return react.exports.useMemo(() => {
    if (data) {
      return data.filter((spectrum) => activeTab === nucleusToString(spectrum.info.nucleus)) || [];
    }
    return [];
  }, [activeTab, data]);
}
function useActiveSpectrumStyleOptions(id2) {
  const { activeSpectrum } = useChartData();
  const preferences = usePreferences();
  return react.exports.useMemo(() => {
    const isActive = activeSpectrum === null ? true : id2 === activeSpectrum.id ? true : false;
    const opacity = isActive ? 1 : get_1(preferences.current, "controllers.dimmedSpectraTransparency", 0.1);
    return { isActive, opacity };
  }, [activeSpectrum, id2, preferences]);
}
function ExclusionZoneAnnotation({
  zone,
  color,
  vAlign,
  spectrumID
}) {
  const {
    scaleX,
    scaleY
  } = useScaleChecked();
  const highlight = useHighlight([zone.id], {
    type: HighlightedSource.EXCLUSION_ZONE,
    extra: {
      id: zone.id,
      spectrumID
    }
  });
  const {
    opacity
  } = useActiveSpectrumStyleOptions(spectrumID);
  return /* @__PURE__ */ jsx$1("g", {
    transform: `translate(${scaleX()(zone.to)},0)`,
    children: /* @__PURE__ */ jsx$1("rect", __spreadValues({
      x: "0",
      transform: `translate(0,${scaleY()(0) - (vAlign + 5)})`,
      width: `${scaleX()(zone.from) - scaleX()(zone.to)}`,
      height: "10px",
      style: {
        fill: highlight.isActive ? "#ff6f0057" : color,
        opacity
      }
    }, highlight.onHover))
  }, zone.id);
}
var ExclusionZoneAnnotation$1 = react.exports.memo(ExclusionZoneAnnotation);
function getVerticalShift(verticalAlign, option) {
  const { index: index2 = 1, align = "stack" } = option || {
    index: 1,
    align: "stack"
  };
  return verticalAlign.align === align ? index2 * verticalAlign.verticalShift : 0;
}
function ExclusionZonesAnnotationsInner({
  displayerKey,
  xDomains,
  spectra,
  verticalAlign
}) {
  return /* @__PURE__ */ jsx$1("g", {
    className: "spectrum-exclusion-zones-group",
    clipPath: `url(#${displayerKey}clip-chart-1d)`,
    children: spectra.filter((d) => d.display.isVisible === true && xDomains[d.id]).map((d, index2) => getExclusionZones(d).map((zone) => {
      return /* @__PURE__ */ jsx$1(ExclusionZoneAnnotation$1, {
        spectrumID: d.id,
        vAlign: getVerticalShift(verticalAlign, {
          index: index2
        }),
        zone,
        color: d.display.color
      }, zone.id);
    }))
  });
}
const MemoizedPeakAnnotations = react.exports.memo(ExclusionZonesAnnotationsInner);
function ExclusionZonesAnnotations() {
  const {
    displayerKey,
    xDomains,
    displayerMode,
    verticalAlign
  } = useChartData();
  const spectra = useSpectraByActiveNucleus();
  if (displayerMode !== DISPLAYER_MODE.DM_1D)
    return null;
  return /* @__PURE__ */ jsx$1(MemoizedPeakAnnotations, {
    spectra,
    displayerKey,
    xDomains,
    verticalAlign
  });
}
function getExclusionZones(data) {
  var _a;
  return ((_a = data.filters.find((filter2) => filter2.name === id$a && filter2.flag)) == null ? void 0 : _a.value) || [];
}
function useXScale() {
  const { width, margin, xDomains, xDomain, mode } = useChartData();
  return react.exports.useMemo(() => getXScale({ width, margin, xDomains, xDomain, mode }), [margin, mode, width, xDomain, xDomains]);
}
function useIntegralYDomain() {
  const { height, margin, verticalAlign, activeSpectrum, integralsYDomains } = useChartData();
  return react.exports.useMemo(() => getIntegralYScale({
    height,
    margin,
    verticalAlign,
    activeSpectrum,
    integralsYDomains
  }), [activeSpectrum, height, integralsYDomains, margin, verticalAlign]);
}
function useIntegralPath(integralOptions) {
  const { data, activeSpectrum } = useChartData();
  const scaleX = useXScale();
  const scaleY = useIntegralYDomain();
  const integral = react.exports.useMemo(() => {
    if (activeSpectrum) {
      const { x, re } = data[activeSpectrum == null ? void 0 : activeSpectrum.index].data;
      const { from, to } = integralOptions;
      return xyIntegral({ x, y: re }, {
        from,
        to,
        reverse: true
      });
    }
    return { x: [], y: [] };
  }, [activeSpectrum, data, integralOptions]);
  const paths = react.exports.useMemo(() => {
    if (integral) {
      const xySeries = xyReduce(integral, {
        nbPoints: 200,
        optimize: true
      });
      const pathBuilder = new PathBuilder();
      pathBuilder.moveTo(scaleX(xySeries.x[0]), scaleY(xySeries.y[0]));
      for (let i = 1; i < xySeries.x.length; i++) {
        pathBuilder.lineTo(scaleX(xySeries.x[i]), scaleY(xySeries.y[i]));
      }
      return pathBuilder.toString();
    } else {
      return "";
    }
  }, [integral, scaleX, scaleY]);
  return paths;
}
const integralDefaultValues = {
  showAbsolute: false,
  absoluteFormat: "0.00",
  showRelative: true,
  relativeFormat: "0.00",
  color: "#000000",
  strokeWidth: 1
};
const zoneDefaultValues = {
  showFrom: false,
  fromFormat: "0.00",
  showTo: false,
  toFormat: "0.00",
  showAbsolute: false,
  absoluteFormat: "0.00",
  showRelative: true,
  relativeFormat: "0.00"
};
const getRangeDefaultValues = (nucleus) => ({
  showFrom: false,
  fromFormat: "0.00",
  showTo: false,
  toFormat: "0.00",
  showAbsolute: false,
  absoluteFormat: "0.00",
  showRelative: true,
  relativeFormat: "0.00",
  jGraphTolerance: nucleus === "1H" ? 0.2 : nucleus === "13C" ? 2 : 0
});
const peaksDefaultValues = {
  showPeakNumber: true,
  peakNumberFormat: "0",
  showPeakIndex: false,
  peakIndexFormat: "0.00",
  showDeltaPPM: true,
  deltaPPMFormat: "0.00",
  showDeltaHz: false,
  deltaHzFormat: "0.00",
  showPeakWidth: false,
  peakWidthFormat: "00.0000",
  showIntensity: true,
  intensityFormat: "0.00"
};
const databaseDefaultValues = {
  showSmiles: true,
  showSolvent: false,
  showNames: true,
  showRange: false,
  showDelta: true,
  showAssignment: false,
  showCoupling: true,
  showMultiplicity: true
};
function useResizer(props) {
  const {
    initialPosition = {
      x1: 10,
      x2: 40
    },
    onStart,
    onMove,
    onEnd,
    parentElement
  } = props;
  const currentPosition = react.exports.useRef(initialPosition);
  const prevPosition = react.exports.useRef(initialPosition);
  const activeRef = react.exports.useRef(false);
  const triggerEvent = react.exports.useRef((position, status) => {
    switch (status) {
      case "start":
        onStart == null ? void 0 : onStart(position);
        activeRef.current = true;
        break;
      case "move":
        onMove == null ? void 0 : onMove(position);
        break;
      case "end":
        prevPosition.current = position;
        activeRef.current = false;
        onEnd == null ? void 0 : onEnd(position);
        break;
    }
  });
  const right = useDraggable({
    position: {
      x: initialPosition.x2,
      y: 0
    },
    parentElement,
    fromEdge: true
  });
  const left = useDraggable({
    position: {
      x: initialPosition.x1,
      y: 0
    },
    parentElement,
    fromEdge: true
  });
  react.exports.useEffect(() => {
    currentPosition.current = {
      x1: left.position.value.x,
      x2: right.position.value.x
    };
  }, [left.position.value.x, right.position.value.x]);
  react.exports.useEffect(() => {
    const {
      value: {
        x
      },
      action
    } = left.position;
    const position = {
      x1: x,
      x2: currentPosition.current.x2
    };
    triggerEvent.current(position, action);
  }, [left.position]);
  react.exports.useEffect(() => {
    const {
      value: {
        x
      },
      action
    } = right.position;
    const position = {
      x1: currentPosition.current.x1,
      x2: x
    };
    triggerEvent.current(position, action);
  }, [right.position]);
  return react.exports.useMemo(() => ({
    left,
    right,
    prevPosition: prevPosition.current,
    currentPosition: currentPosition.current,
    isActive: activeRef.current
  }), [left, right]);
}
const anchorStyle$1 = {
  marginLeft: "5px",
  width: "2px",
  height: "100%",
  pointerEvents: "none",
  position: "relative"
};
const styles$15 = {
  container: (position) => css`
    position: absolute;
    height: 100%;
    width: 10px;
    left: -5px;
    cursor: e-resize;
    transform: translateX(${position}px);
    user-select: none;
    z-index: 99999999;

    &:hover {
      div {
        background-color: red;
      }
    }
  `,
  content: (left, right, prevPosition) => {
    const width = prevPosition.x2 - prevPosition.x1;
    const baseCss = css`
      position: absolute;
      width: ${width}px;
      overflow: hidden;
    `;
    if (right.position.action === "move" || left.position.action === "move") {
      const scale = (right.position.value.x - left.position.value.x) / width;
      return [baseCss, css`
          transform: translateX(${left.position.value.x}px) scaleX(${scale});
          transform-origin: left center;
        `];
    } else {
      return css([baseCss, css`
          transform: translateX(${left.position.value.x}px);
        `]);
    }
  }
};
function DivResizer(props) {
  const {
    children
  } = props;
  const {
    left,
    right,
    prevPosition,
    currentPosition,
    isActive
  } = useResizer(props);
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [/* @__PURE__ */ jsx("div", {
      "data-no-export": "true",
      onMouseDown: right.onMouseDown,
      css: styles$15.container(right.position.value.x),
      children: /* @__PURE__ */ jsx("div", {
        style: anchorStyle$1
      })
    }), /* @__PURE__ */ jsx("div", {
      css: styles$15.content(left, right, prevPosition),
      children: typeof children === "function" ? children == null ? void 0 : children(currentPosition, isActive) : children
    }), /* @__PURE__ */ jsx("div", {
      "data-no-export": "true",
      onMouseDown: left.onMouseDown,
      css: styles$15.container(left.position.value.x),
      children: /* @__PURE__ */ jsx("div", {
        style: anchorStyle$1
      })
    })]
  });
}
const anchorStyle = {
  width: "2px",
  height: "100%",
  pointerEvents: "none",
  fill: "transparent"
};
const styles$14 = {
  container: (position) => css`
    transform: translateX(${position}px);
    &:hover {
      rect:last-child {
        fill: red !important;
      }
    }
  `,
  innerContainer: css`
    position: absolute;
    height: 100%;
    fill: transparent;
    width: 10px;
    cursor: e-resize;
    user-select: none;
    z-index: 99999999;
  `
};
function SVGResizer(props) {
  const {
    children
  } = props;
  const {
    left,
    right,
    currentPosition,
    isActive
  } = useResizer(props);
  return /* @__PURE__ */ jsxs("g", {
    style: {
      transform: `translateX(${currentPosition.x1}px)`
    },
    children: [typeof children === "function" ? children(currentPosition, isActive) : children, /* @__PURE__ */ jsx(SVGResizerHandle, {
      onMouseDown: left.onMouseDown,
      position: 0
    }), /* @__PURE__ */ jsx(SVGResizerHandle, {
      onMouseDown: right.onMouseDown,
      position: Math.ceil(currentPosition.x2 - currentPosition.x1)
    })]
  });
}
function SVGResizerHandle(props) {
  return /* @__PURE__ */ jsxs("g", {
    onMouseDown: props.onMouseDown,
    css: styles$14.container(props.position),
    "data-no-export": "true",
    children: [/* @__PURE__ */ jsx("rect", {
      x: "-5px",
      css: styles$14.innerContainer
    }), /* @__PURE__ */ jsx("rect", {
      x: "-2.5px",
      style: anchorStyle
    })]
  });
}
function Resizer(props) {
  const _a = props, {
    tag = "div"
  } = _a, resProps = __objRest(_a, [
    "tag"
  ]);
  if (tag === "div") {
    return /* @__PURE__ */ jsx$1(DivResizer, __spreadValues({}, resProps));
  } else {
    return /* @__PURE__ */ jsx$1(SVGResizer, __spreadValues({}, resProps));
  }
}
const stylesOnHover$1 = css`
  pointer-events: bounding-box;
  @-moz-document url-prefix() {
    pointer-events: fill;
  }
  .highlight {
    fill: transparent;
  }
  .target {
    visibility: hidden;
  }
`;
const stylesHighlighted$1 = css`
  pointer-events: bounding-box;

  @-moz-document url-prefix() {
    pointer-events: fill;
  }
  fill: #ff6f0057;

  .target {
    visibility: visible;
  }
`;
function IntegralResizable({
  integralData
}) {
  const {
    height,
    margin
  } = useChartData();
  const {
    viewerRef
  } = useGlobal();
  const {
    scaleX
  } = useScaleChecked();
  const dispatch = useDispatch();
  const {
    id: id2,
    integral
  } = integralData;
  const highlight = useHighlight([id2], {
    type: HighlightedSource.INTEGRAL,
    extra: {
      id: id2
    }
  });
  const handleOnStopResizing = react.exports.useCallback((position) => {
    dispatch({
      type: RESIZE_INTEGRAL,
      payload: {
        data: __spreadProps(__spreadValues({}, integralData), {
          from: scaleX().invert(position.x2),
          to: scaleX().invert(position.x1)
        })
      }
    });
  }, [dispatch, integralData, scaleX]);
  const handleOnEnterNotation = react.exports.useCallback(() => {
    highlight.show();
  }, [highlight]);
  const handleOnMouseLeaveNotation = react.exports.useCallback(() => {
    highlight.hide();
  }, [highlight]);
  const from = integralData.from ? scaleX()(integralData.from) : 0;
  const to = integralData.to ? scaleX()(integralData.to) : 0;
  return /* @__PURE__ */ jsx("g", {
    onMouseEnter: handleOnEnterNotation,
    onMouseLeave: handleOnMouseLeaveNotation,
    children: /* @__PURE__ */ jsx(Resizer, {
      tag: "svg",
      initialPosition: {
        x1: to,
        x2: from
      },
      onEnd: handleOnStopResizing,
      parentElement: viewerRef,
      children: ({
        x1,
        x2
      }, isActive) => /* @__PURE__ */ jsxs("g", {
        css: highlight.isActive || isActive ? stylesHighlighted$1 : stylesOnHover$1,
        children: [/* @__PURE__ */ jsx("rect", {
          x: "0",
          y: "0",
          width: x2 - x1,
          height: height - margin.bottom,
          className: "highlight",
          "data-no-export": "true"
        }), /* @__PURE__ */ jsx("text", {
          x: 0,
          y: height - margin.bottom + 30,
          fill: "black",
          style: {
            fontSize: "12px",
            fontWeight: "bold"
          },
          children: integral !== void 0 ? integral.toFixed(2) : ""
        })]
      })
    }, `${id2}_${to}_${from}`)
  });
}
function Integral({
  integral,
  isActive
}) {
  const preferences = usePreferences();
  const path = useIntegralPath(integral);
  const integralSettings = react.exports.useMemo(() => {
    let {
      color = integralDefaultValues.color,
      strokeWidth = integralDefaultValues.strokeWidth
    } = getValue(preferences.current, "formatting.panels.integrals") || {};
    return {
      color,
      strokeWidth
    };
  }, [preferences]);
  return /* @__PURE__ */ jsxs$1("g", {
    children: [/* @__PURE__ */ jsx$1("path", {
      className: "line",
      stroke: integralSettings.color,
      strokeWidth: integralSettings.strokeWidth,
      fill: "none",
      style: {
        opacity: isActive ? 1 : 0.2
      },
      d: path
    }), /* @__PURE__ */ jsx$1(IntegralResizable, {
      integralData: integral
    })]
  });
}
function IntegralsSeries() {
  const {
    xDomains,
    activeSpectrum,
    data,
    displayerKey
  } = useChartData();
  const Integrals = react.exports.useMemo(() => {
    const isActive = (id2) => {
      return activeSpectrum === null ? true : id2 === activeSpectrum.id ? true : false;
    };
    return /* @__PURE__ */ jsx$1("g", {
      className: "integrals",
      children: (data == null ? void 0 : data[0]) && data.filter((d) => d.display.isVisible === true && xDomains[d.id]).filter(isSpectrum1D).map((spectrum) => spectrum.integrals.values.map((integral) => /* @__PURE__ */ jsx$1(Integral, {
        integral,
        isActive: isActive(spectrum.id)
      }, integral.id)))
    });
  }, [activeSpectrum, data, xDomains]);
  return /* @__PURE__ */ jsx$1("g", {
    clipPath: `url(#${displayerKey}clip-chart-1d)`,
    children: Integrals
  });
}
function Line({
  data,
  id: id2,
  display,
  index: index2
}) {
  const {
    verticalAlign
  } = useChartData();
  const {
    scaleX,
    scaleY
  } = useScaleChecked();
  const xyReduce2 = useXYReduce(XYReducerDomainAxis.XAxis);
  const {
    opacity
  } = useActiveSpectrumStyleOptions(id2);
  const vAlign = react.exports.useMemo(() => {
    return getVerticalShift(verticalAlign, {
      index: index2
    });
  }, [index2, verticalAlign]);
  const paths = react.exports.useMemo(() => {
    const _scaleX = scaleX();
    const _scaleY = scaleY(id2);
    const pathBuilder = new PathBuilder();
    if ((data == null ? void 0 : data.x) && (data == null ? void 0 : data.y) && _scaleX(0)) {
      const pathPoints = xyReduce2(data);
      pathBuilder.moveTo(_scaleX(pathPoints.x[0]), _scaleY(pathPoints.y[0]));
      for (let i = 1; i < pathPoints.x.length; i++) {
        pathBuilder.lineTo(_scaleX(pathPoints.x[i]), _scaleY(pathPoints.y[i]));
      }
      return pathBuilder.toString();
    } else {
      return "";
    }
  }, [scaleX, scaleY, id2, data, xyReduce2]);
  return /* @__PURE__ */ jsx$1("path", {
    className: "line",
    "data-test-id": "spectrum-line",
    stroke: display.color,
    fill: "none",
    style: {
      opacity
    },
    d: paths,
    transform: `translate(0,-${vAlign})`
  }, id2);
}
function LinesSeries() {
  const {
    data,
    tempData,
    displayerKey,
    xDomains
  } = useChartData();
  const _data = tempData ? tempData : data;
  return /* @__PURE__ */ jsx$1("g", {
    clipPath: `url(#${displayerKey}clip-chart-1d)`,
    className: "spectrums",
    children: _data == null ? void 0 : _data.filter((d) => d.display.isVisible === true && xDomains[d.id]).map((d, i) => /* @__PURE__ */ jsx$1(Line, __spreadProps(__spreadValues({}, d), {
      data: get1DDataXY(d),
      index: i
    }), d.id))
  });
}
const styles$13 = css`
  input {
    -webkit-user-select: text; /* Safari 3.1+ */
    -moz-user-select: text; /* Firefox 2+ */
    -ms-user-select: text; /* IE 10+ */
    user-select: text; /* Standard syntax */
  }

  input[type='number']::-webkit-outer-spin-button,
  input[type='number']::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  input[type='number'] {
    -moz-appearance: textfield;
  }

  .notification-input-normal {
    opacity: 1;
    left: 4px;
    position: fixed;
    font-size: 10px;
    outline: none;
    background-color: transparent;
  }

  .notification-input-normal input:focus {
    outline: none;
    background-color: white;
  }

  .input-over {
    background-color: white;
    outline: none;
  }
`;
function PeakAnnotation({
  id: id2,
  x,
  y,
  sign,
  value,
  color,
  isActive,
  nucleus
}) {
  const refText = react.exports.useRef(null);
  const [isSelected, setIsSelected] = react.exports.useState(false);
  const [_value, setValue] = react.exports.useState(value);
  const [containerSize, setContainerSize] = react.exports.useState({
    width: 0,
    height: 0
  });
  const format2 = useFormatNumberByNucleus(nucleus);
  const highlight = useHighlight([id2], {
    type: HighlightedSource.PEAK,
    extra: {
      id: id2
    }
  });
  const dispatch = useDispatch();
  const handleOnPeakChange = react.exports.useCallback((e2) => dispatch({
    type: SHIFT_SPECTRUM,
    shiftValue: e2.shiftValue
  }), [dispatch]);
  react.exports.useLayoutEffect(() => {
    var _a;
    const textBox = (_a = refText.current) == null ? void 0 : _a.getBBox();
    setContainerSize({
      width: (textBox == null ? void 0 : textBox.width) || 0,
      height: (textBox == null ? void 0 : textBox.height) || 0
    });
  }, [isSelected]);
  react.exports.useEffect(() => {
    setValue(value);
  }, [value]);
  const handleKeyDown = react.exports.useCallback((event) => {
    if (event.key === "Enter") {
      const newValue2 = event.currentTarget.valueAsNumber;
      if (!isNaN(newValue2)) {
        const shiftValue = newValue2 - value;
        handleOnPeakChange({
          id: id2,
          value: newValue2,
          oldValue: value,
          shiftValue
        });
        event.currentTarget.blur();
        setIsSelected(false);
      }
    } else if (event.key === "Escape") {
      setValue(value);
      event.currentTarget.blur();
      setIsSelected(false);
    }
  }, [value, handleOnPeakChange, id2]);
  const handleChange = react.exports.useCallback((event) => {
    setValue(event.target.value);
  }, []);
  const handleSelectPeakAnnotation = react.exports.useCallback((e2) => {
    e2.stopPropagation();
    setIsSelected(true);
    return false;
  }, []);
  const handleOnEnterNotation = react.exports.useCallback(() => {
    highlight.show();
  }, [highlight]);
  const handleOnMouseLeaveNotation = react.exports.useCallback(() => {
    highlight.hide();
  }, [highlight]);
  const newValue = react.exports.useMemo(() => isSelected ? value : format2(value), [format2, isSelected, value]);
  const oldValue = react.exports.useMemo(() => isSelected ? _value : format2(_value), [_value, format2, isSelected]);
  return /* @__PURE__ */ jsxs("g", {
    css: styles$13,
    id: id2,
    style: {
      outline: "none"
    },
    transform: `translate(${x}, ${y})`,
    onMouseEnter: handleOnEnterNotation,
    onMouseLeave: handleOnMouseLeaveNotation,
    children: [/* @__PURE__ */ jsx("line", {
      x1: "0",
      x2: "0",
      y1: sign === -1 ? 10 : 0,
      y2: sign === -1 ? 28 : -18,
      stroke: color,
      strokeWidth: highlight.isActive ? "7px" : "1px"
    }), /* @__PURE__ */ jsx("text", {
      ref: refText,
      className: "peaks-text",
      x: "0",
      y: sign === -1 ? 28 : -12,
      dy: "0",
      dx: "0.35em",
      fill: "transparent",
      fontSize: "10px",
      fontWeight: "100",
      style: {
        position: "absolute"
      },
      children: newValue
    }), /* @__PURE__ */ jsx("foreignObject", {
      x: "0",
      y: sign === -1 ? 16 : -22,
      dy: "0.1em",
      dx: "0.35em",
      width: containerSize.width + 20,
      height: "40px",
      "data-no-export": "true",
      children: /* @__PURE__ */ jsx("div", {
        style: {
          width: containerSize.width + 20,
          height: "100%",
          paddingRight: 5
        },
        children: /* @__PURE__ */ jsx("input", {
          onClick: handleSelectPeakAnnotation,
          className: isSelected ? "input-over" : "notification-input-normal",
          style: {
            width: "inherit",
            border: isSelected ? `1px solid ${color}` : `0`,
            opacity: isActive ? 1 : 0.2,
            userSelect: "none",
            color
          },
          value: oldValue,
          onKeyDown: handleKeyDown,
          onChange: handleChange,
          type: "number",
          disabled: !isActive
        })
      })
    })]
  });
}
function PeakAnnotations() {
  const {
    data,
    activeSpectrum,
    verticalAlign,
    displayerKey,
    xDomains
  } = useChartData();
  const {
    scaleX,
    scaleY
  } = useScaleChecked();
  const Peaks = react.exports.useMemo(() => {
    const getVerticalAlign = (id2) => {
      const index2 = data.findIndex((d) => d.id === id2);
      return getVerticalShift(verticalAlign, {
        index: index2
      });
    };
    const reSortData = () => {
      const _data = [...data];
      return activeSpectrum ? _data.sort((x, y) => {
        return x.id === activeSpectrum.id ? 1 : y.id === activeSpectrum.id ? -1 : 0;
      }) : _data;
    };
    return data && reSortData().filter((d) => d.display.isVisible === true && xDomains[d.id]).filter(isSpectrum1D).map((d) => {
      var _a;
      return ((_a = d.peaks) == null ? void 0 : _a.values) && d.display.isPeaksMarkersVisible && /* @__PURE__ */ jsx$1("g", {
        transform: `translate(0,-${getVerticalAlign(d.id)})`,
        children: d.peaks.values.map(({
          x,
          y,
          id: id2
        }) => /* @__PURE__ */ jsx$1(PeakAnnotation, {
          x: scaleX()(x),
          y: scaleY(d.id)(y) - 5,
          sign: Math.sign(y),
          id: id2,
          value: x,
          color: "#730000",
          nucleus: d.info.nucleus,
          isActive: activeSpectrum == null ? false : activeSpectrum.id === d.id ? true : false
        }, id2))
      }, d.id);
    });
  }, [data, verticalAlign, activeSpectrum, xDomains, scaleX, scaleY]);
  return /* @__PURE__ */ jsx$1("g", {
    className: "peaks",
    clipPath: `url(#${displayerKey}clip-chart-1d)`,
    children: Peaks
  });
}
const emptyData$b = {
  info: {
    originFrequency: 400
  }
};
function ResurrectedDatabaseRanges() {
  var _a;
  const {
    displayerKey,
    verticalAlign,
    height,
    margin
  } = useChartData();
  const {
    info
  } = useSpectrum(emptyData$b);
  const {
    highlight
  } = useHighlightData();
  const {
    scaleX
  } = useScaleChecked();
  if (((_a = highlight.sourceData) == null ? void 0 : _a.type) !== HighlightedSource.DATABASE) {
    return null;
  }
  const fullHeight = height - margin.bottom;
  const blockHight = fullHeight / 4;
  const {
    ranges
  } = highlight.sourceData.extra || [];
  let yDomain = [0, 0];
  const spectra = ranges.map((range2) => {
    const {
      from,
      to
    } = range2;
    const diff = Math.abs(from - to) / 2;
    const newForm = from - diff;
    const newTo = to + diff;
    const data = rangesToXY([range2], {
      frequency: info.originFrequency,
      from: newForm,
      to: newTo,
      nbPoints: 256
    });
    const domain = extent(data.y);
    yDomain[0] = domain[0] < yDomain[0] ? domain[0] : yDomain[0];
    yDomain[1] = domain[1] > yDomain[1] ? domain[1] : yDomain[1];
    return {
      data,
      from: newForm,
      to: newTo
    };
  }, []);
  const scaleY = getYScale$1({
    height: blockHight,
    margin: {
      top: 0,
      bottom: 0
    },
    verticalAlign,
    yDomain
  });
  const paths = spectra.map(({
    data: {
      x,
      y
    },
    from,
    to
  }) => {
    let path = `M ${scaleX()(x[0])} ${scaleY(y[0])} `;
    path += x.slice(1).reduce((accumulator, point, i) => {
      accumulator += ` L ${scaleX()(point)} ${scaleY(y[i + 1])}`;
      return accumulator;
    }, "");
    return {
      path,
      from,
      to
    };
  }, []);
  return /* @__PURE__ */ jsx$1("g", {
    clipPath: `url(#${displayerKey}clip-chart-1d)`,
    className: "resurrected-database-ranges",
    width: "100%",
    height: "100%",
    children: paths.map(({
      path,
      from,
      to
    }, index2) => /* @__PURE__ */ jsxs$1("g", {
      children: [/* @__PURE__ */ jsx$1("g", {
        transform: `translate(${scaleX()(to)},0)`,
        children: /* @__PURE__ */ jsx$1("rect", {
          x: "0",
          width: Math.abs(scaleX()(to) - scaleX()(from)),
          height: "100%",
          fill: "#ff6f0057"
        })
      }), /* @__PURE__ */ jsx$1("path", {
        transform: `translate(0,${fullHeight - blockHight * 2})`,
        stroke: "black",
        fill: "none",
        d: path
      })]
    }, `${index2}`))
  });
}
const axisStyles = css`
  user-select: none;

  path,
  line {
    fill: none;
    stroke: black;
    stroke-width: 1;
    shape-rendering: crispEdges;
    user-select: none;
  }
`;
const gridStyles = css`
  user-select: none;

  line {
    stroke: rgb(104, 104, 104);
    stroke-opacity: 0.2;
    shape-rendering: crispEdges;
    stroke-dasharray: 3;
    stroke-width: 1;
    user-select: none;
  }

  path {
    stroke-width: 0;
  }
`;
function XAxis(props) {
  const {
    show = true,
    showGrid = false,
    mode,
    label: labelProp
  } = props;
  const {
    xDomain,
    height,
    width,
    margin
  } = useChartData();
  const {
    scaleX
  } = useScale();
  const refAxis = react.exports.useRef(null);
  const refGrid = react.exports.useRef(null);
  const label = labelProp ? labelProp : mode === "RTL" ? "\u03B4 [ppm]" : "time [s]";
  react.exports.useEffect(() => {
    if (!show || !scaleX)
      return;
    const xAxis = axisBottom(scaleX().domain(xDomain)).ticks(8).tickFormat(format("0"));
    const grid = axisBottom(scaleX().domain(xDomain)).ticks(50).tickSize(-(height - margin.top - margin.bottom)).tickFormat(() => "");
    select(refAxis.current).call(xAxis);
    select(refGrid.current).call(grid);
  }, [height, margin.bottom, margin.top, scaleX, show, xDomain]);
  if (!width || !height || !scaleX) {
    return null;
  }
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [show && /* @__PURE__ */ jsx("g", {
      className: "x",
      css: axisStyles,
      transform: `translate(0,${height - margin.bottom})`,
      ref: refAxis,
      children: /* @__PURE__ */ jsx("text", {
        fill: "#000",
        x: width - 10,
        y: "30",
        dy: "0.70em",
        textAnchor: "end",
        children: label
      })
    }), showGrid && /* @__PURE__ */ jsx("g", {
      css: gridStyles,
      className: "grid",
      ref: refGrid,
      transform: `translate(0,${height - margin.bottom})`
    })]
  });
}
function generateJGraphData(ranges, jGraphTolerance) {
  if (!ranges && !Array.isArray(ranges))
    return null;
  let signals = [];
  let jCouplingMax = 0;
  let links = createLinks(ranges, jGraphTolerance);
  for (const range2 of ranges) {
    for (const signal of range2.signals) {
      const _a = signal, { id: signalId } = _a, restSignal = __objRest(_a, ["id"]);
      if (restSignal.js) {
        signals.push(__spreadValues({ id: `${range2.id}${signalId}` }, restSignal));
        const tempMax = getJsCouplingMax(restSignal.js);
        jCouplingMax = tempMax > jCouplingMax ? tempMax : jCouplingMax;
      }
    }
  }
  return { signals, jCouplingMax, links };
}
function getJsCouplingMax(js) {
  let max2 = -Infinity;
  for (const { coupling } of js) {
    max2 = coupling > max2 ? coupling : max2;
  }
  return max2;
}
function getCouplings(ranges) {
  const couplings = [];
  for (let range2 of ranges) {
    for (const { delta, js } of range2.signals) {
      for (const { coupling } of js || []) {
        couplings.push({ coupling, delta });
      }
    }
  }
  return couplings;
}
function initLink(coupling) {
  const { delta } = coupling;
  return {
    id: generateID(),
    from: delta,
    to: delta,
    couplings: [coupling]
  };
}
function createLinks(ranges, jGraphTolerance = 0) {
  const couplings = getCouplings(ranges).sort((a, b) => a.coupling - b.coupling);
  if (!couplings || couplings.length === 0)
    return [];
  const links = [initLink(couplings[0])];
  let index2 = 0;
  let start = index2;
  let end = 1;
  while (end < couplings.length) {
    const nextCoupling = couplings[end];
    if (Math.abs(couplings[start].coupling - nextCoupling.coupling) < jGraphTolerance) {
      links[index2].couplings.push(nextCoupling);
      if (nextCoupling.delta > links[index2].to) {
        links[index2].to = nextCoupling.delta;
      } else if (nextCoupling.delta < links[index2].from) {
        links[index2].from = nextCoupling.delta;
      }
      end++;
    } else {
      if (Math.abs(couplings[end - 1].coupling - nextCoupling.coupling) < jGraphTolerance) {
        start = end - 1;
      } else {
        index2++;
        links[index2] = initLink(couplings[end]);
        start = end;
        end = end + 1;
      }
    }
  }
  return links;
}
const JGraphContext = react.exports.createContext({
  scaleY: null,
  height: 0,
  maxValue: 0
});
const JGraphContextProvider = JGraphContext.Provider;
function useJGraph() {
  const jGraphState = react.exports.useContext(JGraphContext);
  if (!jGraphState.scaleY) {
    throw new Error("scale cannot be null");
  }
  return jGraphState;
}
const VerticalAxis = react.exports.forwardRef((props, ref) => {
  const {
    x,
    y,
    height,
    showGrid,
    ticks
  } = props;
  return /* @__PURE__ */ jsxs$1("g", {
    ref,
    transform: `translate(${x}, ${y})`,
    children: [/* @__PURE__ */ jsx$1("line", {
      y2: height,
      x1: 15,
      x2: 15,
      stroke: "black"
    }), ticks.map(({
      label,
      position
    }, index2) => /* @__PURE__ */ jsxs$1("g", {
      children: [showGrid && props.width && /* @__PURE__ */ jsx$1("line", {
        y1: position,
        y2: position,
        x1: 15,
        x2: props.width - x,
        stroke: "lightgray"
      }), /* @__PURE__ */ jsx$1("line", {
        y1: position,
        y2: position,
        x1: 15,
        x2: 10,
        stroke: "black"
      }), /* @__PURE__ */ jsx$1("text", {
        y: position,
        dominantBaseline: "middle",
        textAnchor: "end",
        children: label
      })]
    }, index2 + label + position))]
  });
});
function LinearVerticalAxis(props) {
  const _a = props, {
    scale
  } = _a, other = __objRest(_a, [
    "scale"
  ]);
  const ref = react.exports.useRef(null);
  const ticks = useLinearPrimaryTicks(scale, "vertical", ref);
  return /* @__PURE__ */ jsx$1(VerticalAxis, __spreadProps(__spreadValues({}, other), {
    ticks,
    ref
  }));
}
function JGraphVerticalAxis() {
  const {
    width,
    margin
  } = useChartData();
  const {
    height,
    scaleY
  } = useJGraph();
  if (!scaleY)
    return null;
  return /* @__PURE__ */ jsx$1("svg", {
    style: {
      overflow: "visible"
    },
    height: height + 20,
    width: 60,
    children: /* @__PURE__ */ jsx$1(LinearVerticalAxis, {
      x: 20,
      y: 0,
      scale: scaleY,
      height,
      showGrid: true,
      width: width - margin.right
    })
  });
}
function JsCouplingLinks(props) {
  const {
    links
  } = props;
  const {
    scaleX
  } = useScaleChecked();
  const {
    scaleY,
    maxValue
  } = useJGraph();
  const generatePath = react.exports.useCallback((link) => {
    if (!scaleY)
      return "";
    const {
      from,
      to,
      couplings
    } = link;
    let paths = [];
    for (const coupling of couplings) {
      paths.push(`M${scaleX()(from)},${scaleY(coupling.coupling)} L${scaleX()(to)},${scaleY(coupling.coupling)}`);
    }
    return paths.join(" ");
  }, [scaleX, scaleY]);
  return /* @__PURE__ */ jsx$1("g", {
    className: "js-coupling-links",
    children: links.filter((link) => link.couplings.length > 1).map((link) => {
      return /* @__PURE__ */ jsx$1("path", {
        d: generatePath(link),
        style: {
          stroke: `hsl(${link.couplings[0].coupling * 360 / maxValue},100%,50%)`
        },
        strokeWidth: "1"
      }, link.id);
    })
  });
}
function JsCoupling({
  value
}) {
  const {
    scaleY,
    maxValue
  } = useJGraph();
  const [isOver, setOver] = react.exports.useState(false);
  if (!scaleY)
    return null;
  return /* @__PURE__ */ jsxs$1("g", {
    className: "coupling",
    style: {
      transform: `translate(0px,${scaleY(value)}px)`
    },
    children: [/* @__PURE__ */ jsx$1("circle", {
      onMouseEnter: () => setOver(true),
      onMouseLeave: () => setOver(false),
      cx: 0,
      cy: 0,
      r: 4,
      fill: `hsl(${value * 360 / maxValue},100%,${isOver ? 45 : 50}%)`,
      pointerEvents: "all"
    }), isOver && /* @__PURE__ */ jsxs$1("g", {
      style: {
        transform: `translate(0px,15px)`
      },
      children: [/* @__PURE__ */ jsx$1("text", {
        pointerEvents: "none",
        stroke: "white",
        strokeWidth: "0.6em",
        fontSize: "11px",
        dominantBaseline: "middle",
        textAnchor: "end",
        children: `${value.toFixed(1)} Hz`
      }), /* @__PURE__ */ jsx$1("text", {
        pointerEvents: "none",
        stroke: "black",
        fontSize: "11px",
        dominantBaseline: "middle",
        textAnchor: "end",
        children: `${value.toFixed(1)} Hz`
      })]
    })]
  });
}
function JsCouplings(props) {
  const {
    scaleX
  } = useScaleChecked();
  const {
    height
  } = useJGraph();
  return /* @__PURE__ */ jsx$1("g", {
    className: "js-coupling",
    children: props.signals.map((signal) => {
      var _a;
      return /* @__PURE__ */ jsxs$1("g", {
        transform: `translate(${scaleX()(signal.delta)},0)`,
        children: [/* @__PURE__ */ jsx$1("line", {
          x1: "0",
          y1: height,
          x2: "0",
          y2: "0",
          stroke: "black",
          strokeWidth: "1"
        }), (_a = signal.js) == null ? void 0 : _a.map((j) => {
          return /* @__PURE__ */ jsx$1(JsCoupling, {
            value: j.coupling
          }, `${j.coupling}`);
        })]
      }, signal.id);
    })
  });
}
const marginTop = 50;
function InnerJGraph(props) {
  const {
    signals,
    links
  } = props;
  return /* @__PURE__ */ jsxs$1("g", {
    className: "j-graph",
    transform: `translate(0,${marginTop})`,
    children: [/* @__PURE__ */ jsx$1(JGraphVerticalAxis, {}), /* @__PURE__ */ jsx$1(JsCouplingLinks, {
      links
    }), /* @__PURE__ */ jsx$1(JsCouplings, {
      signals
    })]
  });
}
const emptyData$a = {
  ranges: {}
};
const MemoizedJGraph = react.exports.memo(InnerJGraph);
function JGraph() {
  const preferences = usePreferences();
  const {
    height,
    toolOptions: {
      data: {
        showJGraph
      }
    },
    activeTab
  } = useChartData();
  const graphHeight = height / 4;
  const {
    ranges
  } = useSpectrum(emptyData$a);
  const jGraphTolerance = react.exports.useMemo(() => {
    const _preferences = get_1(preferences.current, `formatting.panels.ranges.[${activeTab}]`) || getRangeDefaultValues(activeTab);
    return _preferences.jGraphTolerance;
  }, [activeTab, preferences]);
  const {
    signals,
    jCouplingMax: maxValue,
    links
  } = react.exports.useMemo(() => generateJGraphData(ranges.values, jGraphTolerance) || {
    signals: [],
    jCouplingMax: 0,
    links: []
  }, [jGraphTolerance, ranges.values]);
  const scaleY = react.exports.useMemo(() => {
    const maxRange = maxValue + maxValue * 0.1;
    return linear().range([graphHeight, 0]).domain([0, maxRange]);
  }, [graphHeight, maxValue]);
  const JGraphState = react.exports.useMemo(() => {
    return {
      scaleY,
      height: graphHeight,
      maxValue
    };
  }, [graphHeight, scaleY, maxValue]);
  if (!showJGraph)
    return null;
  return /* @__PURE__ */ jsx$1(JGraphContextProvider, {
    value: JGraphState,
    children: /* @__PURE__ */ jsx$1(MemoizedJGraph, {
      signals,
      links
    })
  });
}
function DeleteButton$1(props) {
  const {
    x = "initial",
    y = "initial",
    onDelete = () => null,
    fill = "#c81121"
  } = props;
  return /* @__PURE__ */ jsxs$1("svg", {
    className: "delete-button",
    x,
    y,
    onClick: onDelete,
    "data-no-export": "true",
    children: [/* @__PURE__ */ jsx$1("rect", {
      rx: "5",
      width: "16",
      height: "16",
      fill
    }), /* @__PURE__ */ jsx$1("line", {
      x1: "5",
      x2: "10",
      y1: "8",
      y2: "8",
      stroke: "white",
      strokeWidth: "2"
    })]
  });
}
const styles$12 = {
  common: css`
    pointer-events: bounding-box;

    @-moz-document url-prefix() {
      pointer-events: fill;
    }
  `,
  hover: css`
    .delete-button {
      visibility: hidden;
    }
  `,
  Highlighted: css`
    .range-area {
      height: 100%;
      fill: #ff6f0057;
    }
    .delete-button {
      visibility: visible;
      cursor: pointer;
    }
  `
};
function AnalysisRange({
  rangeData,
  columnKey
}) {
  const highlight = useHighlight([columnKey]);
  const {
    scaleX
  } = useScaleChecked();
  const dispatch = useDispatch();
  const {
    viewerRef
  } = useGlobal();
  const deleteHandler = react.exports.useCallback(() => {
    dispatch({
      type: DELETE_ANALYZE_SPECTRA_RANGE,
      colKey: columnKey
    });
  }, [columnKey, dispatch]);
  const resizeEndHandler = react.exports.useCallback((resized) => {
    dispatch({
      type: RESIZE_ANALYZE_SPECTRA_RANGE,
      payload: __spreadProps(__spreadValues(__spreadValues({}, rangeData), resized), {
        columnKey
      })
    });
  }, [columnKey, dispatch, rangeData]);
  const from = scaleX()(rangeData.from);
  const to = scaleX()(rangeData.to);
  return /* @__PURE__ */ jsx("g", __spreadProps(__spreadValues({}, highlight.onHover), {
    children: /* @__PURE__ */ jsx(Resizer, {
      tag: "svg",
      onEnd: resizeEndHandler,
      initialPosition: {
        x2: from,
        x1: to
      },
      parentElement: viewerRef,
      children: ({
        x1,
        x2
      }, isActive) => /* @__PURE__ */ jsxs(Fragment, {
        children: [/* @__PURE__ */ jsxs("g", {
          transform: `translate(0,25)`,
          css: [styles$12.common, highlight.isActive || isActive ? styles$12.Highlighted : styles$12.hover],
          children: [/* @__PURE__ */ jsx("rect", {
            x: "0",
            width: x2 - x1,
            height: "6",
            className: "range-area",
            fill: "green"
          }), /* @__PURE__ */ jsx("text", {
            textAnchor: "middle",
            x: (x2 - x1) / 2,
            y: "-5",
            fontSize: "12",
            fill: "red",
            fontWeight: "bolder",
            fillOpacity: highlight.isActive ? 1 : 0.6,
            children: columnKey
          })]
        }), /* @__PURE__ */ jsx(DeleteButton$1, {
          x: -20,
          y: 10,
          onDelete: deleteHandler
        })]
      })
    }, `${columnKey}_${to}_${from}`)
  }));
}
function MultiAnalysisRangesInner({
  activeTab,
  spectraAnalysis,
  displayerKey
}) {
  const columns = react.exports.useMemo(() => {
    const {
      options: {
        columns: columns2
      }
    } = spectraAnalysis[activeTab] || {
      options: {
        columns: {}
      }
    };
    return columns2;
  }, [activeTab, spectraAnalysis]);
  const ranges = react.exports.useMemo(() => {
    return Object.keys(columns).map((key) => key, []);
  }, [columns]);
  if (!ranges || ranges.length === 0) {
    return null;
  }
  return /* @__PURE__ */ jsx$1("g", {
    clipPath: `url(#${displayerKey}clip-chart-1d)`,
    children: ranges.map((columnKey) => /* @__PURE__ */ jsx$1(AnalysisRange, {
      columnKey,
      rangeData: columns[columnKey]
    }, columnKey))
  });
}
const MemoizedMultiAnalysisRanges = react.exports.memo(MultiAnalysisRangesInner);
function MultiAnalysisRanges() {
  const {
    activeTab,
    spectraAnalysis,
    displayerKey
  } = useChartData();
  return /* @__PURE__ */ jsx$1(MemoizedMultiAnalysisRanges, {
    activeTab,
    spectraAnalysis,
    displayerKey
  });
}
const Multiplets = [
  { label: "massive (m)", value: "m", multiplicity: null },
  { label: "singlet (s)", value: "s", multiplicity: 1 },
  { label: "doublet (d)", value: "d", multiplicity: 2 },
  { label: "triplet (t)", value: "t", multiplicity: 3 },
  { label: "quartet (q)", value: "q", multiplicity: 4 },
  { label: "quintet (i)", value: "i", multiplicity: 5 },
  { label: "sextet (x)", value: "x", multiplicity: 6 },
  { label: "septet (p)", value: "p", multiplicity: 7 },
  { label: "octet (o)", value: "o", multiplicity: 8 },
  { label: "nonet (n)", value: "n", multiplicity: 9 }
];
function getMultiplicityNumber(string) {
  const multiplet = Multiplets.find((_multiplet) => string === _multiplet.label || string === _multiplet.value);
  return multiplet ? multiplet.multiplicity : null;
}
function checkMultiplet(multiplet, rejected = []) {
  if (multiplet === void 0 || multiplet.length === 0) {
    return false;
  }
  const _multiplet = Multiplets.find((m) => m.value === multiplet || m.label === multiplet);
  return _multiplet && !rejected.includes(_multiplet.value) && !rejected.includes(_multiplet.label);
}
function checkMultiplicity(multiplicity, rejected = []) {
  if (multiplicity === void 0 || multiplicity.length === 0) {
    return false;
  }
  return !multiplicity.split("").find((_multiplet) => !checkMultiplet(_multiplet, rejected));
}
function translateMultiplet(multiplet) {
  var _a, _b;
  return multiplet.length === 1 ? (_a = Multiplets.find((_multiplet) => _multiplet.value === multiplet)) == null ? void 0 : _a.label : (_b = Multiplets.find((_multiplet) => _multiplet.label === multiplet)) == null ? void 0 : _b.value;
}
function hasCouplingConstant(multiplet) {
  if (multiplet.length > 1) {
    multiplet = translateMultiplet(multiplet);
  }
  return checkMultiplicity(multiplet, ["m", "s"]);
}
function getPascal(n, spin) {
  if (n === void 0 || n === 0 || spin === void 0)
    return [1];
  let mult = 2 * spin + 1;
  let previousLine = [];
  for (let j = 0; j < mult - 1; j++)
    previousLine.push(1);
  for (let i = 0; i < n - 1; i++) {
    let _line = previousLine.slice();
    for (let j = 1; j < mult; j++) {
      for (let k = 0; k < previousLine.length - 1; k++) {
        _line[k + j] += previousLine[k];
      }
      _line.push(1);
    }
    previousLine = _line.slice();
  }
  return previousLine;
}
const TREE_LEVEL_COLORS = [
  "red",
  "green",
  "blue",
  "magenta"
];
function LevelNode({
  signal,
  startY,
  levelHeight
}) {
  const {
    scaleX
  } = useScaleChecked();
  return /* @__PURE__ */ jsx$1("line", {
    x1: scaleX()(signal.delta),
    y1: startY,
    x2: scaleX()(signal.delta),
    y2: startY + levelHeight,
    stroke: TREE_LEVEL_COLORS[0]
  }, `startLevelNode_${signal.id}`);
}
function StringNode({
  signal,
  startY,
  levelHeight,
  fontSize,
  showLabels
}) {
  const {
    scaleX
  } = useScaleChecked();
  return /* @__PURE__ */ jsx$1("text", {
    textAnchor: "middle",
    x: scaleX()(signal.delta),
    y: startY + levelHeight / 2,
    fontSize,
    lengthAdjust: "spacing",
    fill: "black",
    visibility: showLabels ? "visible" : "hidden",
    children: signal.multiplicity
  }, `multiplicityString_${signal.id}`);
}
function TreeNodes({
  nodesData,
  levelHeight,
  startY,
  signalID,
  labelOptions,
  showLabels
}) {
  const {
    scaleX
  } = useScaleChecked();
  const buildTreeNodeAndEdge = react.exports.useCallback(({
    startX,
    _startX,
    ratio,
    multiplicityIndex,
    color
  }) => {
    const edgeLevel = 2 * multiplicityIndex + 2;
    const _startYEdge = startY + edgeLevel * levelHeight;
    const _startYNode = startY + (edgeLevel + 1) * levelHeight;
    return /* @__PURE__ */ jsxs$1("g", {
      children: [/* @__PURE__ */ jsx$1("text", {
        textAnchor: "middle",
        x: scaleX()(_startX) + labelOptions.distance,
        y: _startYNode + 2 * (levelHeight / 3),
        fontSize: labelOptions.fontSize,
        fill: color,
        visibility: showLabels ? "visible" : "hidden",
        children: ratio
      }), /* @__PURE__ */ jsx$1("line", {
        x1: scaleX()(startX),
        y1: _startYEdge,
        x2: scaleX()(_startX),
        y2: _startYNode,
        stroke: color
      }), /* @__PURE__ */ jsx$1("line", {
        x1: scaleX()(_startX),
        y1: _startYNode,
        x2: scaleX()(_startX),
        y2: _startYNode + levelHeight,
        stroke: color
      })]
    }, `${multiplicityIndex}_${signalID}_${startX}_${_startX}_${ratio}`);
  }, [signalID, labelOptions.distance, labelOptions.fontSize, scaleX, showLabels, startY, levelHeight]);
  return /* @__PURE__ */ jsx$1(Fragment$1, {
    children: nodesData == null ? void 0 : nodesData.map((node) => buildTreeNodeAndEdge(node))
  });
}
function createTreeNodes(signal, spectrumData) {
  function buildTreeNodesData(multiplicityIndex, jIndices, treeNodesData, startX) {
    var _a;
    if (!signal.multiplicity) {
      return null;
    }
    if (multiplicityIndex >= signal.multiplicity.length) {
      return treeNodesData;
    }
    const color = TREE_LEVEL_COLORS[multiplicityIndex % TREE_LEVEL_COLORS.length];
    const jIndex = jIndices.findIndex((_jIndex) => _jIndex === multiplicityIndex);
    const frequency = get_1(spectrumData, "info.originFrequency", 0);
    const coupling = jIndex >= 0 && frequency > 0 && ((_a = signal == null ? void 0 : signal.js) == null ? void 0 : _a[jIndex]) ? signal.js[jIndex].coupling / frequency : null;
    if (!coupling) {
      treeNodesData.push({
        startX,
        _startX: startX,
        ratio: 1,
        multiplicityIndex,
        color
      });
      buildTreeNodesData(multiplicityIndex + 1, jIndices, treeNodesData, startX);
    } else {
      const multiplicity = signal.multiplicity || "";
      const pascal = getPascal(getMultiplicityNumber(multiplicity.charAt(multiplicityIndex)), 0.5);
      let _startX = pascal.length % 2 === 0 ? startX - pascal.length / 2 * coupling + coupling / 2 : startX - (pascal.length / 2 - 0.5) * coupling;
      pascal.forEach((ratio, k) => {
        if (k > 0) {
          _startX += coupling;
        }
        treeNodesData.push({
          startX,
          _startX,
          ratio,
          multiplicityIndex,
          color
        });
        buildTreeNodesData(multiplicityIndex + 1, jIndices, treeNodesData, _startX);
      });
    }
    return treeNodesData;
  }
  return buildTreeNodesData;
}
const styles$11 = {
  cursor: "default",
  opacity: 0.6,
  strokeWidth: 1
};
function extractID(assignment) {
  var _a;
  return [assignment.id].concat(((_a = assignment.assigned) == null ? void 0 : _a.x) || []);
}
function MultiplicityTree({
  rangeFrom,
  rangeTo,
  signal,
  labelOptions = {
    distance: 10,
    fontSize: 11
  }
}) {
  const {
    scaleX,
    scaleY
  } = useScaleChecked();
  const {
    data: spectraData,
    activeSpectrum,
    toolOptions: {
      selectedTool
    },
    width
  } = useChartData();
  const assignment = useAssignment(signal.id);
  const highlight = useHighlight(extractID(assignment), {
    type: HighlightedSource.SIGNAL,
    extra: extractID(assignment)
  });
  const spectrumData = react.exports.useMemo(() => get_1(spectraData, `${activeSpectrum == null ? void 0 : activeSpectrum.index}`, null), [activeSpectrum, spectraData]);
  const [xRange, setXRange] = react.exports.useState({
    x1: signal.delta,
    x2: signal.delta
  });
  const [treeProps, setTreeProps] = react.exports.useState({
    width: 0,
    height: 0,
    levelHeight: 0
  });
  const [drawInFullRange, setDrawInFullRange] = react.exports.useState(false);
  const [showLabels, setShowLabels] = react.exports.useState(false);
  react.exports.useEffect(() => {
    var _a;
    const _drawInFullRange = !checkMultiplicity(signal.multiplicity, ["m"]);
    const _treeWidth = _drawInFullRange ? Math.abs(scaleX()(xRange.x1) - scaleX()(xRange.x2)) : Math.abs(scaleX()(xRange.x1) - scaleX()(xRange.x2)) + labelOptions.distance;
    const _treeHeight = _drawInFullRange ? _treeWidth / 3 : _treeWidth / 2;
    const length = ((_a = signal == null ? void 0 : signal.multiplicity) == null ? void 0 : _a.length) || 0;
    const _treeLevelHeight = _drawInFullRange ? _treeHeight / (length + 2) : _treeHeight / (2 * length + 2);
    setTreeProps({
      width: _treeWidth,
      height: _treeHeight,
      levelHeight: _treeLevelHeight
    });
    setDrawInFullRange(_drawInFullRange);
  }, [labelOptions.distance, scaleX, signal.multiplicity, xRange.x1, xRange.x2]);
  react.exports.useEffect(() => {
    if (treeProps.width / width >= 0.1) {
      setShowLabels(true);
    } else {
      setShowLabels(false);
    }
  }, [treeProps.width, width]);
  const startY = react.exports.useMemo(() => {
    let yMax;
    spectrumData.data.x.forEach((_x, i) => {
      if (_x >= rangeFrom && _x <= rangeTo && (!yMax || spectrumData.data.re[i] > yMax)) {
        yMax = spectrumData.data.re[i];
      }
    });
    return scaleY(spectrumData.id)(yMax) - treeProps.height - 30;
  }, [spectrumData.data.x, spectrumData.data.re, spectrumData.id, scaleY, treeProps.height, rangeFrom, rangeTo]);
  const treeNodesData = react.exports.useMemo(() => {
    if (signal.multiplicity) {
      const buildTreeNodesData = createTreeNodes(signal, spectrumData);
      const jIndices = signal.multiplicity.split("").map((_mult, i) => hasCouplingConstant(_mult) ? i : void 0).filter((_i) => _i !== void 0);
      return buildTreeNodesData(0, jIndices, [], signal.delta);
    }
    return [];
  }, [signal, spectrumData]);
  react.exports.useEffect(() => {
    if (drawInFullRange) {
      setXRange({
        x1: rangeFrom,
        x2: rangeTo
      });
    } else {
      const _xRange = {
        x1: signal.delta,
        x2: signal.delta
      };
      treeNodesData.forEach((_treeNodeData) => {
        if (_treeNodeData.startX < _xRange.x1) {
          _xRange.x1 = _treeNodeData.startX;
        }
        if (_treeNodeData.startX > _xRange.x2) {
          _xRange.x2 = _treeNodeData.startX;
        }
        if (_treeNodeData._startX < _xRange.x1) {
          _xRange.x1 = _treeNodeData._startX;
        }
        if (_treeNodeData._startX > _xRange.x2) {
          _xRange.x2 = _treeNodeData._startX;
        }
      });
      setXRange(_xRange);
    }
  }, [drawInFullRange, rangeFrom, rangeTo, signal.delta, signal.multiplicity, treeNodesData]);
  const multiplicityTree = react.exports.useMemo(() => {
    const {
      levelHeight
    } = treeProps;
    const firstLevelStartY = startY;
    let _startY = firstLevelStartY;
    const secondLevelStartY = startY + levelHeight;
    _startY = secondLevelStartY;
    _startY += levelHeight;
    if (drawInFullRange) {
      const _rangeFrom = scaleX()(rangeFrom);
      const _rangeTo = scaleX()(rangeTo);
      const pathData = `M ${_rangeFrom} ${_startY + levelHeight} ${_rangeFrom} ${_startY} ${scaleX()(signal.delta)} ${_startY} ${_rangeTo} ${_startY} ${_rangeTo} ${_startY + levelHeight}`;
      return /* @__PURE__ */ jsxs("g", {
        children: [/* @__PURE__ */ jsx(StringNode, {
          signal,
          startY: firstLevelStartY,
          levelHeight,
          fontSize: labelOptions.fontSize,
          showLabels
        }), /* @__PURE__ */ jsx(LevelNode, {
          signal,
          startY: secondLevelStartY,
          levelHeight
        }), /* @__PURE__ */ jsx("path", {
          d: pathData,
          stroke: "blue",
          fill: "none"
        })]
      });
    }
    return /* @__PURE__ */ jsxs("g", {
      children: [/* @__PURE__ */ jsx(StringNode, {
        signal,
        startY: firstLevelStartY,
        levelHeight,
        fontSize: labelOptions.fontSize,
        showLabels
      }), /* @__PURE__ */ jsx(LevelNode, {
        signal,
        startY: secondLevelStartY,
        levelHeight
      }), /* @__PURE__ */ jsx(TreeNodes, {
        nodesData: treeNodesData,
        signalID: treeNodesData,
        showLabels,
        startY,
        labelOptions,
        levelHeight
      })]
    });
  }, [treeProps, startY, drawInFullRange, signal, labelOptions, showLabels, treeNodesData, scaleX, rangeFrom, rangeTo]);
  return /* @__PURE__ */ jsx("g", {
    css: highlight.isActive || assignment.isActive ? __spreadProps(__spreadValues({}, styles$11), {
      opacity: 1,
      strokeWidth: 1.5
    }) : styles$11,
    onMouseEnter: () => {
      assignment.show("x");
      highlight.show();
    },
    onMouseLeave: () => {
      assignment.hide();
      highlight.hide();
    },
    onClick: selectedTool && selectedTool === options.editRange.id ? () => {
      return null;
    } : (e2) => {
      if (e2.shiftKey) {
        e2.stopPropagation();
        assignment.setActive("x");
      }
    },
    children: multiplicityTree
  });
}
function TempMultiplicityTreeInner({
  range: range2
}) {
  return (range2 == null ? void 0 : range2.signals) && range2.signals.length > 0 && range2.signals.map((signal) => /* @__PURE__ */ jsx$1(MultiplicityTree, {
    rangeFrom: range2.from,
    rangeTo: range2.to,
    signal
  }, signal.id));
}
const MemoizedTempMultiplicityTree = react.exports.memo(TempMultiplicityTreeInner);
function TempMultiplicityTree() {
  const {
    toolOptions: {
      data: {
        tempRange
      }
    }
  } = useChartData();
  return /* @__PURE__ */ jsx$1(MemoizedTempMultiplicityTree, {
    range: tempRange
  });
}
const stylesOnHover = css`
  pointer-events: bounding-box;
  @-moz-document url-prefix() {
    pointer-events: fill;
  }
  user-select: 'none';
  -webkit-user-select: none; /* Chrome all / Safari all */
  -moz-user-select: none; /* Firefox all */

  .delete-button {
    visibility: hidden;
  }
`;
const stylesHighlighted = css`
  pointer-events: bounding-box;

  @-moz-document url-prefix() {
    pointer-events: fill;
  }
  .range-area {
    height: 100%;
    fill: #ff6f0057;
  }
  .delete-button {
    visibility: visible;
    cursor: pointer;
  }
`;
function Range({
  rangeData,
  showMultiplicityTrees,
  selectedTool,
  startEditMode
}) {
  var _a;
  const {
    viewerRef
  } = useGlobal();
  const {
    id: id2,
    integration,
    signals
  } = rangeData;
  const assignmentData = useAssignmentData();
  const assignmentRange = useAssignment(id2);
  const highlightRange = useHighlight([assignmentRange.id].concat(((_a = assignmentRange.assigned) == null ? void 0 : _a.x) || []).concat(filterForIDsWithAssignment(assignmentData, signals.map((_signal) => _signal.id))), {
    type: HighlightedSource.RANGE,
    extra: {
      id: id2
    }
  });
  const {
    scaleX
  } = useScaleChecked();
  const dispatch = useDispatch();
  const [reduceOpacity, setReduceOpacity] = react.exports.useState(false);
  const [isBlockedByEditing, setIsBlockedByEditing] = react.exports.useState(false);
  react.exports.useEffect(() => {
    if (selectedTool && selectedTool === options.editRange.id) {
      setIsBlockedByEditing(true);
    } else {
      setIsBlockedByEditing(false);
    }
  }, [selectedTool]);
  react.exports.useEffect(() => {
    setReduceOpacity(!checkRangeKind$1(rangeData));
  }, [rangeData]);
  const handleOnStopResizing = react.exports.useCallback((position) => {
    dispatch({
      type: RESIZE_RANGE,
      data: __spreadProps(__spreadValues({}, rangeData), {
        from: scaleX().invert(position.x2),
        to: scaleX().invert(position.x1)
      })
    });
  }, [dispatch, rangeData, scaleX]);
  const mouseEnterHandler = react.exports.useCallback(() => {
    assignmentRange.show("x");
    highlightRange.show();
  }, [assignmentRange, highlightRange]);
  const mouseLeaveHandler = react.exports.useCallback(() => {
    assignmentRange.hide();
    highlightRange.hide();
  }, [assignmentRange, highlightRange]);
  const assignHandler = react.exports.useCallback((e2) => {
    if (selectedTool === options.rangesPicking.id && e2.shiftKey && !isBlockedByEditing) {
      assignmentRange.setActive("x");
    }
  }, [assignmentRange, isBlockedByEditing, selectedTool]);
  const from = scaleX()(rangeData.from);
  const to = scaleX()(rangeData.to);
  return /* @__PURE__ */ jsxs("g", {
    "data-test-id": "range",
    style: {
      outline: "none"
    },
    onMouseEnter: mouseEnterHandler,
    onMouseLeave: mouseLeaveHandler,
    onClick: assignHandler,
    children: [/* @__PURE__ */ jsx(Resizer, {
      tag: "svg",
      initialPosition: {
        x1: to,
        x2: from
      },
      onEnd: handleOnStopResizing,
      parentElement: viewerRef,
      children: ({
        x1,
        x2
      }, isActive) => /* @__PURE__ */ jsxs("g", {
        transform: `translate(0,10)`,
        css: isBlockedByEditing || highlightRange.isActive || assignmentRange.isActive || isActive ? stylesHighlighted : stylesOnHover,
        children: [/* @__PURE__ */ jsx("rect", {
          "data-no-export": "true",
          x: "0",
          width: x2 - x1,
          height: "6",
          className: "range-area",
          fill: "green",
          fillOpacity: !reduceOpacity || highlightRange.isActive || assignmentRange.isActive ? 1 : 0.4
        }), /* @__PURE__ */ jsx("text", {
          textAnchor: "middle",
          x: (x2 - x1) / 2,
          y: "20",
          fontSize: "10",
          fill: "red",
          fillOpacity: !reduceOpacity || highlightRange.isActive || assignmentRange.isActive ? 1 : 0.6,
          children: integration !== void 0 ? integration.toFixed(2) : ""
        })]
      })
    }, `${id2}_${to}_${from}`), startEditMode ? /* @__PURE__ */ jsx(TempMultiplicityTree, {}) : showMultiplicityTrees && signals && signals.length > 0 && signals.map((_signal) => /* @__PURE__ */ jsx(MultiplicityTree, {
      rangeFrom: from,
      rangeTo: to,
      signal: _signal
    }, _signal.id))]
  }, id2);
}
function RangeIntegral({
  range: range2
}) {
  const path = useIntegralPath(range2);
  return /* @__PURE__ */ jsx$1("path", {
    className: "line",
    stroke: "black",
    strokeWidth: "1",
    fill: "none",
    d: path
  });
}
function RangesInner({
  ranges,
  displayerKey,
  selectedTool,
  editRangeID,
  showMultiplicityTrees,
  showRangesIntegrals
}) {
  var _a;
  return /* @__PURE__ */ jsx$1("g", {
    clipPath: `url(#${displayerKey}clip-chart-1d)`,
    children: (_a = ranges == null ? void 0 : ranges.values) == null ? void 0 : _a.map((range2) => /* @__PURE__ */ jsxs$1(react.exports.Fragment, {
      children: [/* @__PURE__ */ jsx$1(Range, {
        rangeData: range2,
        selectedTool,
        showMultiplicityTrees,
        startEditMode: editRangeID && editRangeID === range2.id ? true : false
      }), showRangesIntegrals && /* @__PURE__ */ jsx$1(RangeIntegral, {
        range: range2
      })]
    }, range2.id))
  });
}
const MemoizedRanges = react.exports.memo(RangesInner);
const empyData = {
  ranges: {}
};
function Ranges() {
  const {
    displayerKey,
    toolOptions: {
      selectedTool,
      data: {
        tempRange,
        showMultiplicityTrees,
        showRangesIntegrals
      }
    }
  } = useChartData();
  const {
    ranges
  } = useSpectrum(empyData);
  return /* @__PURE__ */ jsx$1(MemoizedRanges, {
    ranges,
    showMultiplicityTrees,
    showRangesIntegrals,
    selectedTool,
    displayerKey,
    editRangeID: (tempRange == null ? void 0 : tempRange.id) || ""
  });
}
const styles$10 = css`
  pointer-events: bounding-box;
  user-select: 'none';
  -webkit-user-select: none; /* Chrome all / Safari all */
  -moz-user-select: none; /* Firefox all */

  .zone-area {
    height: 100%;
    fill: #b8b8b857;
    cursor: pointer;
  }
  .delete-button {
    display: none;
    cursor: pointer;
  }
  :hover .delete-button {
    display: block;
  }
`;
function BaseLineZones() {
  const {
    toolOptions
  } = useChartData();
  const {
    scaleX
  } = useScaleChecked();
  const dispatch = useDispatch();
  const deleteRangeHandler = react.exports.useCallback((id2) => {
    dispatch({
      type: DELETE_BASE_LINE_ZONE,
      id: id2
    });
  }, [dispatch]);
  const baseLineZones = react.exports.useMemo(() => {
    return toolOptions.data.baseLineZones;
  }, [toolOptions]);
  return /* @__PURE__ */ jsx(Fragment, {
    children: baseLineZones.length > 0 && /* @__PURE__ */ jsx("g", {
      children: baseLineZones.map((zone) => /* @__PURE__ */ jsxs("g", {
        transform: `translate(${scaleX()(zone.to)},0)`,
        css: styles$10,
        children: [/* @__PURE__ */ jsx(DeleteButton$1, {
          x: -20,
          y: 10,
          onDelete: () => deleteRangeHandler(zone.id)
        }), /* @__PURE__ */ jsx("rect", {
          x: "0",
          width: `${scaleX()(zone.from) - scaleX()(zone.to)}`,
          className: "zone-area"
        })]
      }, zone.id))
    })
  });
}
function Chart1D({
  mode,
  width,
  height,
  margin,
  displayerKey
}) {
  return /* @__PURE__ */ jsxs$1("svg", {
    viewBox: `0 0 ${width} ${height}`,
    width,
    height,
    id: "nmrSVG",
    children: [/* @__PURE__ */ jsx$1("defs", {
      children: /* @__PURE__ */ jsx$1("clipPath", {
        id: `${displayerKey}clip-chart-1d`,
        children: /* @__PURE__ */ jsx$1("rect", {
          width: `${width - margin.left - margin.right}`,
          height: `${height}`,
          x: `${margin.left}`,
          y: `${0}`
        })
      })
    }), /* @__PURE__ */ jsx$1(LinesSeries, {}), /* @__PURE__ */ jsx$1(IntegralsSeries, {}), /* @__PURE__ */ jsx$1(PeakAnnotations, {}), /* @__PURE__ */ jsx$1(Ranges, {}), /* @__PURE__ */ jsx$1(JGraph, {}), /* @__PURE__ */ jsx$1(MultiAnalysisRanges, {}), /* @__PURE__ */ jsx$1(BaseLineZones, {}), /* @__PURE__ */ jsx$1(ExclusionZonesAnnotations, {}), /* @__PURE__ */ jsx$1(ResurrectedDatabaseRanges, {}), /* @__PURE__ */ jsx$1("g", {
      className: "container",
      style: {
        pointerEvents: "none"
      },
      children: /* @__PURE__ */ jsx$1(XAxis, {
        showGrid: true,
        mode
      })
    }), /* @__PURE__ */ jsx$1(FloatMoleculeStructures, {})]
  });
}
const styles$$ = css`
  display: flex;
  flex-firection: row;
  align-items: center;
  pointer-events: bounding-box;
  user-select: 'none';
  -webkit-user-select: none; /* Chrome all / Safari all */
  -moz-user-select: none; /* Firefox all */
  background-color: #f7f7f7;
  height: 30px;
  padding: 6px;
  color: #8d0018;
  position: absolute;
  width: 100%;
  bottom: 0;

  div {
    margin: 0px 10px;
    display: inline-block;

    .label {
      font-size: 12px;
      color: #4d4d4d;
      font-weight: bold;
    }
    .value {
      font-weight: bold;
      font-size: 14px;
      display: inline-block;
    }
    .unit {
      font-weight: bold;
      font-size: 10px;
    }
    .xvalue {
      min-width: 50px;
    }
    .yvalue {
      min-width: 80px;
    }
  }

  .separator {
    border-left: 2px solid gray;
    margin: 0 20px;
    width: 1px;
    height: 100%;
  }
`;
function FooterBannerInner({
  margin,
  width,
  height,
  activeSpectrum,
  spectrum,
  activeTab
}) {
  var _a, _b, _c, _d;
  let position = react.exports.useContext(MouseContext);
  const {
    startX,
    endX,
    step
  } = react.exports.useContext(BrushContext);
  const {
    scaleX
  } = useScaleChecked();
  const format2 = useFormatNumberByNucleus(activeTab);
  const getYValue = react.exports.useCallback((xPosition) => {
    if (spectrum) {
      const data = get1DDataXY(spectrum);
      const xIndex = xFindClosestIndex(data.x, scaleX().invert(xPosition));
      return data.y[xIndex];
    }
    return 1;
  }, [spectrum, scaleX]);
  if (!position || position.y < margin.top || position.x < margin.left || position.x > width - margin.right || position.y > height - margin.bottom) {
    return /* @__PURE__ */ jsx("div", {
      css: styles$$
    });
  }
  return /* @__PURE__ */ jsxs("div", {
    css: styles$$,
    children: [/* @__PURE__ */ jsx(BsCursor, {}), /* @__PURE__ */ jsxs("div", {
      children: [/* @__PURE__ */ jsx("span", {
        className: "label",
        children: " \u{1D6C5}: "
      }), /* @__PURE__ */ jsx("span", {
        className: "value",
        children: format2(scaleX().invert(position.x))
      }), /* @__PURE__ */ jsx("span", {
        className: "unit",
        children: "ppm"
      }), activeSpectrum && ((_a = spectrum == null ? void 0 : spectrum.info) == null ? void 0 : _a.originFrequency) && /* @__PURE__ */ jsxs(Fragment, {
        children: [/* @__PURE__ */ jsxs("span", {
          className: "value",
          children: ["\xA0(", format2(scaleX().invert(position.x) * ((_b = spectrum == null ? void 0 : spectrum.info) == null ? void 0 : _b.originFrequency), "hz")]
        }), /* @__PURE__ */ jsx("span", {
          className: "unit",
          children: "Hz"
        }), /* @__PURE__ */ jsx("span", {
          className: "value",
          children: ") "
        })]
      })]
    }), step === "brushing" && /* @__PURE__ */ jsxs("div", {
      children: [/* @__PURE__ */ jsx("span", {
        className: "label",
        children: " \u0394ppm: "
      }), /* @__PURE__ */ jsx("span", {
        className: "value",
        children: (scaleX().invert(startX) - scaleX().invert(endX)).toPrecision(6)
      })]
    }), activeSpectrum && /* @__PURE__ */ jsxs(react.exports.Fragment, {
      children: [((_c = spectrum == null ? void 0 : spectrum.info) == null ? void 0 : _c.originFrequency) && step === "brushing" && /* @__PURE__ */ jsxs("div", {
        children: [/* @__PURE__ */ jsx("span", {
          className: "label",
          children: " \u0394Hz: "
        }), /* @__PURE__ */ jsx("span", {
          className: "value",
          children: ((scaleX().invert(startX) - scaleX().invert(endX)) * ((_d = spectrum == null ? void 0 : spectrum.info) == null ? void 0 : _d.originFrequency)).toPrecision(5)
        })]
      }), step === "brushing" && /* @__PURE__ */ jsxs("div", {
        children: [/* @__PURE__ */ jsx("span", {
          className: "label",
          children: " ratio :"
        }), /* @__PURE__ */ jsxs("span", {
          className: "value",
          children: [(getYValue(startX) / (getYValue(endX) || Number.MIN_VALUE) * 100).toFixed(2), "%"]
        })]
      })]
    }), activeSpectrum && /* @__PURE__ */ jsxs(react.exports.Fragment, {
      children: [/* @__PURE__ */ jsx("div", {
        className: "separator"
      }), /* @__PURE__ */ jsx(IoPulseSharp, {}), /* @__PURE__ */ jsxs("div", {
        children: [/* @__PURE__ */ jsx("span", {
          className: "label",
          children: "Intensity: "
        }), /* @__PURE__ */ jsx("span", {
          className: "value yvalue",
          children: format2(getYValue(position.x))
        })]
      })]
    })]
  });
}
const MemoizedFooterBanner = react.exports.memo(FooterBannerInner);
function FooterBanner() {
  const {
    margin,
    width,
    height,
    activeSpectrum,
    activeTab
  } = useChartData();
  const spectrum = useSpectrum(null);
  return /* @__PURE__ */ jsx(MemoizedFooterBanner, {
    margin,
    width,
    height,
    activeSpectrum,
    spectrum,
    activeTab
  });
}
const styles$_ = {
  container: {
    position: "absolute",
    left: "10px",
    top: "10px"
  },
  value: {
    width: "67px",
    display: "inline-block",
    margin: "0 5px",
    fontSize: "12px"
  },
  colorIndicator: {
    width: "10px",
    height: "1px",
    borderBottom: `2px solid`,
    display: "inline-block",
    marginBottom: "3px"
  },
  name: {
    fontSize: "12px"
  }
};
function YTracker({
  datum
}) {
  const {
    scaleX
  } = useScale();
  const position = react.exports.useContext(MouseContext);
  if (!scaleX || !position) {
    return null;
  }
  const xIndex = xFindClosestIndex(datum.x, scaleX().invert(position.x));
  return /* @__PURE__ */ jsx$1("span", {
    style: styles$_.value,
    children: datum.y[xIndex]
  });
}
function SpectraTracker() {
  const {
    data,
    activeTab,
    xDomains
  } = useChartData();
  const [isVisible, ToggleVisibility] = react.exports.useState(false);
  react.exports.useEffect(() => {
    function handler(flag) {
      ToggleVisibility(flag);
    }
    Emitter.on("showYSpectraTrackers", handler);
    return () => {
      Emitter.off("showYSpectraTrackers", handler);
    };
  }, []);
  const trackers = react.exports.useMemo(() => {
    return isVisible && data.map((spectrum) => spectrum.display.isVisible && xDomains[spectrum.id] && spectrum.info.nucleus === activeTab && /* @__PURE__ */ jsxs$1("div", {
      style: {
        display: "block"
      },
      children: [/* @__PURE__ */ jsx$1("span", {
        style: __spreadProps(__spreadValues({}, styles$_.colorIndicator), {
          borderColor: spectrum.display.color
        })
      }), /* @__PURE__ */ jsx$1(YTracker, {
        datum: get1DDataXY(spectrum)
      }), /* @__PURE__ */ jsx$1("span", {
        style: styles$_.value,
        children: spectrum.display.name
      })]
    }, spectrum.id), []);
  }, [activeTab, data, isVisible, xDomains]);
  if (!isVisible)
    return null;
  return /* @__PURE__ */ jsx$1("div", {
    style: styles$_.container,
    children: trackers
  });
}
const styles$Z = {
  radius: 10,
  borderColor: "#1f1f1f",
  strokeWidth: 1,
  fillOpacity: 0,
  SVGPadding: 1
};
function PeakPointer() {
  const {
    height,
    width,
    margin,
    activeSpectrum,
    data,
    mode,
    toolOptions: {
      selectedTool
    },
    verticalAlign
  } = useChartData();
  const {
    scaleX,
    scaleY
  } = useScaleChecked();
  let position = react.exports.useContext(MouseContext);
  const brushState = react.exports.useContext(BrushContext);
  const [closePeakPosition, setPosition] = react.exports.useState();
  react.exports.useEffect(() => {
    const vShift = activeSpectrum ? getVerticalShift(verticalAlign, {
      index: (activeSpectrum == null ? void 0 : activeSpectrum.index) || 1,
      align: "center"
    }) : 0;
    const getClosePeak = (xShift, mouseCoordinates) => {
      if (activeSpectrum && position && selectedTool === options.peakPicking.id) {
        const range2 = [scaleX().invert(mouseCoordinates.x - xShift), scaleX().invert(mouseCoordinates.x + xShift)].sort((a, b) => {
          return a - b;
        });
        const spectrum = data.find((d) => d.id === activeSpectrum.id);
        if (!spectrum)
          throw new Error("Unreachable");
        const datum = get1DDataXY(spectrum);
        const maxIndex = datum.x.findIndex((number) => number >= range2[1]) - 1;
        const minIndex = datum.x.findIndex((number) => number >= range2[0]);
        const yDataRange = datum.y.slice(minIndex, maxIndex);
        if (yDataRange && yDataRange.length > 0) {
          const yValue = max(yDataRange);
          const xIndex = yDataRange.findIndex((value) => value === yValue);
          const xValue = datum.x[minIndex + xIndex];
          return {
            x: scaleX()(xValue),
            y: scaleY(activeSpectrum.id)(yValue) - vShift,
            xIndex: minIndex + xIndex
          };
        }
      }
      return null;
    };
    const candidatePeakPosition = getClosePeak(10, position);
    setPosition(candidatePeakPosition);
  }, [activeSpectrum, data, mode, position, scaleX, scaleY, selectedTool, verticalAlign]);
  if (selectedTool !== options.peakPicking.id || !closePeakPosition || !activeSpectrum || brushState.step === "brushing" || !position || position.y < margin.top || position.left < margin.left || position.x > width - margin.right || position.y > height - margin.bottom) {
    return null;
  }
  return /* @__PURE__ */ jsx$1("div", {
    style: {
      cursor: "crosshair",
      transform: `translate(${closePeakPosition.x}px, ${closePeakPosition.y}px)`,
      transformOrigin: "top left",
      position: "absolute",
      top: -(styles$Z.radius + styles$Z.SVGPadding),
      left: -(styles$Z.radius + styles$Z.SVGPadding),
      pointerEvents: "none",
      overflow: "visible"
    },
    children: /* @__PURE__ */ jsxs$1("svg", {
      width: styles$Z.radius * 2 + styles$Z.SVGPadding * 2,
      height: styles$Z.radius * 2 + styles$Z.SVGPadding * 2,
      children: [/* @__PURE__ */ jsx$1("circle", {
        cx: styles$Z.radius + styles$Z.SVGPadding,
        cy: styles$Z.radius + styles$Z.SVGPadding,
        r: styles$Z.radius,
        stroke: styles$Z.borderColor,
        strokeWidth: styles$Z.strokeWidth,
        fillOpacity: styles$Z.fillOpacity
      }), /* @__PURE__ */ jsx$1("line", {
        x1: styles$Z.radius + styles$Z.SVGPadding,
        y1: styles$Z.SVGPadding,
        x2: styles$Z.radius + styles$Z.SVGPadding,
        y2: styles$Z.radius * 2 + styles$Z.SVGPadding,
        stroke: styles$Z.borderColor,
        strokeWidth: styles$Z.strokeWidth
      }), /* @__PURE__ */ jsx$1("line", {
        x1: styles$Z.SVGPadding,
        y1: styles$Z.radius + styles$Z.SVGPadding,
        x2: styles$Z.radius * 2 + styles$Z.SVGPadding,
        y2: styles$Z.radius + styles$Z.SVGPadding,
        stroke: styles$Z.borderColor,
        strokeWidth: styles$Z.strokeWidth
      })]
    })
  }, "peakPointer");
}
const styles$Y = {
  transformOrigin: "top left",
  position: "absolute",
  top: "0px",
  left: "0px",
  width: 1,
  backgroundColor: "red"
};
function VerticalIndicator() {
  const {
    height,
    toolOptions: {
      selectedTool,
      data: {
        pivot
      }
    }
  } = useChartData();
  const {
    scaleX
  } = useScaleChecked();
  if (options.phaseCorrection.id !== selectedTool)
    return null;
  return /* @__PURE__ */ jsx$1("div", {
    style: __spreadProps(__spreadValues({}, styles$Y), {
      transform: `translate(${scaleX()(pivot.value)}px, 0px)`,
      height
    })
  });
}
const style$9 = {
  cursor: "crosshair",
  transformOrigin: "bottom right",
  position: "absolute",
  top: "-18px",
  left: "-30px",
  pointerEvents: "none",
  overflow: "visible",
  userSelect: "none"
};
function XLabelPointer() {
  const {
    height,
    width,
    margin,
    data,
    activeSpectrum
  } = useChartData();
  const {
    scaleX
  } = useScaleChecked();
  const position = react.exports.useContext(MouseContext);
  const brushState = react.exports.useContext(BrushContext);
  const activeSpectrumData = react.exports.useMemo(() => {
    const spectrumData = activeSpectrum ? data.find((d) => d.id === activeSpectrum.id) : null;
    return spectrumData;
  }, [activeSpectrum, data]);
  const format2 = useFormatNumberByNucleus(activeSpectrumData == null ? void 0 : activeSpectrumData.info.nucleus);
  const getXValue = react.exports.useCallback((xVal) => {
    if (activeSpectrumData) {
      const xInvert = scaleX().invert(xVal);
      return format2(xInvert);
    }
  }, [activeSpectrumData, format2, scaleX]);
  if (!activeSpectrum || brushState.step === "brushing" || !position || position.y < margin.top || position.x < margin.left || position.x > width - margin.right || position.y > height - margin.bottom) {
    return null;
  }
  return /* @__PURE__ */ jsx$1("div", {
    style: __spreadProps(__spreadValues({}, style$9), {
      transform: `translate(${position.x}px, ${position.y}px)`
    }),
    children: /* @__PURE__ */ jsx$1("span", {
      children: getXValue(position.x)
    })
  }, "xLabelPointer");
}
function Viewer1D({
  emptyText = void 0
}) {
  const {
    current: {
      display: {
        general
      }
    }
  } = usePreferences();
  const state = useChartData();
  const {
    toolOptions: {
      selectedTool
    },
    isLoading,
    data,
    mode,
    width: widthProp,
    height: heightProp,
    margin,
    activeSpectrum,
    xDomain,
    xDomains,
    yDomain,
    yDomains,
    verticalAlign,
    displayerKey
  } = state;
  const dispatch = useDispatch();
  const modal = useModal();
  const alert2 = useAlert();
  const [scaleState, dispatchScale] = react.exports.useReducer(scaleReducer, scaleInitialState);
  react.exports.useEffect(() => {
    if (xDomain.length > 0 && yDomain.length > 0 && widthProp && heightProp) {
      dispatchScale({
        type: SET_SCALE,
        payload: {
          yDomain,
          yDomains,
          xDomain,
          xDomains,
          margin,
          height: heightProp,
          width: widthProp,
          verticalAlign,
          mode
        }
      });
    }
  }, [heightProp, margin, mode, verticalAlign, widthProp, xDomain, xDomains, yDomain, yDomains]);
  const handelBrushEnd = react.exports.useCallback((brushData) => {
    const propagateEvent = () => {
      if (!scaleState.scaleX || !scaleState.scaleY)
        return;
      const {
        startX,
        endX
      } = brushData;
      const startXPPM = scaleState.scaleX().invert(startX);
      const endXPPM = scaleState.scaleX().invert(endX);
      Emitter.emit("brushEnd", __spreadProps(__spreadValues({}, brushData), {
        range: [startXPPM, endXPPM].sort((a, b) => a - b)
      }));
    };
    if (brushData.altKey) {
      switch (selectedTool) {
        case options.rangesPicking.id: {
          if (!(general == null ? void 0 : general.disableMultipletAnalysis)) {
            modal.show(/* @__PURE__ */ jsx$1(MultipletAnalysisModal, __spreadValues({
              data,
              activeSpectrum,
              scaleX: scaleState.scaleX
            }, brushData)), {
              onClose: () => {
                modal.close();
              }
            });
          }
          break;
        }
      }
    } else if (brushData.shiftKey) {
      switch (selectedTool) {
        case options.integral.id:
          dispatch(__spreadValues({
            type: ADD_INTEGRAL
          }, brushData));
          break;
        case options.rangesPicking.id: {
          const [from, to] = getRange(state, {
            startX: brushData.startX,
            endX: brushData.endX
          });
          if (!activeSpectrum)
            break;
          const {
            data: {
              x
            }
          } = state.data[activeSpectrum.index];
          const {
            fromIndex,
            toIndex
          } = xGetFromToIndex(x, {
            from,
            to
          });
          if (toIndex - fromIndex <= MAX_LENGTH) {
            dispatch({
              type: ADD_RANGE,
              payload: __spreadValues({}, brushData)
            });
          } else {
            alert2.error(`Advanced peak picking only available for area up to ${MAX_LENGTH} points`);
          }
          break;
        }
        case options.multipleSpectraAnalysis.id:
          dispatch(__spreadValues({
            type: ANALYZE_SPECTRA
          }, brushData));
          break;
        case options.peakPicking.id:
          dispatch(__spreadValues({
            type: ADD_PEAKS
          }, brushData));
          break;
        case options.baseLineCorrection.id:
          dispatch({
            type: ADD_BASE_LINE_ZONE,
            zone: {
              from: brushData.startX,
              to: brushData.endX
            }
          });
          break;
        case options.exclusionZones.id:
          dispatch({
            type: ADD_EXCLUSION_ZONE,
            payload: {
              from: brushData.startX,
              to: brushData.endX
            }
          });
          break;
        default:
          propagateEvent();
          break;
      }
    } else {
      switch (selectedTool) {
        default:
          if (selectedTool != null) {
            dispatch(__spreadValues({
              type: BRUSH_END
            }, brushData));
          }
          break;
      }
    }
  }, [scaleState, selectedTool, general == null ? void 0 : general.disableMultipletAnalysis, modal, data, activeSpectrum, dispatch, state, alert2]);
  const handelOnDoubleClick = react.exports.useCallback(() => {
    dispatch({
      type: FULL_ZOOM_OUT,
      zoomType: ZoomType.STEP_HORIZONTAL
    });
  }, [dispatch]);
  const handleZoom2 = react.exports.useCallback((event) => {
    dispatch({
      type: SET_ZOOM,
      event,
      selectedTool
    });
  }, [dispatch, selectedTool]);
  const mouseClick = react.exports.useCallback((position) => {
    const propagateEvent = () => {
      if (!scaleState.scaleX)
        return;
      const xPPM = scaleState.scaleX().invert(position.x);
      Emitter.emit("mouseClick", __spreadProps(__spreadValues({}, position), {
        xPPM
      }));
    };
    if (position.shiftKey) {
      switch (selectedTool) {
        case options.peakPicking.id:
          dispatch({
            type: ADD_PEAK,
            mouseCoordinates: position
          });
          break;
        case options.editRange.id:
          propagateEvent();
          break;
      }
    } else {
      switch (selectedTool) {
        case options.phaseCorrection.id:
          dispatch({
            type: SET_VERTICAL_INDICATOR_X_POSITION,
            position: position.x
          });
          break;
      }
    }
  }, [dispatch, scaleState, selectedTool]);
  return /* @__PURE__ */ jsx$1(ScaleProvider, {
    value: scaleState,
    children: /* @__PURE__ */ jsx$1(ResponsiveChart, {
      children: ({
        height,
        width
      }) => /* @__PURE__ */ jsx$1(ViewerResponsiveWrapper, {
        height,
        width,
        children: /* @__PURE__ */ jsxs$1("div", {
          style: {
            height: "100%",
            position: "relative"
          },
          children: [/* @__PURE__ */ jsx$1(Spinner, {
            isLoading,
            emptyText
          }), scaleState.scaleX && scaleState.scaleY && data && data.length > 0 && /* @__PURE__ */ jsx$1(BrushTracker, {
            onBrush: handelBrushEnd,
            onDoubleClick: handelOnDoubleClick,
            onClick: mouseClick,
            onZoom: handleZoom2,
            style: {
              width: "100%",
              height: "100%",
              margin: "auto",
              position: "relative",
              overflow: "hidden"
            },
            children: /* @__PURE__ */ jsxs$1(MouseTracker, {
              style: {
                width: "100%",
                height: `100%`,
                position: "absolute"
              },
              children: [/* @__PURE__ */ jsx$1(SpectraTracker, {}), /* @__PURE__ */ jsx$1(CrossLinePointer, {}), /* @__PURE__ */ jsx$1(BrushXY, {
                brushType: BRUSH_TYPE.X
              }), /* @__PURE__ */ jsx$1(XLabelPointer, {}), /* @__PURE__ */ jsx$1(PeakPointer, {}), /* @__PURE__ */ jsx$1(VerticalIndicator, {}), /* @__PURE__ */ jsx$1(FooterBanner, {}), /* @__PURE__ */ jsx$1(Chart1D, {
                width: widthProp,
                height: heightProp,
                margin,
                mode,
                displayerKey
              })]
            })
          })]
        })
      })
    })
  });
}
const styles$X = {
  container: {
    margin: "25px"
  },
  header: {
    backgroundColor: "#ffffff",
    padding: "20px",
    borderRadius: "10px",
    fontSize: "30px",
    textAlign: "center"
  },
  title: {
    textDecoration: "underline"
  },
  body: {
    marginTop: "10px",
    whiteSpace: "pre-wrap",
    backgroundColor: "white",
    padding: "20px",
    borderRadius: "10px",
    color: "red"
  }
};
function ErrorOverlay(props) {
  return /* @__PURE__ */ jsxs$1("div", {
    style: styles$X.container,
    children: [/* @__PURE__ */ jsx$1("p", {
      style: styles$X.header,
      children: "Something went wrong."
    }), /* @__PURE__ */ jsxs$1("details", {
      style: styles$X.body,
      children: [/* @__PURE__ */ jsx$1("p", {
        style: styles$X.title,
        children: props.error.message
      }), props.error.stack]
    })]
  });
}
function ActionButtons(props) {
  const {
    onDone,
    onCancel,
    doneLabel = "Apply",
    cancelLabel = "Cancel",
    style: style2 = {}
  } = props;
  return /* @__PURE__ */ jsxs$1("div", {
    style: __spreadValues({
      margin: "0 10px",
      display: "flex"
    }, style2),
    children: [/* @__PURE__ */ jsx$1(Button.Done, {
      onClick: onDone,
      style: (style2 == null ? void 0 : style2.flexDirection) === "row-reverse" ? {
        marginLeft: "10px"
      } : {},
      children: doneLabel
    }), /* @__PURE__ */ jsx$1(Button.Danger, {
      fill: "outline",
      onClick: onCancel,
      style: !style2.flexDirection || style2.flexDirection === "row" ? {
        marginLeft: "10px"
      } : {},
      children: cancelLabel
    })]
  });
}
const CheckBox = react.exports.forwardRef((props, ref) => {
  const {
    checked: checkProps = false,
    disabled = false,
    name: name2 = "",
    onChange = () => null,
    style: style2 = {}
  } = props;
  const [checked, setCheck] = react.exports.useState(checkProps);
  const handleCheck = react.exports.useCallback((e2) => {
    setCheck(!checked);
    onChange(e2);
  }, [checked, onChange]);
  return /* @__PURE__ */ jsx$1("input", {
    ref,
    type: "checkbox",
    name: name2,
    id: name2,
    onChange: handleCheck,
    defaultChecked: checkProps,
    disabled,
    style: style2
  });
});
function FormikCheckBox(props) {
  const _a = props, {
    label,
    name: name2,
    onChange = () => null,
    className = "checkbox",
    reverse = false,
    style: style2 = {
      container: {},
      label: {},
      checkbox: {}
    }
  } = _a, resProps = __objRest(_a, [
    "label",
    "name",
    "onChange",
    "className",
    "reverse",
    "style"
  ]);
  const {
    values,
    setFieldValue
  } = useFormikContext();
  const value = reverse ? !get_1(values, name2) : get_1(values, name2);
  const changeHandler = react.exports.useCallback((e2) => {
    e2.persist();
    onChange(e2);
    setFieldValue(name2, reverse ? value : !value);
  }, [name2, onChange, reverse, setFieldValue, value]);
  return /* @__PURE__ */ jsxs$1("div", {
    className: `${className} check-${value}`,
    style: style2.container ? style2.container : {},
    children: [label && /* @__PURE__ */ jsx$1("label", {
      htmlFor: name2,
      className: "checkbox-label",
      style: style2.label ? style2.label : {},
      children: label
    }), /* @__PURE__ */ jsx$1(CheckBox, __spreadProps(__spreadValues({}, resProps), {
      name: name2,
      checked: value,
      onChange: changeHandler,
      style: style2.checkbox ? style2.checkbox : {}
    }))]
  });
}
const FormikForm = react.exports.forwardRef((props, ref) => {
  const {
    onSubmit = () => null,
    initialValues = {},
    validationSchema: validationSchema2 = null
  } = props;
  return /* @__PURE__ */ jsx$1(Formik, {
    innerRef: ref,
    initialValues,
    onSubmit,
    validationSchema: validationSchema2,
    children: /* @__PURE__ */ jsx$1(Fragment$1, {
      children: props.children
    })
  });
});
function useCombinedRefs(refs) {
  const targetRef = react.exports.useRef();
  react.exports.useEffect(() => {
    refs.forEach((ref) => {
      if (!ref)
        return;
      if (typeof ref === "function") {
        ref(targetRef.current);
      } else {
        ref.current = targetRef.current;
      }
    });
  }, [refs]);
  return targetRef;
}
const styles$W = {
  label: {
    lineHeight: 2,
    userSelect: "none"
  },
  inputWrapper: {
    height: "100%",
    width: "100px",
    borderRadius: "5px",
    borderWidth: "0.55px",
    borderColor: "#c7c7c7",
    borderStyle: "solid",
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    overflow: "hidden"
  },
  input: {
    outline: "none",
    flex: 1,
    height: "100%",
    textAlign: "center",
    width: "100%"
  },
  clearButton: {
    height: "calc(100% - 4px)",
    borderRadius: "50%",
    backgroundColor: "gray",
    color: "white",
    aspectRatio: "1",
    fontSize: "60%",
    padding: 0
  }
};
const Input = react.exports.forwardRef((_g, ref) => {
  var _h = _g, {
    value = "",
    name: name2,
    style: style2 = {
      input: {},
      inputWrapper: {}
    },
    onChange = () => null,
    debounceTime = 0,
    onKeyDown = () => null,
    checkValue = () => true,
    type = "text",
    enableAutoSelect = false,
    className,
    format: format2 = () => (value2) => value2,
    onBlur = () => null,
    onFocus = () => null,
    renderIcon = null,
    canClear = false,
    onClear
  } = _h, props = __objRest(_h, [
    "value",
    "name",
    "style",
    "onChange",
    "debounceTime",
    "onKeyDown",
    "checkValue",
    "type",
    "enableAutoSelect",
    "className",
    "format",
    "onBlur",
    "onFocus",
    "renderIcon",
    "canClear",
    "onClear"
  ]);
  const [val, setVal] = react.exports.useState(value);
  const localRef = react.exports.useRef();
  const combinedRef = useCombinedRefs([ref, localRef]);
  const debounceOnChange = react.exports.useRef(debounce_1((value2) => {
    onChange(value2);
  }, debounceTime)).current;
  react.exports.useEffect(() => {
    setVal(value);
  }, [value]);
  react.exports.useEffect(() => {
    var _a;
    if (enableAutoSelect) {
      (_a = combinedRef == null ? void 0 : combinedRef.current) == null ? void 0 : _a.select();
    }
  }, [enableAutoSelect, combinedRef]);
  const getValue2 = react.exports.useCallback((value2) => {
    const formatValue = format2();
    return formatValue(type === "number" ? String(value2).trim() === "-" ? Number(0) : Number(value2) : value2);
  }, [format2, type]);
  const onChangeHandler = react.exports.useCallback((e2) => {
    e2.persist();
    e2.stopPropagation();
    e2.preventDefault();
    function check(value2) {
      if (type === "number") {
        const pattern = /^(?:-?[0-9]*|[0-9]\d*)(?:\.\d{0,20})?$/;
        if (value2.trim() === "" || pattern.test(value2)) {
          return true;
        }
        return false;
      }
      return true;
    }
    const _value = e2.target.value;
    if (check(_value) && checkValue(_value)) {
      const formatValue = format2();
      setVal(formatValue(_value));
      const val2 = __spreadProps(__spreadValues({}, e2), {
        target: {
          name: e2.target.name,
          value: getValue2(_value)
        }
      });
      if (debounceTime) {
        debounceOnChange(val2);
      } else {
        onChange(val2);
      }
    }
  }, [checkValue, debounceOnChange, debounceTime, format2, getValue2, onChange, type]);
  const handleKeyDown = react.exports.useCallback((event) => {
    event.persist();
    onKeyDown(__spreadProps(__spreadValues({}, event), {
      target: {
        name: event.target.name,
        value: getValue2(val)
      }
    }));
  }, [getValue2, onKeyDown, val]);
  const preventPropagate = react.exports.useCallback((event) => {
    event.stopPropagation();
  }, []);
  const clearHandler = react.exports.useCallback(() => {
    setVal("");
    onClear == null ? void 0 : onClear();
  }, [onClear]);
  return /* @__PURE__ */ jsxs$1("div", {
    style: __spreadValues(__spreadValues({}, styles$W.inputWrapper), (style2 == null ? void 0 : style2.inputWrapper) ? style2.inputWrapper : {}),
    className: `input ${className || ""}`,
    children: [renderIcon == null ? void 0 : renderIcon(), /* @__PURE__ */ jsx$1("input", __spreadProps(__spreadValues({}, props), {
      ref: combinedRef,
      name: name2,
      style: __spreadValues(__spreadValues({}, styles$W.input), (style2 == null ? void 0 : style2.input) ? style2.input : {}),
      "data-test-id": name2 ? `input-${name2}` : "",
      type: "text",
      value: val,
      onChange: onChangeHandler,
      onKeyDown: handleKeyDown,
      onKeyPress: preventPropagate,
      onDoubleClick: (e2) => e2.stopPropagation(),
      onFocus,
      onBlur
    })), canClear && val && /* @__PURE__ */ jsx$1("button", {
      type: "button",
      style: styles$W.clearButton,
      onClick: clearHandler,
      children: /* @__PURE__ */ jsx$1("span", {
        style: {
          display: "block",
          margin: "0 auto"
        },
        children: "\u2715"
      })
    })]
  });
});
function FormikInput(props) {
  const _a = props, {
    name: name2,
    style: style2 = {
      label: {},
      input: {}
    },
    onChange = () => null,
    checkValue = () => true,
    type = "text",
    className = "",
    value = null,
    format: format2 = () => (value2) => value2,
    checkErrorAfterInputTouched = true
  } = _a, resProps = __objRest(_a, [
    "name",
    "style",
    "onChange",
    "checkValue",
    "type",
    "className",
    "value",
    "format",
    "checkErrorAfterInputTouched"
  ]);
  const {
    values,
    handleChange,
    setFieldValue,
    errors,
    touched
  } = useFormikContext();
  const changeHandler = react.exports.useCallback((e2) => {
    onChange(e2);
    handleChange(e2);
  }, [handleChange, onChange]);
  react.exports.useEffect(() => {
    if (value) {
      setFieldValue(name2, value);
    }
  }, [name2, setFieldValue, value]);
  const isInvalid = react.exports.useMemo(() => {
    if (checkErrorAfterInputTouched) {
      return get_1(errors, name2) && get_1(touched, name2);
    }
    return get_1(errors, name2);
  }, [checkErrorAfterInputTouched, errors, name2, touched]);
  return /* @__PURE__ */ jsx$1(Input, __spreadValues({
    name: name2,
    value: value ? value : get_1(values, name2),
    onChange: changeHandler,
    type,
    style: __spreadProps(__spreadValues({}, style2), {
      inputWrapper: __spreadValues(__spreadValues({}, style2.input), isInvalid && {
        borderColor: "red",
        outline: "none"
      })
    }),
    checkValue,
    className,
    format: format2
  }, resProps));
}
const ModalStyles = css`
  overflow: auto;
  height: 100%;
  display: flex;
  flex-direction: column;

  .header {
    text-align: center;
    padding: 10px 0 10px 0px;
    margin: 0px;
    color: #005d9e;
    place-items: normal;
    text-transform: none;
    background-color: #fcfcfc;
  }

  .tab-content {
    width: 100%;
  }
  .row {
    display: flex;
  }

  .inner-content {
    padding: 15px 30px;
    width: 100%;
    overflow: auto;
  }

  .footer-container {
    display: flex;
    flex-direction: row;
    align-items: end;
    justify-content: end;

    background: rgb(242, 242, 242);
    background: -moz-linear-gradient(
      0deg,
      rgba(242, 242, 242, 1) 0%,
      rgba(245, 245, 245, 1) 37%,
      rgba(255, 255, 255, 1) 90%
    );
    background: -webkit-linear-gradient(
      0deg,
      rgba(242, 242, 242, 1) 0%,
      rgba(245, 245, 245, 1) 37%,
      rgba(255, 255, 255, 1) 90%
    );
    background: linear-gradient(
      0deg,
      rgba(242, 242, 242, 1) 0%,
      rgba(245, 245, 245, 1) 37%,
      rgba(255, 255, 255, 1) 90%
    );
    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr="#f2f2f2",endColorstr="#ffffff",GradientType=1);
    padding: 6px 15px;
    height: 55px;
  }

  .section-header {
    font-size: 13px;
    color: #2ca8ff;
    margin-bottom: 10px;
    border-bottom: 0.55px solid #f9f9f9;
    padding: 6px 2px;
  }

  .custom-label {
    font-size: 12px;
    font-weight: bold;
    margin-right: 10px;
    width: 120px;
  }
  .margin-10 {
    margin: 10px 0;
  }
  .padding-h-10 {
    margin: 10px;
  }

  .input {
    font-size: 14px;
    border-radius: 5px;
    border: 1px solid #cccccc;
    padding: 5px;
    width: 100px;
    margin-right: 10px;
    height: initial !important;
  }

  .close-bt {
    border: none;
    color: red;
    background-color: transparent;
    outline: none;
    position: absolute;
    right: 10px;
    top: 2px;
    width: 30px;
    height: 30px;
  }
`;
const styles$V = css`
  .row {
    align-items: center;
  }

  .inner-content {
    flex: 1;
  }

  .custom-label {
    width: 80px;
  }

  .name {
    width: 100% !important;
    text-align: left !important;
  }

  .data-export-group {
    label:first-child {
      margin-right: 10px;
    }
    label {
      display: inline-block;
    }
    input[type='radio'] {
      margin-right: 5px;
    }
  }
`;
const INITIAL_VALUE$1 = {
  name: "",
  compressed: false,
  pretty: false,
  dataExportOption: DataExportOptions.ROW_DATA
};
function SaveAsModal({
  onClose,
  onSave,
  name: name2
}) {
  const refForm = react.exports.useRef();
  const handleSave = react.exports.useCallback(() => {
    refForm.current.submitForm();
  }, []);
  const submitHandler = react.exports.useCallback((values) => {
    onSave(values);
    onClose == null ? void 0 : onClose();
  }, [onClose, onSave]);
  return /* @__PURE__ */ jsxs("div", {
    css: [ModalStyles, styles$V],
    children: [/* @__PURE__ */ jsxs("div", {
      className: "header handle",
      children: [/* @__PURE__ */ jsx("span", {
        children: "Save as ... "
      }), /* @__PURE__ */ jsx(CloseButton$1, {
        onClick: onClose,
        className: "close-bt"
      })]
    }), /* @__PURE__ */ jsx("div", {
      className: "inner-content",
      children: /* @__PURE__ */ jsxs(FormikForm, {
        ref: refForm,
        initialValues: __spreadProps(__spreadValues({}, INITIAL_VALUE$1), {
          name: name2
        }),
        onSubmit: submitHandler,
        children: [/* @__PURE__ */ jsxs("div", {
          className: "row margin-10",
          children: [/* @__PURE__ */ jsx("span", {
            className: "custom-label",
            children: "Name"
          }), /* @__PURE__ */ jsx(FormikInput, {
            name: "name",
            className: "name",
            style: {
              inputWrapper: {
                width: "100%"
              }
            }
          })]
        }), /* @__PURE__ */ jsxs("div", {
          className: "row margin-10",
          children: [/* @__PURE__ */ jsx("span", {
            className: "custom-label",
            children: "Compressed"
          }), /* @__PURE__ */ jsx(FormikCheckBox, {
            name: "compressed"
          })]
        }), /* @__PURE__ */ jsxs("div", {
          className: "row margin-10",
          children: [/* @__PURE__ */ jsx("span", {
            className: "custom-label",
            children: "Pretty Format"
          }), /* @__PURE__ */ jsx(FormikCheckBox, {
            name: "pretty"
          })]
        }), /* @__PURE__ */ jsxs("div", {
          className: "row margin-10",
          children: [/* @__PURE__ */ jsx("span", {
            className: "custom-label",
            children: " Include "
          }), /* @__PURE__ */ jsxs("div", {
            className: "data-export-group",
            children: [/* @__PURE__ */ jsxs("label", {
              children: [/* @__PURE__ */ jsx(Field, {
                type: "radio",
                name: "dataExportOption",
                value: DataExportOptions.ROW_DATA
              }), "Raw Data"]
            }), /* @__PURE__ */ jsxs("label", {
              children: [/* @__PURE__ */ jsx(Field, {
                type: "radio",
                name: "dataExportOption",
                value: DataExportOptions.DATA_SOURCE
              }), "Data Source"]
            })]
          })]
        })]
      })
    }), /* @__PURE__ */ jsx("div", {
      className: "footer-container",
      children: /* @__PURE__ */ jsx(ActionButtons, {
        style: {
          flexDirection: "row-reverse",
          margin: 0
        },
        onDone: handleSave,
        doneLabel: "Save",
        onCancel: () => onClose == null ? void 0 : onClose()
      })
    })]
  });
}
function copyFormattedHtml(html) {
  var _a, _b;
  let container = document.createElement("div");
  container.innerHTML = html;
  container.style.position = "fixed";
  container.style.pointerEvents = "none";
  container.style.opacity = "0";
  let activeSheets = Array.prototype.slice.call(document.styleSheets).filter((sheet) => {
    return !sheet.disabled;
  });
  document.body.appendChild(container);
  (_a = window.getSelection()) == null ? void 0 : _a.removeAllRanges();
  let range2 = document.createRange();
  range2.selectNode(container);
  (_b = window.getSelection()) == null ? void 0 : _b.addRange(range2);
  document.execCommand("copy");
  for (const active of activeSheets) {
    active.disabled = true;
  }
  document.execCommand("copy");
  for (const active of activeSheets) {
    active.disabled = false;
  }
  document.body.removeChild(container);
}
async function copyHTMLToClipboard(data) {
  try {
    copyFormattedHtml(data);
    return true;
  } catch (err) {
    return false;
  }
}
async function copyTextToClipboard(data) {
  try {
    await navigator.clipboard.writeText(data);
    return true;
  } catch (err) {
    return false;
  }
}
async function exportAsJSON(data, fileName = "experiment", spaceIndent = 0, isCompressed = false) {
  const fileData = JSON.stringify(data, (key, value) => ArrayBuffer.isView(value) ? Array.from(value) : value, spaceIndent);
  if (!isCompressed) {
    const blob = new Blob([fileData], { type: "text/plain" });
    FileSaver_min.exports.saveAs(blob, `${fileName}.nmrium`);
  } else {
    try {
      const zip = new Zip();
      zip.file(`${fileName}.nmrium`, fileData);
      const blob = await zip.generateAsync({
        type: "blob",
        compression: "DEFLATE",
        compressionOptions: {
          level: 9
        }
      });
      FileSaver_min.exports.saveAs(blob, `${fileName}.nmrium`);
    } catch (e2) {
      console.log(e2);
    }
  }
}
function exportAsMatrix(data, options2, fileName = "experiment") {
  const columnsLables = ["name", "experiment"];
  for (const value of data[0].data.x) {
    columnsLables.push(value);
  }
  let matrix = `${columnsLables.join("	")}
`;
  for (const spectrum of data) {
    const {
      data: { re },
      info: { experiment },
      display: { name: name2 }
    } = spectrum;
    const cellsValues = [name2, experiment];
    for (const value of re) {
      cellsValues.push(value);
    }
    matrix += `${cellsValues.join("	")}
`;
  }
  const blob = new Blob([matrix], { type: "text/tab-separated-values" });
  FileSaver_min.exports.saveAs(blob, `${fileName}.tsv`);
}
function exportAsNMRE(data, fileName = "experiment") {
  data.generateAsync({ type: "blob" }).then((content) => {
    FileSaver_min.exports.saveAs(content, `${fileName}.nmredata`);
  });
}
function exportAsSVG(rootRef, elementID, fileName = "experiment") {
  const { blob } = getBlob(rootRef, elementID);
  FileSaver_min.exports.saveAs(blob, `${fileName}.svg`);
}
function exportAsPng(rootRef, elementID, fileName = "experiment") {
  const { blob, width, height } = getBlob(rootRef, elementID);
  try {
    let canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    let context = canvas.getContext("2d");
    if (context) {
      context.fillStyle = "white";
      context.fillRect(0, 0, canvas.width, canvas.height);
    }
    let img = new Image();
    let url = URL.createObjectURL(blob);
    img.onload = async () => {
      context == null ? void 0 : context.drawImage(img, 0, 0);
      let png = canvas.toDataURL("image/png", 1);
      FileSaver_min.exports.saveAs(png, `${fileName}.png`);
      URL.revokeObjectURL(png);
    };
    img.src = url;
  } catch (e2) {
    console.log(e2);
  }
}
function copyDataURLCliboard(image) {
  var _a;
  const img = document.createElement("img");
  img.src = image;
  img.style.position = "fixed";
  img.style.pointerEvents = "none";
  img.style.opacity = "0";
  document.body.appendChild(img);
  const range2 = document.createRange();
  range2.selectNode(img);
  (_a = window.getSelection()) == null ? void 0 : _a.addRange(range2);
  document.execCommand("Copy");
  document.body.removeChild(img);
}
function copyBlobToCliboard(canvas) {
  canvas.toBlob((b) => {
    const clip = new ClipboardItem({
      [b.type]: b
    });
    navigator.clipboard.write([clip]).then(() => {
      console.log("experiment copied.");
    }, (err) => {
      console.log(err);
    });
  });
}
function copyPNGToClipboard(rootRef, elementID) {
  const { blob, width, height } = getBlob(rootRef, elementID);
  try {
    let canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    let context = canvas.getContext("2d");
    if (context) {
      context.fillStyle = "white";
      context.fillRect(0, 0, canvas.width, canvas.height);
    }
    let img = new Image();
    const url = URL.createObjectURL(blob);
    img.onload = async () => {
      context == null ? void 0 : context.drawImage(img, 0, 0);
      const png = canvas.toDataURL("image/png", 1);
      if (navigator.clipboard.write) {
        copyBlobToCliboard(canvas);
      } else {
        copyDataURLCliboard(png);
      }
      URL.revokeObjectURL(png);
    };
    img.src = url;
  } catch (e2) {
    if (e2 instanceof ReferenceError) {
      alert("Your browser does not support this feature, please use Google Chrome");
    }
    console.log(e2);
  }
}
function getBlob(rootRef, elementID) {
  var _a;
  let _svg = (_a = rootRef.getRootNode().getElementById(elementID)) == null ? void 0 : _a.cloneNode(true);
  const width = _svg == null ? void 0 : _svg.getAttribute("width").replace("px", "");
  const height = _svg == null ? void 0 : _svg.getAttribute("height").replace("px", "");
  _svg.querySelectorAll('[data-no-export="true"]').forEach((element) => element.remove());
  _svg.querySelectorAll('[data-replace-float-structure="true"]').forEach((element) => {
    element.replaceWith(element.childNodes[0].childNodes[0]);
    return element;
  });
  const head = `<svg class="nmr-svg"  viewBox='0 0 ${width} ${height}' width="${width}"  height="${height}"  version="1.1" xmlns="http://www.w3.org/2000/svg">`;
  const style2 = `<style>.grid line,.grid path{stroke:none;} .peaks-text{fill:#730000} .x path{stroke-width:1px} .x text{
    font-size: 12px;
    font-weight: bold;
  } 
 
  .nmr-svg,.contours{
    background-color:white;
    fill:white;
  }
  

  
  </style>`;
  const svg = `${head + style2 + _svg.innerHTML}</svg>`;
  const blob = new Blob([svg], { type: "image/svg+xml" });
  return { blob, width, height };
}
const jszip = new Zip();
async function addSource(nmrRecord, options2 = {}) {
  const { spectrum, source } = options2;
  const { file = {}, jcampURL } = source;
  let tag = "";
  const dimension = `${spectrum.info.dimension}d`;
  switch (file.extension) {
    case "jdx":
    case "dx":
      tag += `
Jcamp_Location=file:jcamp/${dimension}/${spectrum.display.name}\\`;
      nmrRecord.file(`jcamp/${dimension}/${spectrum.display.name}`, file.binary);
      break;
    case "zip":
      if (!file.binary)
        return;
      void jszip.loadAsync(file.binary).then(async (zip) => {
        var _a;
        for (const file2 in zip.files) {
          if (file2.endsWith("/"))
            continue;
          nmrRecord.file(`Bruker/${file2}`, await ((_a = zip.file(file2)) == null ? void 0 : _a.async("arraybuffer")));
        }
        tag += `
Spectrum_Location=file:Bruker/${getPathFromZip(zip)}\\`;
      });
      break;
    default:
      if (!jcampURL)
        break;
      void await fetch(jcampURL).then(async (jcamp) => {
        if (!jcamp)
          return;
        let name2 = jcampURL.split("/").slice(-1);
        const path = `jcamp/${dimension}/${name2}`;
        tag += `
Jcamp_Location=file:${path}\\`;
        nmrRecord.file(path, await jcamp.arrayBuffer());
      });
  }
  return tag;
}
function getPathFromZip(zip) {
  let files = zip.filter((relativePath) => {
    if (relativePath.match("__MACOSX"))
      return false;
    if (relativePath.endsWith("fid") || relativePath.endsWith("1r") || relativePath.endsWith("ser") || relativePath.endsWith("2rr")) {
      return true;
    }
    return false;
  });
  const index2 = files.findIndex((file) => file.name.endsWith("1r") || file.name.endsWith("2rr"));
  return index2 > -1 ? files[index2].name : files[0].name;
}
function getToFix(nucleusArray) {
  if (!Array.isArray(nucleusArray))
    nucleusArray = [nucleusArray];
  let toFix = [];
  for (let nucleus of nucleusArray) {
    toFix.push(chooseDecimal(nucleus));
  }
  return toFix;
}
function chooseDecimal(nucleus) {
  switch (nucleus.toUpperCase()) {
    case "1H":
      return 2;
    case "13C":
      return 1;
    default:
      return 1;
  }
}
async function get1DSignals(data, nmrRecord, options2 = { labels: { byDiaID: [] } }) {
  let { prefix = "", labels } = options2;
  let str = "";
  let nucleusArray = [];
  for (let spectrum of data) {
    const { info } = spectrum;
    if (info.isFid || info.dimension > 1)
      continue;
    let partTag = "";
    let ranges = spectrum.ranges.values || [];
    let nucleus = spectrum.info.nucleus;
    let counter = 1;
    let subfix = "";
    nucleusArray.forEach((e2) => {
      if (e2 === nucleus)
        counter++;
    });
    nucleusArray.push(nucleus);
    if (counter > 1)
      subfix = `#${counter}`;
    partTag += `${prefix}1D_${nucleus.toUpperCase()}${subfix}>`;
    if (spectrum.info.baseFrequency) {
      partTag += `
Larmor=${Number(spectrum.info.baseFrequency).toFixed(2)}\\`;
    }
    const { source = {} } = spectrum;
    partTag += await addSource(nmrRecord, {
      spectrum,
      source
    });
    let toFix = getToFix(nucleus)[0];
    for (let range2 of ranges) {
      let signals = range2.signals;
      for (let signal of signals) {
        let { multiplicity } = signal;
        if ((!multiplicity || multiplicity === "m") && nucleus === "1H") {
          partTag += `
${Number(range2.from).toFixed(toFix)}-${Number(range2.to).toFixed(toFix)}`;
        } else if (signal.delta) {
          partTag += `
${Number(signal.delta).toFixed(toFix)}`;
        } else {
          continue;
        }
        let signalLabel = "";
        if (signal.diaIDs && signal.diaIDs.length > 0) {
          signal.diaIDs.forEach((diaID, i, arr) => {
            let separator = ", ";
            if (i === arr.length - 1)
              separator = "";
            let label = labels.byDiaID[diaID].label || diaID;
            signalLabel += `${label}${separator}`;
          });
          partTag += `, L=${signalLabel}`;
        }
        if (nucleus === "1H") {
          if (signal.multiplicity)
            partTag += `, S=${signal.multiplicity}`;
          let jCoupling = signal.js;
          if (Array.isArray(jCoupling) && jCoupling.length) {
            let separator = ", J=";
            for (const jCouplingElement of jCoupling) {
              partTag += `${separator}${Number(jCouplingElement.coupling).toFixed(3)}`;
              if (jCouplingElement.diaIDs) {
                let { diaIDs } = jCouplingElement;
                if (!Array.isArray(diaIDs))
                  diaIDs = [diaIDs];
                if (!diaIDs.length)
                  continue;
                let jCouple = labels.byDiaID[diaIDs[0]].label || String(diaIDs[0]);
                partTag += `(${jCouple})`;
              }
              separator = ", ";
            }
          }
          if (range2.integration) {
            partTag += `, E=${Number(range2.integration).toFixed(toFix)}`;
          } else if (range2.nbAtoms) {
            partTag += `, E=${range2.nbAtoms.toFixed(toFix)}`;
          } else if (range2.signals[0].nbAtoms !== void 0) {
            partTag += `, E=${range2.signals[0].nbAtoms}`;
          }
        }
      }
      if (signals.length)
        partTag += "\\";
    }
    partTag += "\n";
    if (/\n/.exec(partTag))
      str += partTag;
  }
  return str;
}
function getCouplingObserved(experiment) {
  switch (experiment.toLowerCase()) {
    case "hsqc":
    case "cosy":
      return "1J";
    case "hmbc":
      return "NJ";
    default:
      return "NJ";
  }
}
const isArray = Array.isArray;
async function get2DSignals(data, nmrRecord, options2 = { labels: {} }) {
  const { byDiaID } = options2.labels;
  let str = "";
  const prefix = `
> <NMREDATA_2D_`;
  for (let spectrum of data) {
    if (spectrum.info.dimension < 2)
      continue;
    let partTag = "";
    const { info, source } = spectrum;
    let { nucleus, experiment, pulseSequence } = info;
    let couplingObserved = getCouplingObserved(experiment);
    if (nucleus) {
      partTag += `${prefix}${nucleus[1]}_${couplingObserved}_${nucleus[0]}>`;
    }
    let toFix = getToFix(nucleus);
    partTag += await addSource(nmrRecord, {
      spectrum,
      source
    });
    if (experiment)
      partTag += `
CorType=${experiment} \\`;
    if (pulseSequence)
      partTag += `
PulseProgram=${pulseSequence} \\`;
    if (spectrum.info.baseFrequency) {
      partTag += `
Larmor=${Number(spectrum.info.baseFrequency[0]).toFixed(2)}\\`;
    }
    let zones = spectrum.zones.values || [];
    for (let zone of zones) {
      let signals = zone.signals;
      for (let signal of signals) {
        let { x, y, peaks } = signal;
        let xLabel = getAssignment(x, byDiaID, toFix[0]);
        let yLabel = getAssignment(y, byDiaID, toFix[1]);
        let intensity = Math.max(...peaks.map((e2) => e2.z));
        partTag += `
${xLabel}/${yLabel}, I=${intensity.toFixed(2)}\\`;
      }
    }
    str += partTag;
  }
  return str.length > 0 ? `${str}
` : "";
}
function getAssignment(axis, labels, toFix) {
  let { diaIDs, delta } = axis;
  if (diaIDs) {
    if (!isArray(diaIDs))
      diaIDs = [diaIDs];
    if (diaIDs.length < 1)
      return Number(delta).toFixed(toFix);
    let label = diaIDs.map((diaID) => labels[diaID].label).join(",");
    return diaIDs.length > 1 ? `(${label})` : label;
  }
  return Number(delta).toFixed(toFix);
}
function flat2DSignals(signals) {
  let flattedSignal = [];
  for (const { x, y } of signals) {
    flattedSignal.push(x, y);
  }
  return flattedSignal;
}
function getLabels(data, options2 = { groupedDiaIDs: [] }) {
  const { groupedDiaIDs, molecule } = options2;
  let connections = getShortestPaths(molecule, { toLabel: "H", maxLength: 1 });
  let byDiaID = {};
  let byAssignNumber = {};
  for (let spectrum of data) {
    let { dimension, nucleus } = spectrum.info;
    let toFix = getToFix(nucleus);
    let [roiKey, flatSignals] = dimension > 1 ? ["zones", flat2DSignals] : ["ranges", (s) => s || []];
    let rois = spectrum[roiKey].values || [];
    for (let roi of rois) {
      let signals = flatSignals(roi.signals);
      for (let i = 0; i < signals.length; i++) {
        let diaIDs = signals[i].diaIDs || [];
        for (let diaID of diaIDs) {
          let delta = Number(signals[i].delta).toFixed(toFix[i % dimension]);
          let groupedOclID = groupedDiaIDs.find((dia) => {
            if (dia.oclID === diaID)
              return true;
            return false;
          });
          let labelOptions = {
            atom: groupedOclID.atoms[0],
            molecule,
            connections,
            atomLabel: groupedOclID.atomLabel
          };
          byDiaID[diaID] = {
            atoms: groupedOclID.atoms.map((e2) => e2 + 1),
            shift: delta,
            label: createLabel(labelOptions)
          };
          for (let atom of groupedOclID.atoms) {
            labelOptions.atom = atom;
            byAssignNumber[atom] = {
              shift: delta,
              diaID,
              label: createLabel(labelOptions)
            };
          }
        }
      }
    }
  }
  return { byAssignNumber, byDiaID };
}
function createLabel(options2) {
  const { atom, molecule, atomLabel, connections } = options2;
  let label = "";
  if (atomLabel !== "C") {
    let connectedTo = connections[atom];
    let path = connectedTo.find((e2) => e2 && e2.length > 1);
    let pLabel = `${atomLabel}${path[0] + 1}`;
    let hLabel = `${molecule.getAtomLabel(path[1])}${path[1] + 1}`;
    label = `${pLabel}${hLabel}`;
  } else {
    label = `${atomLabel}${atom + 1}`;
  }
  return label;
}
const tags = {
  solvent: "SOLVENT",
  temperature: "TEMPERATURE",
  assignment: "ASSIGNMENT",
  j: "J",
  signals: "SIGNALS",
  id: "ID"
};
async function nmriumToNmredata(state, options2 = {}) {
  const {
    data,
    molecules
  } = state || {
    data: [],
    molecules: []
  };
  let nmrRecord = new Zip();
  for (const molecule of molecules) {
    await addNMReDATA(data, nmrRecord, __spreadProps(__spreadValues({}, options2), {
      molecule
    }));
  }
  if (!molecules.length)
    await addNMReDATA(data, nmrRecord, options2);
  return nmrRecord;
}
async function addNMReDATA(data, nmrRecord, options2 = {}) {
  let {
    id: id2,
    prefix = "\n> <NMREDATA_",
    filename = "nmredata",
    molecule
  } = options2;
  let sdfResult = "";
  let groupedDiaIDs;
  if (molecule) {
    molecule = full.Molecule.fromMolfile(molecule.molfile);
    sdfResult += molecule.toMolfile();
    molecule.addImplicitHydrogens();
    groupedDiaIDs = getGroupedDiastereotopicAtomIDs(molecule);
  }
  let labels = molecule ? getLabels(data, { groupedDiaIDs, molecule }) : { byDiaID: void 0, byAssignNumber: void 0 };
  sdfResult += `${prefix}VERSION>
1.1\\
`;
  sdfResult += putTag(data, "temperature", { prefix });
  sdfResult += putTag(data, "solvent", { prefix });
  if (id2)
    sdfResult += `${prefix + tags.id}>
id\\
`;
  sdfResult += formatAssignments(labels.byDiaID, { prefix });
  sdfResult += await get1DSignals(data, nmrRecord, { prefix, labels });
  sdfResult += await get2DSignals(data, nmrRecord, { prefix, labels });
  sdfResult += "\n$$$$\n";
  nmrRecord.file(`${filename}.sdf`, sdfResult);
}
function formatAssignments(labels, options2) {
  if (!labels)
    return "";
  const { prefix } = options2;
  let str = `${prefix + tags.assignment}>
`;
  for (let l in labels) {
    let atoms = labels[l].atoms;
    str += `${labels[l].label}, ${labels[l].shift}`;
    for (let atom of atoms)
      str += `, ${atom}`;
    str += "\\\n";
  }
  return str;
}
function putTag(spectra, tag, options2 = { prefix: "" }) {
  const { prefix } = options2;
  let str = "";
  for (let spectrum of spectra) {
    if (spectrum.info[tag]) {
      str += `${prefix + tags[tag]}>
${String(spectrum.info[tag])}\\
`;
      break;
    }
  }
  return str;
}
function useExport() {
  const {
    rootRef
  } = useGlobal();
  const modal = useModal();
  const alert2 = useAlert();
  const state = useChartData();
  const saveToClipboardHandler = react.exports.useCallback(async () => {
    if (state.data.length > 0 && rootRef) {
      const hideLoading = await alert2.showLoading("Exporting as NMRium process in progress");
      setTimeout(() => {
        copyPNGToClipboard(rootRef, "nmrSVG");
        hideLoading();
        alert2.success("Image copied to clipboard");
      }, 0);
    }
  }, [rootRef, alert2, state]);
  const saveAsJSONHandler = react.exports.useCallback(async (spaceIndent = 0, isCompressed = true) => {
    if (state.data.length > 0) {
      const hideLoading = await alert2.showLoading("Exporting as NMRium process in progress");
      setTimeout(() => {
        async function handle() {
          var _a, _b;
          const fileName = (_b = (_a = state.data[0]) == null ? void 0 : _a.display) == null ? void 0 : _b.name;
          const exportedData = toJSON$1(state);
          await exportAsJSON(exportedData, fileName, spaceIndent, isCompressed);
          hideLoading();
        }
        void handle();
      }, 0);
    }
  }, [alert2, state]);
  const saveAsNMREHandler = react.exports.useCallback(async () => {
    if (state.data.length > 0) {
      const hideLoading = await alert2.showLoading("Exporting as NMRE process in progress");
      setTimeout(() => {
        async function handle() {
          var _a, _b;
          const fileName = (_b = (_a = state.data[0]) == null ? void 0 : _a.display) == null ? void 0 : _b.name;
          const exportedData = await nmriumToNmredata(state);
          exportAsNMRE(exportedData, fileName);
          hideLoading();
        }
        void handle();
      }, 0);
    }
  }, [alert2, state]);
  const saveAsSVGHandler = react.exports.useCallback(async () => {
    if (state.data.length > 0 && rootRef) {
      const hideLoading = await alert2.showLoading("Exporting as SVG process in progress");
      setTimeout(() => {
        var _a, _b;
        const fileName = (_b = (_a = state.data[0]) == null ? void 0 : _a.display) == null ? void 0 : _b.name;
        exportAsSVG(rootRef, "nmrSVG", fileName);
        hideLoading();
      }, 0);
    }
  }, [rootRef, alert2, state.data]);
  const saveAsPNGHandler = react.exports.useCallback(async () => {
    if (state.data.length > 0 && rootRef) {
      const hideLoading = await alert2.showLoading("Exporting as PNG process in progress");
      setTimeout(() => {
        var _a, _b;
        const fileName = (_b = (_a = state.data[0]) == null ? void 0 : _a.display) == null ? void 0 : _b.name;
        exportAsPng(rootRef, "nmrSVG", fileName);
        hideLoading();
      }, 0);
    }
  }, [rootRef, alert2, state.data]);
  const saveHandler = react.exports.useCallback((options2) => {
    async function handler() {
      const {
        name: name2,
        pretty,
        compressed,
        dataExportOption
      } = options2;
      const hideLoading = await alert2.showLoading(`Exporting as ${name2}.nmrium process in progress`);
      setTimeout(() => {
        void (async () => {
          const exportedData = toJSON$1(state, dataExportOption);
          const spaceIndent = pretty ? 2 : 0;
          await exportAsJSON(exportedData, name2, spaceIndent, compressed);
          hideLoading();
        })();
      }, 0);
    }
    void handler();
  }, [alert2, state]);
  const saveAsHandler = react.exports.useCallback(async () => {
    var _a, _b;
    if (state.data.length > 0) {
      const fileName = (_b = (_a = state.data[0]) == null ? void 0 : _a.display) == null ? void 0 : _b.name;
      modal.show(/* @__PURE__ */ jsx$1(SaveAsModal, {
        name: fileName,
        onSave: saveHandler
      }), {
        isBackgroundBlur: false,
        position: positions.TOP_CENTER,
        width: 400
      });
    }
  }, [modal, saveHandler, state.data]);
  return {
    saveToClipboardHandler,
    saveAsJSONHandler,
    saveAsNMREHandler,
    saveAsSVGHandler,
    saveAsPNGHandler,
    saveAsHandler
  };
}
function useCheckExperimentalFeature() {
  const preferences = usePreferences();
  const value = get_1(preferences.current, "display.general.experimentalFeatures", false);
  if ((value == null ? void 0 : value.hidden) === true || (value == null ? void 0 : value.display) === false) {
    return false;
  }
  return true;
}
function ButtonToolTip(_i) {
  var _j = _i, {
    children,
    style: style2 = {},
    onClick = () => null,
    popupTitle = "",
    popupPlacement = "right"
  } = _j, props = __objRest(_j, [
    "children",
    "style",
    "onClick",
    "popupTitle",
    "popupPlacement"
  ]);
  return /* @__PURE__ */ jsx$1(ToolTip$1, {
    title: popupTitle,
    popupPlacement,
    children: /* @__PURE__ */ jsx$1("button", __spreadProps(__spreadValues({
      style: style2,
      type: "button",
      onClick
    }, props), {
      children
    }))
  });
}
const tablePanelStyle = css`
  display: flex;
  flex-direction: column;
  height: 100%;
  width: 100%;

  .inner-container {
    height: 100%;
    overflow: hidden;
    isolation: isolate;
  }

  .table-container {
    overflow: auto;
    height: 100%;
    display: block;
    background-color: white;
  }
`;
const styles$U = css`
  background-color: #f5f5f5;
  border: none;
  border-radius: 5px;

  &:hover {
    background-color: lightgray !important;
    color: black !important;
  }

  &.toggle-active {
    background-color: gray;
    color: white;
  }
`;
function ToggleButton$1({
  children,
  style: style2 = {},
  onClick = () => null,
  popupTitle = "",
  popupPlacement = "right",
  defaultValue = false,
  disabled = false,
  className = ""
}) {
  const [flag, Toggle] = react.exports.useState(defaultValue);
  const toggleHandler = react.exports.useCallback(() => {
    onClick(!flag);
    Toggle(!flag);
  }, [onClick, flag]);
  return /* @__PURE__ */ jsx(ToolTip$1, {
    title: popupTitle,
    popupPlacement,
    children: /* @__PURE__ */ jsx("button", {
      disabled,
      css: styles$U,
      style: style2,
      className: (flag ? "toggle toggle-active " : "toggle ") + className,
      type: "button",
      onClick: toggleHandler,
      children
    })
  });
}
var ToggleButton$2 = react.exports.memo(ToggleButton$1);
const styles$T = css`
  display: flex;
  flex-direction: row;
  border-bottom: 0.55px solid rgb(240, 240, 240);
  padding: 0px 5px;

  .left-container {
    display: flex;
    flex-direction: row;
    flex: 1;
  }
  button {
    background-color: transparent;
    border: none;
    padding: 5px;
  }

  button:disabled {
    opacity: 0.6;
  }

  .counter-label {
    margin: 0;
    text-align: right;
    line-height: 22px;
    padding: 0px 10px;
    white-space: nowrap;
  }
`;
function DefaultPanelHeader({
  counter,
  onDelete = () => null,
  deleteToolTip = "Delete",
  onFilter = () => null,
  filterToolTip = "",
  filterIsActive = false,
  counterFiltered = 0,
  children,
  onSettingClick = () => null,
  showSettingButton = false,
  canDelete = true,
  style: style2 = {},
  className = ""
}) {
  return /* @__PURE__ */ jsxs("div", {
    css: styles$T,
    style: style2,
    className,
    children: [/* @__PURE__ */ jsxs("div", {
      className: "left-container",
      children: [canDelete && /* @__PURE__ */ jsx(ToolTip$1, {
        title: deleteToolTip,
        popupPlacement: "right",
        children: /* @__PURE__ */ jsx("button", {
          type: "button",
          onClick: onDelete,
          disabled: counter === 0,
          children: /* @__PURE__ */ jsx(FaRegTrashAlt, {})
        })
      }), filterToolTip ? /* @__PURE__ */ jsx(ToggleButton$2, {
        popupTitle: filterToolTip,
        popupPlacement: "right",
        onClick: onFilter,
        defaultValue: filterIsActive,
        children: /* @__PURE__ */ jsx(FaFilter, {
          style: {
            pointerEvents: "none",
            fontSize: "12px"
          }
        })
      }) : null, children]
    }), counter !== void 0 && /* @__PURE__ */ jsxs("p", {
      className: "counter-label",
      children: ["[", " ", filterIsActive && filterIsActive === true && counterFiltered !== void 0 ? `${counterFiltered}/${counter}` : counter, " ", "]"]
    }), showSettingButton && /* @__PURE__ */ jsx(ToolTip$1, {
      title: "preferences",
      popupPlacement: "left",
      children: /* @__PURE__ */ jsx("button", {
        type: "button",
        onClick: onSettingClick,
        children: /* @__PURE__ */ jsx(FaCog, {})
      })
    })]
  });
}
var DefaultPanelHeader$1 = react.exports.memo(DefaultPanelHeader);
function useCheckToolsVisibility() {
  const preferences = usePreferences();
  return (toolKey) => get_1(preferences.current, `display.toolBarButtons.${toolKey}`, true);
}
function SpectraAutomaticPickingButton() {
  const dispatch = useDispatch();
  const alert2 = useAlert();
  const {
    data
  } = useChartData();
  const isToolVisible = useCheckToolsVisibility();
  const automaticPickingHandler = react.exports.useCallback(() => {
    void (async () => {
      const hideLoading = await alert2.showLoading("Automatic Ranges/Zones detection for all spectra in progress");
      setTimeout(() => {
        dispatch({
          type: AUTO_RANGES_SPECTRA_PICKING
        });
        dispatch({
          type: AUTO_ZONES_SPECTRA_PICKING
        });
        hideLoading();
      }, 0);
    })();
  }, [dispatch, alert2]);
  if (Array.isArray(data) && data.length === 0 || !isToolVisible("autoRangesTool")) {
    return null;
  }
  return /* @__PURE__ */ jsx$1(ButtonToolTip, {
    popupTitle: "Automatic Ranges/Zones picking for all spectra",
    onClick: automaticPickingHandler,
    children: /* @__PURE__ */ jsx$1(SvgRangePicking, {})
  });
}
const styles$S = css`
  box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.25);
  padding: 0px;
  margin: 0px;
  border-radius: 2px;
  display: flex;
  flex-direction: column;
  position: fixed;
  z-index: 99999;
  padding: 2px;
  background-color: white;
  width: 150px;
  pointer-events: all;

  button {
    background-color: transparent;
    border: none;
    border-bottom: 0.55px solid #f0f0f0;
    font-size: 11px;
    padding: 5px;
    text-align: left;
    outline: none;
  }
  button:hover {
    background-color: #fafafa;
    outline: none;
  }

  button:active {
    background-color: #eaeaea;
    outline: none;
  }

  button:last-of-type {
    border: none;
  }
`;
function ContextMenu({
  context
}, ref) {
  const [position, setPosition] = react.exports.useState({
    left: 0,
    top: 0
  });
  const {
    rootRef,
    elementsWrapperRef
  } = useGlobal();
  const [data, setData2] = react.exports.useState();
  const [isVisible, show] = react.exports.useState();
  const [sourceElement, setSourceElement] = react.exports.useState(null);
  const root2 = react.exports.useRef();
  react.exports.useEffect(() => {
    root2.current = document.createElement("div");
    if (elementsWrapperRef) {
      elementsWrapperRef.appendChild(root2.current);
    }
    return () => {
      if (root2.current && elementsWrapperRef) {
        elementsWrapperRef.removeChild(root2.current);
      }
    };
  }, [elementsWrapperRef]);
  const contextMenuHandler = (event) => {
    event.preventDefault();
    setSourceElement(event.target.parentElement);
    show(true);
    const clickX = event.clientX;
    const clickY = event.clientY;
    const screenW = window.innerWidth;
    const screenH = window.innerHeight;
    const rootW = 150;
    const rootH = 0;
    const right = screenW - clickX > rootW;
    let left = !right;
    let top = screenH - clickY > rootH;
    const bottom = !top;
    if (right) {
      left = `${clickX + 5}px`;
    }
    if (left) {
      left = `${clickX - rootW - 5}px`;
    }
    if (top) {
      top = `${clickY + 5}px`;
    }
    if (bottom) {
      top = `${clickY - rootH - 5}px`;
    }
    setPosition({
      left,
      top
    });
  };
  react.exports.useImperativeHandle(ref, () => ({
    handleContextMenu: (e2, _data) => {
      setData2(_data);
      contextMenuHandler(e2);
    }
  }));
  const clickHandler = react.exports.useCallback((event, click) => {
    event.preventDefault();
    click(data);
    show(false);
  }, [data]);
  react.exports.useEffect(() => {
    const _handleGlobalClick = (event) => {
      const wasOutside = sourceElement && event.target.parentElement && !event.target.parentElement.isSameNode(sourceElement);
      if (wasOutside && isVisible)
        show(false);
    };
    if (rootRef) {
      rootRef.addEventListener("click", _handleGlobalClick);
    }
    return () => {
      if (rootRef) {
        rootRef.removeEventListener("click", _handleGlobalClick);
      }
    };
  }, [isVisible, ref, rootRef, sourceElement]);
  if (!isVisible) {
    return null;
  }
  return root2.current && reactDom.exports.createPortal(context && /* @__PURE__ */ jsx("div", {
    ref,
    css: [styles$S, position],
    children: context.map((c, index2) => /* @__PURE__ */ jsx("button", {
      type: "button",
      onClick: (e2) => clickHandler(e2, c.onClick),
      children: c.label
    }, index2))
  }), root2.current);
}
var ContextMenu$1 = react.exports.forwardRef(ContextMenu);
function ReactTableHeader({
  headerGroups
}) {
  return /* @__PURE__ */ jsx$1("thead", {
    children: headerGroups.map((headerGroup) => /* @__PURE__ */ jsx$1("tr", __spreadProps(__spreadValues({}, headerGroup.getHeaderGroupProps()), {
      children: headerGroup.headers.map((column) => /* @__PURE__ */ jsxs$1("th", __spreadProps(__spreadValues({}, column.getHeaderProps(column.getSortByToggleProps())), {
        style: column.style,
        children: [column.render("Header"), /* @__PURE__ */ jsx$1("span", {
          children: column.isSorted ? column.isSortedDesc ? " \u25BC" : " \u25B2" : ""
        })]
      }), column.getHeaderProps().key))
    }), headerGroup.getHeaderGroupProps().key))
  });
}
var ReactTableHeader$1 = react.exports.memo(ReactTableHeader);
function highlightStyle(isActive, row) {
  var _a;
  if (isActive) {
    return {
      backgroundColor: "#ff6f0057"
    };
  } else if (((_a = row.original) == null ? void 0 : _a.isConstantlyHighlighted) === true) {
    return {
      backgroundColor: "#f5f5dc"
    };
  }
  return {};
}
const rowCss = css`
  &:hover {
    background-color: #ff6f0091 !important;
  }

  &:active {
    background-color: #ff6f0070 !important;
  }
`;
function getIDs(row) {
  const id2 = row.original.id;
  if (id2) {
    if (id2 instanceof Array) {
      return id2;
    } else {
      return [String(id2)];
    }
  }
  return [""];
}
function ReactTableRow(props, ref) {
  const {
    row,
    highlightedSource = HighlightedSource.UNKNOWN,
    onContextMenu,
    onClick,
    isRowActive = false
  } = props;
  const data = react.exports.useMemo(() => ({
    type: highlightedSource,
    extra: row.original
  }), [highlightedSource, row]);
  const highlight = useHighlight(getIDs(row), data);
  react.exports.useEffect(() => {
    return () => {
      highlight.hide();
    };
  }, []);
  const clickHandler = react.exports.useCallback((event) => {
    onClick == null ? void 0 : onClick(event, row);
  }, [onClick, row]);
  return react.exports.useMemo(() => {
    return /* @__PURE__ */ jsx("tr", __spreadProps(__spreadValues(__spreadValues({
      ref,
      onContextMenu,
      css: [highlightStyle(highlight.isActive || isRowActive, row), onClick && rowCss]
    }, row.getRowProps()), highlight.onHover), {
      children: row.cells.map((cell) => {
        const {
          style: style2,
          padding
        } = cell.column;
        if (cell.isRowSpanned) {
          return null;
        } else {
          return /* @__PURE__ */ jsx("td", __spreadProps(__spreadValues({
            rowSpan: cell.rowSpan
          }, cell.getCellProps()), {
            onContextMenu: (e2) => {
              e2.preventDefault();
              return false;
            },
            style: __spreadValues({
              padding
            }, style2),
            onClick: clickHandler,
            children: cell.render("Cell")
          }), cell.key);
        }
      })
    }), row.getRowProps().key);
  }, [clickHandler, highlight.isActive, highlight.onHover, onClick, onContextMenu, ref, row]);
}
var ReactTableRow$1 = react.exports.forwardRef(ReactTableRow);
const ReactTableStyle = css`
  border-spacing: 0;
  border: 1px solid #dedede;
  width: 100%;
  max-height: 100%;
  font-size: 12px;

  .react-contextmenu-wrapper {
    display: contents;
  }

  tr {
    :last-child {
      td {
        border-bottom: 0;
      }
    }
  }

  th {
    position: sticky;
    background-color: white;
    z-index: 0;
    top: 0;
  }
  th,
  td {
    margin: 0;
    padding: 0.15rem 0.4rem;
    border-bottom: 1px solid #dedede;
    border-right: 1px solid #dedede;

    // :last-child {
    //   border-right: 0;
    // }
    button {
      background-color: transparent;
      border: none;
    }
  }
`;
const reactContext = react.exports.createContext(null);
const ReactTableProvider = reactContext.Provider;
function useReactTableContext() {
  const context = react.exports.useContext(reactContext);
  if (!context) {
    throw new Error("react table context was not found ");
  }
  return context;
}
function useRowSpan(hooks) {
  hooks.useInstance.push(reducer);
}
function reducer(instance) {
  const { allColumns } = instance;
  let rowSpanHeaders = [];
  allColumns.forEach((column) => {
    const { id: id2, enableRowSpan } = column;
    if (enableRowSpan !== void 0 && enableRowSpan !== false) {
      rowSpanHeaders.push({ id: id2, cellValue: null, cellIndex: 0 });
    }
  });
  Object.assign(instance, {
    rowSpanHeaders
  });
}
function prepareRowSpan(rows, index2, rowSpanHeaders, groupKey) {
  const row = rows[index2];
  for (let j = 0; j < row.allCells.length; j++) {
    const cell = row.allCells[j];
    const rowSpanHeader = rowSpanHeaders.find((x) => x.id === cell.column.id);
    if (rowSpanHeader !== void 0) {
      const cellValue = groupKey ? `${cell.value}-${row.original[groupKey]}` : cell.value;
      if (rowSpanHeader.cellValue === null || rowSpanHeader.cellValue !== cellValue) {
        cell.isRowSpanned = false;
        rowSpanHeader.cellValue = cellValue;
        rowSpanHeader.cellIndex = index2;
        cell.rowSpan = 1;
      } else {
        rows[rowSpanHeader.cellIndex].allCells[j].rowSpan++;
        cell.isRowSpanned = true;
      }
    }
  }
}
const styles$R = {
  table: (enableVirtualScroll) => {
    if (enableVirtualScroll) {
      return {
        position: "sticky",
        top: 0
      };
    }
  }
};
const ReactTableInner = react.exports.forwardRef(function ReactTableInner2(props, ref) {
  const {
    data,
    columns,
    highlightedSource,
    context = null,
    onScroll,
    approxItemHeight = 40,
    enableVirtualScroll = false,
    groupKey,
    onClick,
    highlightActiveRow = false
  } = props;
  const contextRef = react.exports.useRef(null);
  const {
    index: indexBoundary
  } = useReactTableContext();
  const [rowIndex, setRowIndex] = react.exports.useState();
  const {
    getTableProps,
    getTableBodyProps,
    headerGroups,
    rows,
    prepareRow,
    rowSpanHeaders
  } = reactTable.exports.useTable({
    columns,
    data
  }, reactTable.exports.useSortBy, useRowSpan);
  const contextMenuHandler = react.exports.useCallback((e2, row) => {
    if (!checkModifierKeyActivated(e2)) {
      e2.preventDefault();
      contextRef.current.handleContextMenu(e2, row.original);
    }
  }, [contextRef]);
  const rowsData = enableVirtualScroll ? rows.slice(indexBoundary.start, indexBoundary.end) : rows;
  const clickHandler = react.exports.useCallback((event, row) => {
    setRowIndex(row.index);
    onClick == null ? void 0 : onClick(event, row);
  }, [onClick]);
  return /* @__PURE__ */ jsxs("div", __spreadProps(__spreadValues({
    ref,
    className: "table-container",
    style: {
      overflowY: "auto",
      position: "relative",
      height: "100%"
    }
  }, enableVirtualScroll && {
    onScroll
  }), {
    children: [enableVirtualScroll && /* @__PURE__ */ jsx("div", {
      style: {
        height: approxItemHeight * data.length,
        position: "absolute",
        width: "100%",
        pointerEvents: "none"
      }
    }), /* @__PURE__ */ jsxs("table", __spreadProps(__spreadValues({}, getTableProps()), {
      css: ReactTableStyle,
      style: styles$R.table(enableVirtualScroll),
      children: [/* @__PURE__ */ jsx(ReactTableHeader$1, {
        headerGroups
      }), /* @__PURE__ */ jsx("tbody", __spreadProps(__spreadValues({}, getTableBodyProps()), {
        children: rowsData.map((row, index2) => {
          prepareRow(row);
          prepareRowSpan(rows, enableVirtualScroll ? index2 + indexBoundary.start : index2, rowSpanHeaders, groupKey);
          return /* @__PURE__ */ jsx(ReactTableRow$1, __spreadProps(__spreadValues({
            row
          }, row.getRowProps()), {
            onContextMenu: (e2) => contextMenuHandler(e2, row),
            onClick: highlightActiveRow ? clickHandler : onClick,
            highlightedSource,
            isRowActive: rowIndex === index2
          }), row.key);
        })
      }))]
    })), /* @__PURE__ */ jsx(ContextMenu$1, {
      ref: contextRef,
      context
    })]
  }));
});
function ReactTable(props) {
  const {
    data,
    approxItemHeight = 40,
    groupKey
  } = props;
  const ref = react.exports.useRef(null);
  const [mRef, {
    height
  }] = useMeasure();
  const combineRef = useCombinedRefs([mRef, ref]);
  const [tableVirtualConfig, setTableVirtualConfig] = react.exports.useState({
    offsetHeight: 0,
    scrollHeight: 0,
    numberOfVisibleRows: 0,
    index: {
      start: 0,
      end: 0
    }
  });
  react.exports.useEffect(() => {
    if (combineRef.current) {
      const {
        scrollHeight
      } = combineRef.current;
      const numberOfVisibleRows = Math.ceil(height / approxItemHeight);
      setTableVirtualConfig((prev) => __spreadProps(__spreadValues({}, prev), {
        offsetHeight: height,
        scrollHeight,
        numberOfVisibleRows,
        index: {
          start: 0,
          end: numberOfVisibleRows + 1
        }
      }));
    }
  }, [approxItemHeight, combineRef, height]);
  const lookForGroupIndex = react.exports.useCallback((currentIndex, side) => {
    const currentItem = data[currentIndex];
    if (currentItem.index && groupKey) {
      switch (side) {
        case -1: {
          let index2 = currentIndex - 1;
          while (index2 > 0) {
            if (data[index2][groupKey] !== currentItem[groupKey]) {
              return index2 + 1;
            }
            index2--;
          }
          return currentIndex;
        }
        case 1: {
          let index2 = currentIndex + 1;
          while (index2 < data.length) {
            if (data[index2][groupKey] !== currentItem[groupKey]) {
              return index2 - 1;
            }
            index2++;
          }
          return currentIndex;
        }
        default:
          return currentIndex;
      }
    }
    return currentIndex;
  }, [data, groupKey]);
  const findStartIndex = react.exports.useCallback((index2, numberOfVisibleRows) => {
    const newIndex = index2 - numberOfVisibleRows;
    const currentIndx = newIndex >= data.length ? newIndex : index2;
    return lookForGroupIndex(currentIndx, -1);
  }, [data.length, lookForGroupIndex]);
  const findEndIndex = react.exports.useCallback((index2, numberOfVisibleRows) => {
    const newIndex = index2 + numberOfVisibleRows;
    const currentIndx = newIndex >= data.length ? data.length - 1 : newIndex;
    return lookForGroupIndex(currentIndx, 1);
  }, [data.length, lookForGroupIndex]);
  const scrollHandler = react.exports.useCallback(() => {
    if (ref.current && tableVirtualConfig) {
      const {
        scrollTop
      } = ref.current;
      const {
        numberOfVisibleRows,
        index: index2
      } = tableVirtualConfig;
      const currentIndx = Math.ceil(scrollTop / approxItemHeight);
      const start = findStartIndex(currentIndx, numberOfVisibleRows);
      if (currentIndx !== index2.start) {
        const end = findEndIndex(currentIndx, numberOfVisibleRows);
        setTableVirtualConfig(__spreadProps(__spreadValues({}, tableVirtualConfig), {
          index: {
            start,
            end: end + 1
          }
        }));
      }
    }
  }, [approxItemHeight, findEndIndex, findStartIndex, tableVirtualConfig]);
  return /* @__PURE__ */ jsx(ReactTableProvider, {
    value: tableVirtualConfig,
    children: /* @__PURE__ */ jsx(ReactTableInner, __spreadValues({
      onScroll: scrollHandler,
      ref: combineRef
    }, props))
  });
}
var ReactTable$1 = react.exports.memo(ReactTable);
const styles$Q = {
  container: {
    height: "100%",
    backgroundColor: "white"
  },
  label: {
    textAlign: "center",
    width: "100%",
    fontSize: "11px",
    padding: "5px",
    color: "gray"
  }
};
function NoTableData({
  text = "No Data"
}) {
  return /* @__PURE__ */ jsx$1("div", {
    style: styles$Q.container,
    children: /* @__PURE__ */ jsx$1("p", {
      style: styles$Q.label,
      children: text
    })
  });
}
function AutomaticAssignmentTable({
  data
}) {
  const dispatch = useDispatch();
  const assignHandler = react.exports.useCallback((e2, row) => {
    e2.preventDefault();
    e2.stopPropagation();
    const assignments = row.original.assignment;
    dispatch({
      type: SET_AUTOMATIC_ASSIGNMENTS,
      payload: {
        assignments
      }
    });
  }, [dispatch]);
  const COLUMNS2 = react.exports.useMemo(() => [{
    index: 1,
    Header: "#",
    Cell: ({
      row
    }) => row.index + 1,
    style: {
      width: "1%",
      maxWidth: "40px",
      minWidth: "40px"
    }
  }, {
    index: 2,
    Header: "Score",
    accessor: "score"
  }, {
    index: 3,
    Header: "",
    style: {
      width: "1%",
      maxWidth: "24px",
      minWidth: "24px"
    },
    id: "assign-button",
    Cell: ({
      row
    }) => /* @__PURE__ */ jsx$1("button", {
      type: "button",
      className: "assign-button",
      onClick: (e2) => assignHandler(e2, row),
      children: /* @__PURE__ */ jsx$1(SvgAssignment, {})
    })
  }], [assignHandler]);
  return data && data.length > 0 ? /* @__PURE__ */ jsx$1(ReactTable$1, {
    data,
    columns: COLUMNS2,
    onClick: assignHandler,
    highlightActiveRow: true
  }) : /* @__PURE__ */ jsx$1(NoTableData, {});
}
var AutomaticAssignmentTable$1 = react.exports.memo(AutomaticAssignmentTable);
function mapSpectra(data) {
  return data.reduce((acc, spectrum) => {
    const { id: id2, info } = spectrum;
    const dimension = spectrum.info.dimension;
    if (dimension === 1) {
      const ranges = spectrum.ranges.values;
      acc.push({ id: id2, info, ranges });
    } else if (dimension === 2) {
      const zones = spectrum.zones.values;
      acc.push({ id: id2, info, zones });
    }
    return acc;
  }, []);
}
function useAutoAssignments() {
  const dispatch = useDispatch();
  const { data, molecules } = useChartData();
  const originData = react.exports.useRef();
  const alert2 = useAlert();
  const [assignments, setAssignments] = react.exports.useState([]);
  const restAssignments = react.exports.useCallback(() => {
    dispatch({
      type: SET_AUTOMATIC_ASSIGNMENTS,
      payload: { assignments: originData.current }
    });
  }, [dispatch]);
  const getAssignments$1 = react.exports.useCallback(() => {
    void (async () => {
      var _a, _b;
      const hideLoading = await alert2.showLoading("Auto Assignments");
      const molecule = full.Molecule.fromMolfile(((_a = molecules[0]) == null ? void 0 : _a.molfile) || "");
      const spectra = mapSpectra(data);
      if (!originData.current) {
        originData.current = spectra;
      }
      const result = await getAssignments({
        spectra,
        molecule
      }, { minScore: 0 });
      if ((_b = result[0]) == null ? void 0 : _b.assignment) {
        dispatch({
          type: SET_AUTOMATIC_ASSIGNMENTS,
          payload: { assignments: result[0].assignment }
        });
      } else {
        alert2.error("Could not assign molecule, please check that all the ranges are defined correctly");
      }
      setAssignments(result);
      hideLoading();
    })();
  }, [alert2, data, dispatch, molecules]);
  return react.exports.useMemo(() => ({
    getAssignments: getAssignments$1,
    assignments,
    restAssignments
  }), [assignments, getAssignments$1, restAssignments]);
}
function AutomaticAssignment() {
  const {
    getAssignments: getAssignments2,
    assignments,
    restAssignments
  } = useAutoAssignments();
  return /* @__PURE__ */ jsxs("div", {
    css: tablePanelStyle,
    children: [/* @__PURE__ */ jsxs(DefaultPanelHeader$1, {
      showSettingButton: false,
      canDelete: false,
      children: [/* @__PURE__ */ jsx(SpectraAutomaticPickingButton, {}), /* @__PURE__ */ jsx(ButtonToolTip, {
        popupTitle: "automatic assignment",
        onClick: getAssignments2,
        children: /* @__PURE__ */ jsx(SvgAssignment2, {
          style: {
            fontSize: "18px"
          }
        })
      }), /* @__PURE__ */ jsx(ButtonToolTip, {
        popupTitle: "reset assignment",
        onClick: restAssignments,
        children: /* @__PURE__ */ jsx(FaBolt, {})
      })]
    }), /* @__PURE__ */ jsx("div", {
      className: "inner-container",
      children: /* @__PURE__ */ jsx(AutomaticAssignmentTable$1, {
        data: assignments
      })
    })]
  });
}
function ReactTableFlexLayout({
  data,
  columns,
  onMouseDown = () => null
}) {
  const {
    getTableProps,
    getTableBodyProps,
    headerGroups,
    rows,
    prepareRow
  } = reactTable.exports.useTable({
    columns,
    data
  }, reactTable.exports.useSortBy, reactTable.exports.useFlexLayout);
  return /* @__PURE__ */ jsxs("table", __spreadProps(__spreadValues({}, getTableProps()), {
    css: ReactTableStyle,
    style: {
      height: "100%"
    },
    children: [/* @__PURE__ */ jsx("thead", {
      children: headerGroups.map((headerGroup) => /* @__PURE__ */ jsx("tr", __spreadProps(__spreadValues({}, headerGroup.getHeaderGroupProps()), {
        children: headerGroup.headers.map((column) => /* @__PURE__ */ jsxs("th", __spreadProps(__spreadValues({}, column.getHeaderProps(column.getSortByToggleProps())), {
          children: [column.render("Header"), /* @__PURE__ */ jsx("span", {
            children: column.isSorted ? column.isSortedDesc ? " \u25BC" : " \u25B2" : ""
          })]
        }), column.getHeaderProps().key))
      }), headerGroup.getHeaderGroupProps().key))
    }), /* @__PURE__ */ jsx("tbody", __spreadProps(__spreadValues({}, getTableBodyProps()), {
      style: {
        display: "block",
        height: "100%",
        overflowY: "auto"
      },
      children: rows.map((row) => {
        prepareRow(row);
        return /* @__PURE__ */ jsx("tr", __spreadProps(__spreadValues({}, row.getRowProps()), {
          onMouseDown,
          children: row.cells.map((cell) => {
            return /* @__PURE__ */ jsx("td", __spreadProps(__spreadValues({}, cell.getCellProps()), {
              style: __spreadProps(__spreadValues({}, cell.getCellProps().style), {
                padding: "0px"
              }),
              children: cell.render("Cell")
            }), cell.getCellProps().key);
          })
        }), row.getRowProps().key);
      })
    }))]
  }));
}
var ReactTableFlexLayout$1 = react.exports.memo(ReactTableFlexLayout);
const styles$P = {
  container: {
    height: "100%",
    flexDirection: "column",
    display: "flex",
    width: "100%"
  },
  tableContainer: {
    height: "calc(100% - 30px)",
    overflow: "auto",
    display: "block"
  },
  searchInput: {
    width: "100%",
    borderRadius: "5px",
    border: "0.55px solid gray",
    padding: "5px",
    marginBottom: "2px"
  }
};
function InformationPanelInner({
  info,
  meta
}) {
  const [information, setInformation] = react.exports.useState({});
  const [matches, setMatchesData] = react.exports.useState([]);
  const searchRef = react.exports.useRef(null);
  const handleSearch = react.exports.useCallback((e2) => {
    const values = Object.keys(information).filter((key) => key.toLowerCase().includes(e2.target ? e2.target.value.toLowerCase() : e2.toLowerCase()));
    setMatchesData(values);
  }, [information]);
  react.exports.useEffect(() => {
    if (searchRef.current) {
      handleSearch(searchRef.current.value);
    }
  }, [handleSearch, searchRef]);
  react.exports.useEffect(() => {
    if (info && meta) {
      const keys = Object.keys(info).concat(Object.keys(meta));
      setMatchesData(keys);
      setInformation(__spreadValues(__spreadValues({}, info), meta));
    }
  }, [info, meta]);
  const columns = react.exports.useMemo(() => [{
    Header: "Parameter",
    sortType: "basic",
    minWidth: 100,
    width: 20,
    maxWidth: 20,
    Cell: ({
      row
    }) => /* @__PURE__ */ jsx$1("p", {
      style: {
        padding: "5px",
        backgroundColor: "white"
      },
      children: row.original
    })
  }, {
    Header: "Value",
    sortType: "basic",
    resizable: true,
    Cell: ({
      row
    }) => /* @__PURE__ */ jsx$1("p", {
      style: {
        backgroundColor: "#efefef",
        height: "100%",
        padding: "5px",
        fontFamily: "monospace",
        whiteSpace: "pre",
        overflow: "hidden"
      },
      children: `${information[row.original]}`
    })
  }], [information]);
  return /* @__PURE__ */ jsxs$1("div", {
    style: styles$P.container,
    children: [/* @__PURE__ */ jsx$1("div", {
      children: /* @__PURE__ */ jsx$1("input", {
        type: "text",
        style: styles$P.searchInput,
        placeholder: "Search for parameter...",
        onChange: handleSearch,
        ref: searchRef
      })
    }), /* @__PURE__ */ jsx$1("div", {
      style: styles$P.tableContainer,
      children: /* @__PURE__ */ jsx$1(ReactTableFlexLayout$1, {
        data: matches,
        columns
      })
    })]
  });
}
const MemoizedInformationPanel = react.exports.memo(InformationPanelInner);
const emptyData$9 = {
  info: {},
  meta: {}
};
function InformationPanel() {
  const {
    info,
    meta
  } = useSpectrum(emptyData$9);
  return /* @__PURE__ */ jsx$1(MemoizedInformationPanel, {
    info,
    meta
  });
}
const styles$O = css`
  border-radius: 50%;
  width: 16px;
  height: 16px;
  background-color: transparent;
  border: none;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;

  :hover {
    background-color: red;
    border-radius: 50%;

    .icon {
      color: white;
    }
  }

  .icon {
    color: #252525;
    width: 8px;
  }
`;
function DeleteButton({
  onDelete,
  className = "delete"
}) {
  return /* @__PURE__ */ jsx("button", {
    css: styles$O,
    className,
    type: "button",
    onClick: onDelete,
    children: /* @__PURE__ */ jsx(FaTimes, {
      className: "icon"
    })
  });
}
const styles$N = (styles2) => css`
  position: relative;

  .delete {
    position: absolute;
    top: 2px;
    left: 2px;
  }

  ${styles2}
`;
function InternalTab({
  tabid,
  tablabel,
  isActive,
  onClick = () => null,
  canDelete,
  onDelete = () => null,
  tabstyles,
  render
}) {
  let className = "tab-list-item";
  if (isActive) {
    className += " tab-list-active";
  }
  const clickHandler = react.exports.useCallback((e2) => {
    onClick(__spreadProps(__spreadValues({}, e2), {
      tablabel,
      tabid
    }));
  }, [onClick, tablabel, tabid]);
  const deleteHandler = react.exports.useCallback((e2) => {
    e2.stopPropagation();
    onDelete(__spreadProps(__spreadValues({}, e2), {
      tablabel,
      tabid
    }));
  }, [onDelete, tablabel, tabid]);
  return /* @__PURE__ */ jsxs("li", {
    className,
    onClick: clickHandler,
    css: styles$N(tabstyles),
    "data-test-id": `tab-${tabid}`,
    children: [canDelete && /* @__PURE__ */ jsx(DeleteButton, {
      onDelete: deleteHandler
    }), render ? render({
      isActive,
      title: tablabel || "",
      id: tabid
    }) : tablabel]
  });
}
function Tab(props) {
  return /* @__PURE__ */ jsx(Fragment, {
    children: props.children
  });
}
const topStyles = css`
  height: 100%;
  width: 100%;
  display: flex;
  flex-direction: column;

  .tab-list {
    border-bottom: 1px solid #ccc;
    padding-left: 0;
    margin: 0;
  }

  .tab-list li:first-of-type {
    margin-left: 5px;
  }

  .tab-list li:hover {
    background-color: #f7f7f7;
  }

  .tab-list-item {
    display: inline-block;
    list-style: none;
    padding: 0.5rem 2rem;
  }

  .tab-list-active {
    background-color: white;
    border: solid #ccc;
    border-width: 1px 1px 0 1px;
  }

  .tab-content {
    height: 100%;
    overflow: auto;
  }
`;
const leftStyles = css`
  display: flex;
  height: 100%;
  width: 100%;
  .tab-list {
    border-right: 1px solid #ccc;
    padding-left: 0;
    margin: 0;
  }

  .tab-list li:hover {
    background-color: #f7f7f7;
  }

  .tab-list li:first-of-type {
    margin-top: 10px;
  }

  .tab-list-item {
    display: block;
    list-style: none;
    margin-right: -1px;
    padding: 0.5rem 0.75rem;
  }

  .tab-list-active {
    background-color: white;
    border: solid #ccc;
    border-width: 1px 0px 1px 1px;
  }

  .tab-content {
    height: 100%;
    overflow: auto;
  }
`;
var PositionsEnum = /* @__PURE__ */ ((PositionsEnum2) => {
  PositionsEnum2["TOP"] = "TOP";
  PositionsEnum2["LEFT"] = "LEFT";
  return PositionsEnum2;
})(PositionsEnum || {});
function Tabs({
  children,
  onClick,
  position,
  onDelete = () => null,
  activeTab
}) {
  const onClickTabHandler = react.exports.useCallback((tab) => {
    const {
      tablabel,
      tabid
    } = tab;
    onClick({
      tablabel,
      tabid
    });
  }, [onClick]);
  let contentChild;
  const tabs = react.exports.Children.map(children, (child) => {
    if (!react.exports.isValidElement(child))
      return null;
    const {
      tabid
    } = child.props;
    if (tabid === activeTab) {
      contentChild = child.props.children;
    }
    return /* @__PURE__ */ jsx(InternalTab, __spreadProps(__spreadValues({}, child.props), {
      isActive: tabid === activeTab,
      onClick: onClickTabHandler,
      onDelete
    }));
  });
  const styles2 = react.exports.useMemo(() => {
    switch (position) {
      case "TOP":
        return topStyles;
      case "LEFT":
        return leftStyles;
      default:
        return topStyles;
    }
  }, [position]);
  return /* @__PURE__ */ jsxs("div", {
    className: "tabs",
    css: styles2,
    children: [/* @__PURE__ */ jsx("ol", {
      className: "tab-list",
      children: tabs
    }), /* @__PURE__ */ jsx("div", {
      className: "tab-content",
      children: contentChild
    })]
  });
}
var Tabs$1 = react.exports.memo(Tabs);
function Arrow({
  direction,
  onClick
}) {
  return /* @__PURE__ */ jsx("div", {
    onClick,
    css: css`
        display: flex;
        position: absolute;
        top: calc(50% - 20px);
        ${direction === "right" ? `right: 25px` : `left: 25px`};
        height: 40px;
        width: 40px;
        justify-content: center;
        background: white;
        border-radius: 50%;
        cursor: pointer;
        align-items: center;
        border: none;
        transition: transform ease-in 0.1s;
        background-color: #f7f7f7;

        &:hover {
          transform: scale(1.1);
          background-color: #607d8b !important;
          color: white;
        }
        img {
          transform: translateX(${direction === "left" ? "-2" : "2"}px);
          &:focus {
            outline: 0;
          }
        }
      `,
    children: /* @__PURE__ */ jsx(FaAngleLeft, {
      style: {
        transform: `scaleX(${direction === "right" ? "-1" : "1"})`
      }
    })
  });
}
const transition = 0.45;
function NextPrev({
  children,
  loop = false,
  defaultIndex = 0,
  onChange = () => null
}) {
  const [ref, {
    width
  }] = useMeasure();
  const [activeIndex, setActiveIndex] = react.exports.useState(0);
  react.exports.useEffect(() => {
    setActiveIndex(defaultIndex);
  }, [defaultIndex]);
  const Sliders = react.exports.useMemo(() => react.exports.Children.map(children, (child) => {
    return /* @__PURE__ */ jsx("div", {
      css: css`
              width: ${width}px;
              height: 100%;
            `,
      children: child
    }, child.key);
  }), [children, width]);
  const nextHandler = react.exports.useCallback(() => {
    setActiveIndex((preActiveIndex) => {
      if (Sliders && preActiveIndex === Sliders.length - 1) {
        onChange(preActiveIndex);
        if (loop) {
          return 0;
        } else {
          return preActiveIndex;
        }
      }
      const nextIndex = preActiveIndex + 1;
      onChange(nextIndex);
      return nextIndex;
    });
  }, [Sliders, loop, onChange]);
  const prevHandler = react.exports.useCallback(() => {
    setActiveIndex((preActiveIndex) => {
      if (preActiveIndex === 0) {
        onChange(preActiveIndex);
        if (loop) {
          return 0;
        } else {
          return preActiveIndex;
        }
      }
      const prevIndex = preActiveIndex - 1;
      onChange(prevIndex);
      return prevIndex;
    });
  }, [loop, onChange]);
  if (!width && !Sliders)
    return null;
  return /* @__PURE__ */ jsxs("div", {
    css: css`
        position: relative;
        height: 100%;
        width: 100%;
        margin: 0 auto;
        overflow: hidden;
        display: block;
      `,
    ref,
    children: [/* @__PURE__ */ jsx("div", {
      css: css`
          transform: translateX(-${width * activeIndex}px);
          transition: transform ease-out ${transition}s;
          height: 100%;
          width: ${width * (Sliders ? Sliders.length : 1)}px;
          display: flex;
        `,
      children: Sliders
    }), activeIndex !== 0 && /* @__PURE__ */ jsx(Arrow, {
      direction: "left",
      onClick: prevHandler
    }), Sliders && activeIndex !== Sliders.length - 1 && /* @__PURE__ */ jsx(Arrow, {
      direction: "right",
      onClick: nextHandler
    })]
  });
}
var NextPrev$1 = react.exports.memo(NextPrev);
const toolbarStyle$1 = css`
  display: flex;
  flex-direction: row;
  border-top: 0.55px solid rgb(240, 240, 240);
  border-bottom: 0.55px solid rgb(240, 240, 240);
  padding: 0px 5px;

  p {
    margin: 0;
    text-align: right;
    width: 100%;
    line-height: 22px;
    padding: 0px 10px;
  }
`;
const moleculeContainerStyle = css`
  width: 100%;
  position: relative;
  .slider {
    height: 180px;
    width: 100%;
    padding: 0px;
    padding: 0px;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
  }
  .slider p {
    width: 100%;
    margin: 0 auto;
    display: block;
    position: relative;
    text-align: center;
  }
  .slider svg polygon {
    fill: gray !important;
  }
  button {
    flex: 2;
    padding: 5px;
    border: 1px solid gray;
    border-radius: 5px;
    height: 36px;
    margin: 0 auto;
    margin-top: 15px;
    display: block;
    width: 20%;

    color: white;
    background-color: gray;
  }
`;
function MoleculeSelection(props) {
  const {
    molecules,
    onChange = () => null,
    index: index2
  } = props;
  const [currentIndex, setCurrentIndex] = react.exports.useState(0);
  react.exports.useEffect(() => {
    const _index = index2 && index2 < molecules.length ? index2 : 0;
    if (molecules && molecules.length > 0) {
      setCurrentIndex(_index);
    }
  }, [index2, molecules]);
  const onChangeHandler = react.exports.useCallback((slideIndex) => {
    setCurrentIndex(slideIndex);
    onChange(slideIndex);
  }, [onChange]);
  return /* @__PURE__ */ jsxs("div", {
    children: [/* @__PURE__ */ jsx("div", {
      css: toolbarStyle$1,
      children: /* @__PURE__ */ jsxs("p", {
        children: [molecules && molecules.length > 0 && `${+(currentIndex + 1)} / ${molecules.length}`, " "]
      })
    }), /* @__PURE__ */ jsx("div", {
      css: moleculeContainerStyle,
      children: /* @__PURE__ */ jsx(NextPrev$1, {
        defaultIndex: currentIndex,
        onChange: onChangeHandler,
        children: molecules == null ? void 0 : molecules.map((mol, index22) => {
          var _a;
          return /* @__PURE__ */ jsxs("div", {
            className: "slider",
            children: [/* @__PURE__ */ jsx("div", {
              children: mol.molfile && /* @__PURE__ */ jsx(MolfileSvgRenderer, {
                id: `molSVG${index22}`,
                width: 120,
                molfile: mol.molfile
              })
            }), /* @__PURE__ */ jsxs("p", {
              children: [/* @__PURE__ */ jsx(_default, {
                mf: mol.mf
              }), " - ", (_a = mol.mw) == null ? void 0 : _a.toFixed(2)]
            })]
          }, mol.key);
        })
      })
    })]
  });
}
const styles$M = css`
  .molecule-container {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    .title {
      padding: 0px 10px;
      width: 100%;
      text-align: center;
    }

    .molecule-selection-container {
      width: 450px;
      display: block;
      margin: 0 auto;
    }

    .newSumText {
      margin-top: 15px;
      padding: 0px 10px;
      width: 100%;

      text-align: center;
    }
  }

  .empty {
    width: 100%;
    padding: 20%;
    text-align: center;
  }
`;
function SelectMolecule(props) {
  const [currentIndex, setCurrentIndex] = react.exports.useState();
  const {
    setFieldValue,
    errors,
    values
  } = useFormikContext();
  const {
    molecules,
    activeTab
  } = useChartData();
  const element = getAtom(activeTab);
  const newSum = react.exports.useMemo(() => {
    return element && molecules && molecules.length > 0 && currentIndex !== void 0 && molecules[currentIndex].atoms[element] ? molecules[currentIndex].atoms[element] : 0;
  }, [currentIndex, element, molecules]);
  const setValue = react.exports.useCallback((index2) => {
    setCurrentIndex(index2);
    setFieldValue(props.name, molecules[index2]);
  }, [molecules, props.name, setFieldValue]);
  react.exports.useEffect(() => {
    if (molecules && molecules.length > 0) {
      const index2 = values[props.name] ? molecules.findIndex((molecule) => molecule.key === values[props.name].key) : -1;
      setValue(index2 !== -1 ? index2 : 0);
    }
  }, [molecules, props.name, setValue, values]);
  const onChangeMoleculeSelectionHandler = react.exports.useCallback((index2) => {
    setValue(index2);
  }, [setValue]);
  return /* @__PURE__ */ jsx("div", {
    css: styles$M,
    children: element && molecules && molecules.length > 0 ? /* @__PURE__ */ jsxs("div", {
      className: "molecule-container",
      children: [/* @__PURE__ */ jsx("p", {
        className: "title",
        children: "Select a molecule as reference!"
      }), /* @__PURE__ */ jsxs("div", {
        className: "molecule-selection-container",
        children: [/* @__PURE__ */ jsx(MoleculeSelection, {
          index: currentIndex,
          molecules,
          onChange: onChangeMoleculeSelectionHandler
        }), /* @__PURE__ */ jsxs("p", {
          className: "newSumText",
          children: ["New sum for ", element, " will be ", newSum, "!"]
        })]
      })]
    }) : /* @__PURE__ */ jsx("p", {
      className: "empty",
      style: {
        color: errors[props.name] ? "red" : "black"
      },
      children: "You have to Select a spectrum and Add a molecule from the Structure panel to select as a reference!"
    })
  });
}
const styles$L = css`
  width: 450px;
  height: 400px;
  .header {
    display: flex;
    padding: 10px;
    span {
      font-size: 14px;
      flex: 1;
    }
  }

  .tab-content {
    flex: 1;
  }

  .manual-container {
    padding: 30px 5px;

    .input {
      width: 80% !important;
      height: 36px;
      margin: 0 auto;
    }
    .input Input {
      padding: 5px;
      text-align: center;
    }
  }

  .footer-container {
    button {
      width: 20%;
      color: white;
      background-color: gray !important;
    }
    button:hover {
      border: 1px solid gray;
      color: gray;
      background-color: white !important;
    }
  }
`;
function ChangeSumModal({
  onSave,
  onClose,
  header,
  sumOptions
}) {
  var _a;
  const {
    current: {
      display: {
        general,
        panels
      }
    }
  } = usePreferences();
  const [setOption, setActiveOption] = react.exports.useState("auto");
  const formRef = react.exports.useRef(null);
  const handleKeyDown = react.exports.useCallback((event) => {
    if (event.key === "Enter") {
      formRef.current.submitForm();
    }
  }, []);
  const onTabChangeHandler = react.exports.useCallback((tab) => {
    setActiveOption(tab.tabid);
  }, []);
  react.exports.useEffect(() => {
    var _a2;
    if ((sumOptions == null ? void 0 : sumOptions.sumAuto) && !(general == null ? void 0 : general.hideSetSumFromMolecule) && !((_a2 = panels == null ? void 0 : panels.structuresPanel) == null ? void 0 : _a2.hidden)) {
      setActiveOption("auto");
      const {
        mf,
        moleculeKey: key
      } = sumOptions;
      formRef.current.setValues({
        sum: null,
        molecule: key && mf ? {
          mf,
          key
        } : null
      });
    } else {
      setActiveOption("manual");
      formRef.current.setValues({
        sum: (sumOptions == null ? void 0 : sumOptions.sum) || "",
        molecule: null
      });
    }
  }, [general == null ? void 0 : general.hideSetSumFromMolecule, panels == null ? void 0 : panels.structuresPanel, sumOptions]);
  const saveHandler = react.exports.useCallback((values) => {
    switch (setOption) {
      case "auto": {
        const {
          molecule: {
            mf,
            key: moleculeKey
          }
        } = values;
        onSave({
          sumAuto: true,
          mf,
          moleculeKey
        });
        break;
      }
      case "manual": {
        const {
          sum
        } = values;
        onSave({
          sum,
          sumAuto: false
        });
        break;
      }
      default:
        return;
    }
    onClose();
  }, [onClose, onSave, setOption]);
  const validationSchema2 = react.exports.useMemo(() => {
    switch (setOption) {
      case "auto": {
        return create({
          molecule: create().required()
        });
      }
      case "manual": {
        return create({
          sum: create$1().required()
        });
      }
      default:
        return null;
    }
  }, [setOption]);
  return /* @__PURE__ */ jsxs("div", {
    css: [ModalStyles, styles$L],
    children: [/* @__PURE__ */ jsxs("div", {
      className: "header handle",
      children: [/* @__PURE__ */ jsx("span", {
        children: header
      }), /* @__PURE__ */ jsx(CloseButton$1, {
        onClick: onClose
      })]
    }), /* @__PURE__ */ jsx("div", {
      className: "tab-content",
      children: /* @__PURE__ */ jsx(FormikForm, {
        ref: formRef,
        onSubmit: saveHandler,
        initialValues: {
          sum: null,
          molecule: null
        },
        validationSchema: validationSchema2,
        children: /* @__PURE__ */ jsxs(Tabs$1, {
          activeTab: setOption,
          onClick: onTabChangeHandler,
          children: [!(general == null ? void 0 : general.hideSetSumFromMolecule) && !((_a = panels == null ? void 0 : panels.structuresPanel) == null ? void 0 : _a.hidden) && /* @__PURE__ */ jsx(Tab, {
            tablabel: "Auto",
            tabid: "auto",
            children: /* @__PURE__ */ jsx(SelectMolecule, {
              name: "molecule"
            })
          }), /* @__PURE__ */ jsx(Tab, {
            tablabel: "Manual",
            tabid: "manual",
            children: /* @__PURE__ */ jsx("div", {
              className: "manual-container",
              children: /* @__PURE__ */ jsx(FormikInput, {
                name: "sum",
                type: "number",
                placeholder: "Enter the new value",
                onKeyDown: handleKeyDown
              })
            })
          })]
        })
      })
    }), /* @__PURE__ */ jsx("div", {
      className: "footer-container",
      children: /* @__PURE__ */ jsx("button", {
        type: "button",
        onClick: () => formRef.current.submitForm(),
        className: "btn",
        children: "Set"
      })
    })]
  });
}
const styles$K = css`
  background-color: transparent;
  border: none;
  height: 100%;
  svg {
    fill: green;
    font-size: 16px;
  }
`;
function SaveButton(props) {
  const {
    className = "",
    disabled = false,
    popupPlacement = "left",
    popupTitle = "Save",
    onClick
  } = props;
  return /* @__PURE__ */ jsx("div", {
    className,
    children: /* @__PURE__ */ jsx(ToolTip$1, {
      title: popupTitle,
      popupPlacement,
      children: /* @__PURE__ */ jsx("button", {
        css: styles$K,
        type: "button",
        onClick,
        disabled,
        className,
        children: /* @__PURE__ */ jsx(FaCheck, {})
      })
    })
  });
}
var SaveButton$1 = react.exports.memo(SaveButton);
const styles$J = css`
  display: flex;
  flex-direction: row-reverse;
  border-bottom: 0.55px solid rgb(240, 240, 240);

  button {
    background-color: transparent;
    border: none;
    padding: 5px;
  }
  button:disabled {
    opacity: 0.6;
  }
`;
function PreferencesHeader({
  onClose,
  onSave
}) {
  return /* @__PURE__ */ jsxs("div", {
    css: styles$J,
    children: [/* @__PURE__ */ jsx(CloseButton$1, {
      onClick: onClose,
      popupTitle: "close Preferences"
    }), /* @__PURE__ */ jsx(SaveButton$1, {
      onClick: onSave,
      popupTitle: "save Preferences"
    })]
  });
}
var PreferencesHeader$1 = react.exports.memo(PreferencesHeader);
function EditableColumn(props, ref) {
  const {
    onSave = () => null,
    value,
    type = "text",
    style: style2,
    onEditStart = () => null,
    editStatus = false
  } = props;
  const [enabled, enableEdit] = react.exports.useState();
  react.exports.useEffect(() => {
    enableEdit(editStatus);
  }, [editStatus]);
  react.exports.useImperativeHandle(ref, () => ({
    startEdit: () => {
      enableEdit(true);
    },
    closeEdit: () => {
      enableEdit(false);
    }
  }));
  const mouseClickCallback = react.exports.useCallback((e2) => {
    if (!e2.target.classList.contains("editable-column")) {
      enableEdit(false);
      window.removeEventListener("mousedown", mouseClickCallback);
    }
  }, []);
  const editModeHandler = react.exports.useCallback((flag, event) => {
    if (!flag && event) {
      if (["Enter", "Tab"].includes(event.key)) {
        onSave(event);
      }
      if (["Enter", "Tab", "Escape"].includes(event.key)) {
        enableEdit(flag);
        window.removeEventListener("mousedown", mouseClickCallback);
      }
    } else {
      window.addEventListener("mousedown", mouseClickCallback);
      onEditStart(event);
      enableEdit(flag);
    }
  }, [mouseClickCallback, onEditStart, onSave]);
  return /* @__PURE__ */ jsxs$1("div", {
    style: __spreadValues({
      display: "table",
      width: "100%",
      height: "100%"
    }, style2),
    onDoubleClick: () => editModeHandler(true),
    children: [!enabled && /* @__PURE__ */ jsx$1("span", {
      style: {
        display: "table-cell",
        verticalAlign: "middle"
      },
      children: value
    }), enabled && /* @__PURE__ */ jsx$1("div", {
      style: {
        display: "table-cell",
        verticalAlign: "middle"
      },
      children: /* @__PURE__ */ jsx$1(Input, {
        enableAutoSelect: true,
        className: "editable-column",
        value,
        type,
        onKeyDown: (e2) => editModeHandler(false, e2)
      })
    })]
  });
}
var EditableColumn$1 = react.exports.forwardRef(EditableColumn);
function addCustomColumn(array2, options2) {
  const {
    index: index2,
    Header: Header2 = () => null,
    extraParams,
    accessor = null,
    Cell = null,
    sortType = "basic",
    enableRowSpan = false,
    style: style2 = {},
    id: id2
  } = options2 || {};
  array2.push(__spreadValues(__spreadProps(__spreadValues(__spreadValues(__spreadValues({
    index: index2
  }, __spreadValues({}, id2 && { id: id2 })), __spreadValues({}, accessor ? { accessor } : {})), __spreadValues({}, Cell ? { Cell } : {})), {
    Header: Header2,
    sortType,
    enableRowSpan,
    style: style2
  }), extraParams));
}
const arrowDownIcon = `url('data:image/svg+xml;utf8,<svg  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="960px" height="560px" viewBox="0 0 960 560" enable-background="new 0 0 960 560" xml:space="preserve"><g id="Rounded_Rectangle_33_copy_4_1_"><path d="M480,344.181L268.869,131.889c-15.756-15.859-41.3-15.859-57.054,0c-15.754,15.857-15.754,41.57,0,57.431l237.632,238.937c8.395,8.451,19.562,12.254,30.553,11.698c10.993,0.556,22.159-3.247,30.555-11.698l237.631-238.937c15.756-15.86,15.756-41.571,0-57.431s-41.299-15.859-57.051,0L480,344.181z"/></g></svg>')`;
const styles$I = {
  select: (width) => css`
    padding: 0px 5px;
    border: 0.55px solid #cacaca;
    font-size: 14px;
    width: ${width ? Number(width) - 5 : 115}px;
    margin: 0;
    height: 100%;
    background: ${arrowDownIcon} no-repeat right white;
    -webkit-appearance: none;
    background-position-x: calc(100% - 5px);
    background-size: 15px 15px;
    border-radius: 5px;
    margin: 0px 5px;
    align-self: center;
    &:focus,
    input:focus {
      outline: none;
    }

    &:required:invalid {
      color: #666;
    }
  `
};
const Select = react.exports.forwardRef(function Select2(props, ref) {
  const {
    data,
    style: style2 = {
      width: 100
    },
    onChange = () => null,
    defaultValue = "",
    name: name2 = "",
    className = "",
    placeholder = ""
  } = props;
  const handleOnChanged = react.exports.useCallback((e2) => {
    let value = e2.target.value;
    if (!isNaN(value)) {
      value = Number(value);
    }
    onChange(value);
  }, [onChange]);
  return /* @__PURE__ */ jsxs("select", {
    ref,
    css: styles$I.select(style2 == null ? void 0 : style2.width),
    name: name2,
    onChange: handleOnChanged,
    defaultValue,
    className,
    style: style2,
    required: true,
    children: [placeholder && /* @__PURE__ */ jsx("option", {
      value: "",
      disabled: true,
      children: placeholder
    }), data.map((d) => /* @__PURE__ */ jsx("option", {
      value: d.value,
      children: d.label
    }, `${d.key}`))]
  });
});
const selectStyle = {
  marginLeft: 10,
  marginRight: 10,
  border: "none"
};
function IntegralTable({
  activeTab,
  data,
  preferences
}) {
  const dispatch = useDispatch();
  const deleteIntegralHandler = react.exports.useCallback((e2, row) => {
    e2.preventDefault();
    e2.stopPropagation();
    const params = row.original;
    dispatch({
      type: DELETE_INTEGRAL,
      integralID: params.id
    });
  }, [dispatch]);
  const changeIntegralDataHandler = react.exports.useCallback((value, row) => {
    const data2 = __spreadProps(__spreadValues({}, row.original), {
      kind: value
    });
    dispatch({
      type: CHANGE_INTEGRAL_DATA,
      payload: {
        data: data2
      }
    });
  }, [dispatch]);
  const initialColumns = react.exports.useMemo(() => [{
    index: 1,
    Header: "#",
    Cell: ({
      row
    }) => row.index + 1,
    width: 10
  }, {
    index: 2,
    Header: "From",
    sortType: "basic",
    resizable: true,
    accessor: (row) => row.from.toFixed(2)
  }, {
    index: 3,
    Header: "To",
    sortType: "basic",
    resizable: true,
    accessor: (row) => row.to.toFixed(2)
  }, {
    index: 6,
    Header: "Kind",
    sortType: "basic",
    resizable: true,
    accessor: (row) => row.kind,
    Cell: ({
      row
    }) => /* @__PURE__ */ jsx$1(Select, {
      onChange: (value) => changeIntegralDataHandler(value, row),
      data: SignalKinds,
      style: selectStyle,
      defaultValue: row.original.kind
    })
  }, {
    index: 7,
    style: {
      width: "1%",
      maxWidth: "24px",
      minWidth: "24px"
    },
    id: "delete-button",
    Cell: ({
      row
    }) => /* @__PURE__ */ jsx$1("button", {
      type: "button",
      className: "delete-button",
      onClick: (e2) => deleteIntegralHandler(e2, row),
      children: /* @__PURE__ */ jsx$1(FaRegTrashAlt, {})
    })
  }], [changeIntegralDataHandler, deleteIntegralHandler]);
  const saveRelativeHandler = react.exports.useCallback((event, row) => {
    const data2 = {
      value: event.target.value,
      id: row.id
    };
    dispatch({
      type: CHANGE_INTEGRAL_RELATIVE,
      payload: {
        data: data2
      }
    });
  }, [dispatch]);
  const integralsPreferences = react.exports.useMemo(() => getValue(preferences.current, `formatting.panels.integrals.[${activeTab}]`, integralDefaultValues), [activeTab, preferences]);
  const COLUMNS2 = react.exports.useMemo(() => [{
    showWhen: "showAbsolute",
    index: 4,
    Header: "Absolute",
    accessor: (row) => FormatNumber(row.absolute, get_1(integralsPreferences, "absoluteFormat", integralDefaultValues.absoluteFormat))
  }, {
    showWhen: "showRelative",
    index: 5,
    id: "relative",
    Header: () => {
      const n = activeTab == null ? void 0 : activeTab.replace(/[0-9]/g, "");
      return /* @__PURE__ */ jsx$1("span", {
        children: `Relative ${n}`
      });
    },
    accessor: (row) => {
      return FormatNumber(row.integral, get_1(integralsPreferences, "relativeFormat", integralDefaultValues.relativeFormat));
    },
    Cell: ({
      row
    }) => {
      const value = FormatNumber(row.original.integral, get_1(integralsPreferences, "relativeFormat", integralDefaultValues.relativeFormat));
      const flag = checkIntegralKind(row.original);
      const integral = flag ? value : `[ ${value} ]`;
      return /* @__PURE__ */ jsx$1(EditableColumn$1, {
        value: integral,
        onSave: (event) => saveRelativeHandler(event, row.original),
        type: "number"
      });
    }
  }], [activeTab, integralsPreferences, saveRelativeHandler]);
  const tableColumns = react.exports.useMemo(() => {
    let columns = [...initialColumns];
    for (const col of COLUMNS2) {
      const _a = col, {
        showWhen
      } = _a, colParams = __objRest(_a, [
        "showWhen"
      ]);
      if (integralsPreferences[showWhen]) {
        addCustomColumn(columns, colParams);
      }
    }
    return columns.sort((object1, object2) => object1.index - object2.index);
  }, [COLUMNS2, initialColumns, integralsPreferences]);
  return data && data.length > 0 ? /* @__PURE__ */ jsx$1(ReactTable$1, {
    data,
    columns: tableColumns
  }) : /* @__PURE__ */ jsx$1(NoTableData, {});
}
var IntegralTable$1 = react.exports.memo(IntegralTable);
const style$8 = css`
  display: flex;
  margin: 5px 0px;

.inputLabel{
  flex: 2;
  font-size: 11px;
  font-weight: bold;
  color: #232323;
}

.input {
  width: '60%',
  text-align: 'center',
}

.color{
  width: 36px;
  height: 14px;
  border-radius: 2px;
}

.swatch{
  padding: 5px;
  background: #fff;
  border-radius: 1px;
  box-shadow: 0 0 0 1px rgba(0,0,0,.1);
  display: inline-block;
  cursor: pointer;
}
.color-popover {
  position: absolute;
  z-index: 2;
}

.cover {
  position: fixed;
  top: 0px;
  right: 0px;
  bottom: 0px;
  left: 0px;
}
  .chrome-picker {
    border-radius: none !important;
    width: 200px !important;
    height: 60px !important;
    display: flex;


  }
  .chrome-picker > div:first-of-type {
    padding: 0px !important;

  }
  .chrome-picker > div:last-child >  div:first-of-type {
    width: 120px;

  }
  .chrome-picker > div:last-child >  div:last-child {
    display:none !important;
  }
`;
function ColorInput(props) {
  const {
    label = "Color: ",
    onColorChange = () => null,
    name: name2,
    value = "#000000"
  } = props;
  const [displayColorPicker, showColorPicker] = react.exports.useState(false);
  const [selectedColor, setColor] = react.exports.useState(value);
  react.exports.useEffect(() => {
    setColor(value);
  }, [value]);
  const handleClick = react.exports.useCallback(() => {
    showColorPicker(!displayColorPicker);
  }, [displayColorPicker]);
  const handleClose = react.exports.useCallback(() => {
    showColorPicker(false);
  }, []);
  const handleOnColorChanged = react.exports.useCallback((colorEvent) => {
    const hex = `${colorEvent.hex}${Math.round(colorEvent.rgb.a * 255).toString(16)}`;
    setColor(hex);
    onColorChange(__spreadProps(__spreadValues({}, colorEvent), {
      hex,
      name: name2
    }));
  }, [name2, onColorChange]);
  return /* @__PURE__ */ jsxs("div", {
    css: style$8,
    children: [/* @__PURE__ */ jsx("span", {
      className: "inputLabel",
      children: label
    }), /* @__PURE__ */ jsxs("div", {
      style: {
        flex: 4
      },
      children: [/* @__PURE__ */ jsxs("div", {
        className: "swatch",
        onClick: handleClick,
        children: [/* @__PURE__ */ jsx("div", {
          className: "color",
          style: {
            backgroundColor: selectedColor
          }
        }), /* @__PURE__ */ jsx("input", {
          type: "hidden",
          value: selectedColor,
          name: name2
        })]
      }), displayColorPicker ? /* @__PURE__ */ jsxs("div", {
        className: "color-popover",
        children: [/* @__PURE__ */ jsx("div", {
          className: "cover",
          onClick: handleClose
        }), /* @__PURE__ */ jsx(lib.ChromePicker, {
          color: {
            hex: selectedColor
          },
          onChangeComplete: handleOnColorChanged
        })]
      }) : null]
    })]
  });
}
var ColorInput$1 = react.exports.memo(ColorInput);
function FormikColorPicker$2(props) {
  const _a = props, {
    onColorChange = () => null,
    name: name2
  } = _a, colorPickerProps = __objRest(_a, [
    "onColorChange",
    "name"
  ]);
  const {
    values,
    setFieldValue
  } = useFormikContext();
  const colorChangeHandler = react.exports.useCallback((color) => {
    onColorChange(color);
    setFieldValue(name2, color.hex);
  }, [name2, onColorChange, setFieldValue]);
  return /* @__PURE__ */ jsx$1(ColorInput$1, __spreadProps(__spreadValues({}, colorPickerProps), {
    name: name2,
    onColorChange: colorChangeHandler,
    value: get_1(values, name2)
  }));
}
var FormikColorInput = react.exports.memo(FormikColorPicker$2);
const styles$H = {
  row: {
    display: "flex",
    margin: "5px 0px",
    alignItems: "center"
  },
  inputLabel: {
    flex: 2,
    fontSize: "11px",
    fontWeight: "bold",
    color: "#232323"
  },
  input: {
    width: "60%",
    textAlign: "center"
  }
};
function FormikColumnFormatField(props) {
  const {
    label,
    checkControllerName,
    formatControllerName,
    disableFormat = false,
    hideFormat = false
  } = props;
  const {
    values,
    handleChange,
    setFieldValue
  } = useFormikContext();
  const changeHandler = react.exports.useCallback((e2) => {
    handleChange(e2);
  }, [handleChange]);
  const checkChangeHandler = react.exports.useCallback((e2) => {
    setFieldValue(e2.target.name, e2.target.checked);
  }, [setFieldValue]);
  return /* @__PURE__ */ jsxs$1("div", {
    style: styles$H.row,
    children: [/* @__PURE__ */ jsx$1("span", {
      style: styles$H.inputLabel,
      children: label
    }), /* @__PURE__ */ jsxs$1("div", {
      style: {
        flex: 4,
        display: "flex",
        flexDirection: "row",
        alignItems: "center"
      },
      children: [/* @__PURE__ */ jsx$1("input", {
        type: "checkbox",
        style: {
          margin: "0px 5px"
        },
        name: checkControllerName,
        onChange: checkChangeHandler,
        checked: get_1(values, checkControllerName, false)
      }), !hideFormat && formatControllerName && /* @__PURE__ */ jsx$1(Input, {
        style: {
          inputWrapper: styles$H.input
        },
        name: formatControllerName,
        value: get_1(values, formatControllerName, ""),
        onChange: changeHandler,
        type: "text",
        disabled: disableFormat
      })]
    })]
  });
}
var FormikColumnFormatField$1 = react.exports.memo(FormikColumnFormatField);
const styles$G = {
  container: {
    display: "flex"
  },
  label: {
    lineHeight: 2,
    userSelect: "none",
    flex: "2"
  },
  inputContainer: {
    flex: "4",
    display: "flex",
    justifyContent: "flex-start"
  },
  input: {
    height: "100%",
    width: "100px",
    borderRadius: "5px",
    border: "0.55px solid #c7c7c7",
    margin: "0px 5px 0px 5px",
    textAlign: "center"
  }
};
const NumberInput = react.exports.forwardRef(({
  label,
  name: name2,
  defaultValue = 0,
  style: style2 = {
    label: {},
    input: {},
    container: {},
    inputContainer: {}
  },
  onChange = () => null,
  onInput = () => null,
  pattern = "^d*(.d{0,2})?$",
  step = "any",
  min = "any",
  max: max2 = "any"
}, ref) => {
  const localRef = react.exports.useRef(null);
  const changeHander = react.exports.useCallback((e2) => {
    if (e2.target.checkValidity()) {
      const value = Number(e2.target.value === "" ? defaultValue : e2.target.value);
      onChange(__spreadProps(__spreadValues({}, e2), {
        target: __spreadProps(__spreadValues({}, e2.target), {
          name: e2.target.name,
          value
        })
      }));
    } else {
      const _ref = ref ? ref : localRef;
      _ref.current.value = Number(defaultValue);
    }
  }, [defaultValue, onChange, ref]);
  return /* @__PURE__ */ jsxs$1("div", {
    style: __spreadValues(__spreadValues({}, styles$G.container), style2.container),
    children: [/* @__PURE__ */ jsx$1("span", {
      style: __spreadValues(__spreadValues({}, styles$G.label), style2.label),
      children: label
    }), /* @__PURE__ */ jsx$1("div", {
      style: __spreadValues(__spreadValues({}, styles$G.inputContainer), style2.inputContainer),
      children: /* @__PURE__ */ jsx$1("input", {
        ref: ref ? ref : localRef,
        name: name2,
        style: __spreadValues(__spreadValues({}, styles$G.input), style2.input),
        type: "number",
        pattern,
        defaultValue,
        step,
        onChange: changeHander,
        onInput,
        min,
        max: max2
      }, defaultValue)
    })]
  });
});
function FormikNumberInput(props) {
  const _a = props, {
    label,
    name: name2
  } = _a, resProps = __objRest(_a, [
    "label",
    "name"
  ]);
  const {
    values,
    handleChange
  } = useFormikContext();
  const changeHandler = react.exports.useCallback((e2) => {
    handleChange(e2);
  }, [handleChange]);
  return /* @__PURE__ */ jsx$1(NumberInput, __spreadValues({
    label,
    name: name2,
    defaultValue: get_1(values, name2),
    onChange: changeHandler
  }, resProps));
}
function useNucleus() {
  const { tabActiveSpectrum } = useChartData();
  return react.exports.useMemo(() => {
    if (tabActiveSpectrum && Object.keys(tabActiveSpectrum).length > 0) {
      return Object.keys(tabActiveSpectrum);
    }
    return [];
  }, [tabActiveSpectrum]);
}
const styles$F = {
  container: {
    padding: 10,
    backgroundColor: "#f1f1f1",
    height: "100%",
    overflowY: "auto"
  },
  groupContainer: {
    padding: "5px",
    borderRadius: "5px",
    margin: "10px 0px",
    backgroundColor: "white"
  },
  row: {
    display: "flex",
    margin: "5px 0px"
  },
  header: {
    borderBottom: "1px solid #e8e8e8",
    paddingBottom: "5px",
    fontWeight: "bold",
    color: "#4a4a4a"
  },
  inputLabel: {
    flex: 2,
    fontSize: "11px",
    fontWeight: "bold",
    color: "#232323"
  },
  input: {
    width: "30%",
    textAlign: "center"
  }
};
const formatFields$3 = [{
  id: 1,
  label: "Absolute :",
  checkController: "showAbsolute",
  formatController: "absoluteFormat"
}, {
  id: 2,
  label: "Relative :",
  checkController: "showRelative",
  formatController: "relativeFormat"
}];
function IntegralsPreferencesInner({
  nucleus,
  preferences,
  innerRef
}) {
  const alert2 = useAlert();
  const formRef = react.exports.useRef();
  const updateValues = react.exports.useCallback(() => {
    if (nucleus) {
      const _a = integralDefaultValues, {
        color,
        strokeWidth
      } = _a, restProps = __objRest(_a, [
        "color",
        "strokeWidth"
      ]);
      const integralPreferences = getValue(preferences.current, `formatting.panels.integrals`);
      let defaultValues = nucleus.reduce((acc, nucleusLabel) => {
        acc[nucleusLabel] = restProps;
        return acc;
      }, {});
      defaultValues = Object.assign(defaultValues, {
        color,
        strokeWidth
      });
      formRef.current.setValues(integralPreferences ? integralPreferences : defaultValues);
    }
  }, [nucleus, preferences]);
  react.exports.useEffect(() => {
    updateValues();
  }, [updateValues]);
  const saveHandler = react.exports.useCallback((values) => {
    preferences.dispatch({
      type: "SET_PANELS_PREFERENCES",
      payload: {
        key: "integrals",
        value: values
      }
    });
    alert2.success("Integrals preferences saved successfully");
  }, [alert2, preferences]);
  react.exports.useImperativeHandle(innerRef, () => ({
    saveSetting: () => {
      formRef.current.submitForm();
    }
  }));
  return /* @__PURE__ */ jsx$1("div", {
    style: styles$F.container,
    children: /* @__PURE__ */ jsxs$1(FormikForm, {
      onSubmit: saveHandler,
      ref: formRef,
      children: [/* @__PURE__ */ jsxs$1("div", {
        style: styles$F.groupContainer,
        children: [/* @__PURE__ */ jsx$1("p", {
          style: styles$F.header,
          children: "General"
        }), /* @__PURE__ */ jsx$1(FormikColorInput, {
          name: "color"
        }), /* @__PURE__ */ jsx$1(FormikNumberInput, {
          name: "strokeWidth",
          label: "stroke width :",
          style: {
            label: {
              fontSize: "11px",
              fontWeight: "bold",
              color: "#232323"
            },
            input: {
              width: "60%",
              textAlign: "center",
              borderRadius: "5px"
            }
          },
          min: 1,
          max: 9,
          pattern: "[1-9]+"
        })]
      }), nucleus == null ? void 0 : nucleus.map((nucleusLabel) => /* @__PURE__ */ jsxs$1("div", {
        style: styles$F.groupContainer,
        children: [/* @__PURE__ */ jsx$1("p", {
          style: styles$F.header,
          children: /* @__PURE__ */ jsx$1(MF, {
            mf: nucleusLabel
          })
        }), formatFields$3.map((field) => /* @__PURE__ */ jsx$1(FormikColumnFormatField$1, {
          label: field.label,
          checkControllerName: `${nucleusLabel}.${field.checkController}`,
          formatControllerName: `${nucleusLabel}.${field.formatController}`
        }, field.id))]
      }, nucleusLabel))]
    })
  });
}
const MemoizedIntegralsPreferences = react.exports.memo(IntegralsPreferencesInner);
function IntegralsPreferences(props, ref) {
  const preferences = usePreferences();
  const nucleus = useNucleus();
  return /* @__PURE__ */ jsx$1(MemoizedIntegralsPreferences, {
    innerRef: ref,
    nucleus,
    preferences
  });
}
var IntegralsPreferences$1 = react.exports.forwardRef(IntegralsPreferences);
const style$7 = css`
  .sum-button {
    width: 22px;
    height: 22px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .fix-integral-toggle-btn {
    svg {
      font-size: 12px !important;
    }
  }
`;
function IntegralPanelInner({
  integrals,
  info,
  activeTab,
  xDomain,
  preferences
}) {
  var _a;
  const [filterIsActive, setFilterIsActive] = react.exports.useState(false);
  const dispatch = useDispatch();
  const modal = useModal();
  const [isFlipped, setFlipStatus] = react.exports.useState(false);
  const settingRef = react.exports.useRef();
  const yesHandler = react.exports.useCallback(() => {
    dispatch({
      type: DELETE_INTEGRAL,
      integralID: null
    });
  }, [dispatch]);
  const handleDeleteAll = react.exports.useCallback(() => {
    modal.showConfirmDialog({
      message: "All records will be deleted, Are You sure?",
      buttons: [{
        text: "Yes",
        handler: yesHandler
      }, {
        text: "No"
      }]
    });
  }, [modal, yesHandler]);
  const changeIntegralSumHandler = react.exports.useCallback((value) => {
    dispatch({
      type: CHANGE_INTEGRAL_SUM,
      value
    });
    modal.close();
  }, [dispatch, modal]);
  const currentSum = react.exports.useMemo(() => {
    return get_1(integrals, "options.sum", null);
  }, [integrals]);
  const showChangeIntegralSumModal = react.exports.useCallback(() => {
    modal.show(/* @__PURE__ */ jsx(ChangeSumModal, {
      onClose: () => modal.close(),
      onSave: changeIntegralSumHandler,
      header: currentSum ? `Set new Integrals Sum (Current: ${Number(currentSum).toFixed(2)})` : "Set new Integrals Sum",
      sumOptions: integrals == null ? void 0 : integrals.options
    }));
  }, [changeIntegralSumHandler, currentSum, integrals == null ? void 0 : integrals.options, modal]);
  const settingsPanelHandler = react.exports.useCallback(() => {
    setFlipStatus(!isFlipped);
  }, [isFlipped]);
  const saveSettingHandler = react.exports.useCallback(() => {
    settingRef.current.saveSetting();
    setFlipStatus(false);
  }, []);
  const handleOnFilter = react.exports.useCallback(() => {
    setFilterIsActive(!filterIsActive);
  }, [filterIsActive]);
  const toggleConstantSumHandler = react.exports.useCallback((flag) => {
    dispatch({
      type: CHANGE_INTEGRALS_SUM_FLAG,
      payload: flag
    });
  }, [dispatch]);
  const filteredData = react.exports.useMemo(() => {
    function isInRange(from, to) {
      const factor = 1e4;
      to = to * factor;
      from = from * factor;
      return to >= xDomain[0] * factor && from <= xDomain[1] * factor || from <= xDomain[0] * factor && to >= xDomain[1] * factor;
    }
    if (info.dimension === 1 && (integrals == null ? void 0 : integrals.values)) {
      const _integrals = filterIsActive ? integrals.values.filter((integral) => isInRange(integral.from, integral.to)) : integrals.values;
      return _integrals.map((integral) => {
        return __spreadProps(__spreadValues({}, integral), {
          isConstantlyHighlighted: isInRange(integral.from, integral.to)
        });
      });
    }
    return [];
  }, [filterIsActive, info.dimension, integrals, xDomain]);
  return /* @__PURE__ */ jsx(react.exports.Fragment, {
    children: /* @__PURE__ */ jsxs("div", {
      css: [tablePanelStyle, style$7, isFlipped && css`
              th {
                position: relative;
              }
            `],
      children: [!isFlipped && /* @__PURE__ */ jsxs(DefaultPanelHeader$1, {
        counter: (_a = integrals == null ? void 0 : integrals.values) == null ? void 0 : _a.length,
        onDelete: handleDeleteAll,
        deleteToolTip: "Delete All Integrals",
        onFilter: handleOnFilter,
        filterToolTip: filterIsActive ? "Show all integrals" : "Hide integrals out of view",
        filterIsActive,
        counterFiltered: filteredData.length,
        showSettingButton: true,
        onSettingClick: settingsPanelHandler,
        children: [/* @__PURE__ */ jsx(ToolTip$1, {
          title: currentSum ? `Change Integrals Sum (${Number(currentSum).toFixed(2)})` : "Change Integrals Sum",
          popupPlacement: "right",
          children: /* @__PURE__ */ jsx("button", {
            className: "sum-button",
            type: "button",
            onClick: showChangeIntegralSumModal,
            children: /* @__PURE__ */ jsx(SvgSum, {})
          })
        }), /* @__PURE__ */ jsx(ToggleButton$2, {
          className: "fix-integral-toggle-btn",
          popupTitle: "fix integral values",
          popupPlacement: "right",
          onClick: toggleConstantSumHandler,
          children: /* @__PURE__ */ jsx(ImLink, {})
        })]
      }), isFlipped && /* @__PURE__ */ jsx(PreferencesHeader$1, {
        onSave: saveSettingHandler,
        onClose: settingsPanelHandler
      }), /* @__PURE__ */ jsx("div", {
        className: "inner-container",
        children: !isFlipped ? /* @__PURE__ */ jsx(IntegralTable$1, {
          data: filteredData,
          activeTab,
          preferences
        }) : /* @__PURE__ */ jsx(IntegralsPreferences$1, {
          ref: settingRef
        })
      })]
    })
  });
}
const MemoizedIntegralPanel = react.exports.memo(IntegralPanelInner);
const emptyData$8 = {
  integrals: {},
  info: {}
};
function IntegralPanel() {
  const {
    xDomain,
    activeTab
  } = useChartData();
  const preferences = usePreferences();
  const {
    integrals,
    info
  } = useSpectrum(emptyData$8);
  return /* @__PURE__ */ jsx(MemoizedIntegralPanel, {
    integrals,
    info,
    preferences: preferences.current,
    xDomain,
    activeTab
  });
}
function Label(props) {
  const {
    title,
    className = "",
    children,
    style: style2
  } = props;
  return /* @__PURE__ */ jsxs$1("div", {
    style: {
      display: "flex",
      alignItems: "center"
    },
    children: [/* @__PURE__ */ jsx$1("span", {
      className,
      style: __spreadValues({
        fontSize: "11px",
        fontWeight: "bold",
        color: "#232323",
        paddingRight: "10px",
        width: "max-content"
      }, style2 == null ? void 0 : style2.label),
      children: title
    }), /* @__PURE__ */ jsx$1("div", {
      style: style2 == null ? void 0 : style2.wrapper,
      children
    })]
  });
}
const INITIAL_VALUE = {
  from: -1,
  to: 1,
  nbPoints: 1024
};
function ExportAsMatrixModal({
  onClose = () => null
}) {
  const refForm = react.exports.useRef();
  const {
    data
  } = useChartData();
  const handleSave = react.exports.useCallback(() => {
    refForm.current.submitForm();
  }, []);
  const submitHandler = react.exports.useCallback((options2) => {
    exportAsMatrix(data, options2, "fileName");
    onClose();
  }, [data, onClose]);
  react.exports.useEffect(() => {
    function handler(event) {
      const [from, to] = event.range;
      refForm.current.setValues(__spreadProps(__spreadValues({}, refForm.current.values), {
        from,
        to
      }));
    }
    Emitter.on("brushEnd", handler);
    return () => {
      Emitter.off("brushEnd", handler);
    };
  }, []);
  return /* @__PURE__ */ jsxs("div", {
    css: ModalStyles,
    children: [/* @__PURE__ */ jsxs("div", {
      className: "header handle",
      children: [/* @__PURE__ */ jsx("span", {
        children: "Export spectra as a Matrix"
      }), /* @__PURE__ */ jsx(CloseButton$1, {
        onClick: onClose,
        className: "close-bt"
      })]
    }), /* @__PURE__ */ jsx("div", {
      className: "inner-content",
      children: /* @__PURE__ */ jsxs(FormikForm, {
        ref: refForm,
        initialValues: INITIAL_VALUE,
        onSubmit: submitHandler,
        children: [/* @__PURE__ */ jsxs("div", {
          className: "row margin-10",
          children: [/* @__PURE__ */ jsx("span", {
            className: "custom-label",
            children: "Range :"
          }), /* @__PURE__ */ jsx(Label, {
            title: "From : ",
            children: /* @__PURE__ */ jsx(FormikInput, {
              name: "from",
              type: "number"
            })
          }), /* @__PURE__ */ jsx(Label, {
            title: "To : ",
            children: /* @__PURE__ */ jsx(FormikInput, {
              name: "to",
              type: "number"
            })
          })]
        }), /* @__PURE__ */ jsx("div", {
          className: "row margin-10",
          children: /* @__PURE__ */ jsx(Label, {
            title: "Number of Points :",
            className: "custom-label",
            children: /* @__PURE__ */ jsx(FormikInput, {
              name: "nbPoints",
              type: "number"
            })
          })
        })]
      })
    }), /* @__PURE__ */ jsx("div", {
      className: "footer-container",
      children: /* @__PURE__ */ jsx(Button.Done, {
        onClick: handleSave,
        children: "Export Now"
      })
    })]
  });
}
function EquallySpacedFilter({
  onSubmit
}, ref) {
  const {
    xDomain
  } = useChartData();
  return /* @__PURE__ */ jsxs$1(FormikForm, {
    ref,
    initialValues: {
      from: xDomain[0],
      to: xDomain[1],
      numberOfPoints: 1024
    },
    onSubmit,
    children: [/* @__PURE__ */ jsxs$1("div", {
      className: "row margin-10",
      children: [/* @__PURE__ */ jsx$1("span", {
        className: "custom-label",
        children: "Range :"
      }), /* @__PURE__ */ jsx$1(Label, {
        title: "From : ",
        children: /* @__PURE__ */ jsx$1(FormikInput, {
          name: "from",
          type: "number"
        })
      }), /* @__PURE__ */ jsx$1(Label, {
        title: "To : ",
        children: /* @__PURE__ */ jsx$1(FormikInput, {
          name: "to",
          type: "number"
        })
      })]
    }), /* @__PURE__ */ jsx$1("div", {
      className: "row margin-10",
      children: /* @__PURE__ */ jsx$1(Label, {
        className: "custom-label",
        title: "Number of points : ",
        children: /* @__PURE__ */ jsx$1(FormikInput, {
          name: "numberOfPoints",
          type: "number"
        })
      })
    })]
  });
}
var EquallySpacedFilter$1 = react.exports.forwardRef(EquallySpacedFilter);
function FromToFilter({
  onSubmit
}, ref) {
  const {
    xDomain
  } = useChartData();
  return /* @__PURE__ */ jsx$1(FormikForm, {
    ref,
    initialValues: {
      from: xDomain[0],
      to: xDomain[1]
    },
    onSubmit,
    children: /* @__PURE__ */ jsxs$1("div", {
      className: "row margin-10",
      children: [/* @__PURE__ */ jsx$1("span", {
        className: "custom-label",
        children: "Range :"
      }), /* @__PURE__ */ jsx$1(Label, {
        title: "From :",
        children: /* @__PURE__ */ jsx$1(FormikInput, {
          name: "from",
          type: "number"
        })
      }), /* @__PURE__ */ jsx$1(Label, {
        title: "To :",
        children: /* @__PURE__ */ jsx$1(FormikInput, {
          name: "to",
          type: "number"
        })
      })]
    })
  });
}
var FromToFilter$1 = react.exports.forwardRef(FromToFilter);
const baseList$1 = [{
  key: 0,
  value: 0,
  label: "Select Filter"
}, {
  key: id$8,
  value: id$8,
  label: name$8
}, {
  key: id$b,
  value: id$b,
  label: name$b
}, {
  key: id$3,
  value: id$3,
  label: name$3
}, {
  key: id$d,
  value: id$d,
  label: name$d
}, {
  key: id$6,
  value: id$6,
  label: name$6
}];
const styles$E = css`
  .row {
    align-items: center;
  }

  .container {
    flex: 1;
  }

  .infoText {
    padding: 10px;
    font-size: 12px;
    text-align: left;
    color: white;
    background-color: #5f5f5f;
    border-radius: 5px;
  }
`;
function MultipleSpectraFiltersModal({
  onClose = () => null,
  nucleus = ""
}) {
  const refForm = react.exports.useRef();
  const dispatch = useDispatch();
  const [filter2, setFilter] = react.exports.useState("");
  const List = react.exports.useMemo(() => {
    const list = REFERENCES[nucleus] ? Object.entries(REFERENCES[nucleus]).map((item) => ({
      key: item[0],
      value: item[0],
      label: item[0]
    }), []) : [];
    return baseList$1.concat(list);
  }, [nucleus]);
  const handleSave = react.exports.useCallback((e2) => {
    e2.preventDefault();
    if (refForm.current) {
      refForm.current.submitForm();
    }
  }, []);
  const submitHandler = react.exports.useCallback((options2) => {
    if (options2) {
      dispatch({
        type: APPLY_MULTIPLE_SPECTRA_FILTER,
        payload: [{
          name: filter2,
          options: options2
        }]
      });
      onClose();
    }
  }, [dispatch, filter2, onClose]);
  react.exports.useEffect(() => {
    function handle(event) {
      const [from, to] = event.range;
      if (refForm.current) {
        refForm.current.setValues(__spreadProps(__spreadValues({}, refForm.current.values), {
          from,
          to
        }));
      }
    }
    Emitter.on("brushEnd", handle);
    return () => {
      Emitter.off("brushEnd", handle);
    };
  }, []);
  const filterChangeHandler = react.exports.useCallback((id2) => {
    setFilter(id2);
  }, []);
  const filterOptions = react.exports.useMemo(() => {
    switch (filter2) {
      case id$8:
        return /* @__PURE__ */ jsx(FromToFilter$1, {
          onSubmit: submitHandler,
          ref: refForm
        });
      case id$b:
        return /* @__PURE__ */ jsx(EquallySpacedFilter$1, {
          onSubmit: submitHandler,
          ref: refForm
        });
    }
  }, [filter2, submitHandler]);
  return /* @__PURE__ */ jsxs("div", {
    css: [ModalStyles, styles$E],
    children: [/* @__PURE__ */ jsxs("div", {
      className: "header handle",
      children: [/* @__PURE__ */ jsx("span", {
        children: "Apply filters"
      }), /* @__PURE__ */ jsx(CloseButton$1, {
        onClick: onClose,
        className: "close-bt"
      })]
    }), /* @__PURE__ */ jsxs("div", {
      className: "inner-content container",
      children: [/* @__PURE__ */ jsx("p", {
        className: "infoText",
        children: "This filter will use the exclusions zones defined in the first spectrum."
      }), /* @__PURE__ */ jsxs("div", {
        className: "row margin-10",
        children: [/* @__PURE__ */ jsx("span", {
          className: "custom-label",
          children: "Filter :"
        }), /* @__PURE__ */ jsx(Select, {
          data: List,
          style: {
            width: 275,
            height: 30,
            margin: 0
          },
          onChange: filterChangeHandler
        })]
      }), filterOptions]
    }), /* @__PURE__ */ jsx("div", {
      className: "footer-container",
      children: /* @__PURE__ */ jsx(ActionButtons, {
        style: {
          flexDirection: "row-reverse",
          margin: 0
        },
        onDone: handleSave,
        doneLabel: "Save",
        onCancel: onClose,
        cancelLabel: "Close"
      })
    })]
  });
}
function MatrixGenerationPanel() {
  const modal = useModal();
  const dispatch = useDispatch();
  const openFiltersModal = react.exports.useCallback(() => {
    dispatch({
      type: RESET_SELECTED_TOOL
    });
    modal.show(/* @__PURE__ */ jsx(MultipleSpectraFiltersModal, {}), {
      isBackgroundBlur: false,
      position: positions.TOP_CENTER,
      width: 550,
      height: 250
    });
  }, [modal, dispatch]);
  const openExportAsMatrixModal = react.exports.useCallback(() => {
    dispatch({
      type: RESET_SELECTED_TOOL
    });
    modal.show(/* @__PURE__ */ jsx(ExportAsMatrixModal, {}), {
      isBackgroundBlur: false,
      position: positions.TOP_CENTER,
      width: 500
    });
  }, [modal, dispatch]);
  return /* @__PURE__ */ jsxs("div", {
    css: tablePanelStyle,
    children: [/* @__PURE__ */ jsxs(DefaultPanelHeader$1, {
      deleteToolTip: "Delete All Peaks",
      showSettingButton: true,
      canDelete: false,
      children: [/* @__PURE__ */ jsx(ButtonToolTip, {
        popupTitle: "Add Filter",
        onClick: openFiltersModal,
        children: /* @__PURE__ */ jsx(SvgAddFilter, {
          style: {
            fontSize: "18px"
          }
        })
      }), /* @__PURE__ */ jsx(ButtonToolTip, {
        popupTitle: "Export spectra as a Matrix",
        onClick: openExportAsMatrixModal,
        children: /* @__PURE__ */ jsx(SvgExportAsMatrix, {})
      })]
    }), /* @__PURE__ */ jsx("div", {
      className: "inner-container"
    })]
  });
}
function MoleculeStructureEditorModal(props) {
  const {
    onClose = () => null,
    selectedMolecule
  } = props;
  const [molfile, setMolfile2] = react.exports.useState(null);
  const dispatch = useDispatch();
  react.exports.useEffect(() => {
    if (selectedMolecule) {
      setMolfile2(selectedMolecule.molfile);
    } else {
      setMolfile2(null);
    }
  }, [selectedMolecule]);
  const cb = react.exports.useCallback((newMolfile) => {
    var _a, _b;
    const molText = (_b = (_a = /(?<s>M {2}V30 BEGIN BOND)(?<mol>.*?)(?<e>M {2}V30 END BOND)/gs.exec(newMolfile)) == null ? void 0 : _a.groups) == null ? void 0 : _b.mol;
    setMolfile2((molText == null ? void 0 : molText.trim()) ? newMolfile : null);
  }, [setMolfile2]);
  const handleClose = react.exports.useCallback(() => {
    onClose();
  }, [onClose]);
  const handleSave = react.exports.useCallback(() => {
    if (selectedMolecule) {
      dispatch({
        type: SET_MOLECULE,
        molfile,
        key: selectedMolecule.key
      });
      onClose("replace");
    } else {
      dispatch({
        type: ADD_MOLECULE,
        molfile
      });
      onClose("new");
    }
  }, [dispatch, selectedMolecule, molfile, onClose]);
  return /* @__PURE__ */ jsxs("div", {
    css: ModalStyles,
    children: [/* @__PURE__ */ jsx(StructureEditor, {
      initialMolfile: selectedMolecule == null ? void 0 : selectedMolecule.molfile,
      svgMenu: true,
      fragment: false,
      onChange: cb
    }), /* @__PURE__ */ jsx("div", {
      className: "footer-container",
      children: /* @__PURE__ */ jsx(ActionButtons, {
        style: {
          flexDirection: "row-reverse",
          margin: 0
        },
        onDone: handleSave,
        doneLabel: "Save",
        onCancel: handleClose
      })
    })]
  });
}
const menuStyles$1 = css`
  .menu {
    box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5);
    padding: 0px;
    margin: 0px;
    border-radius: 5px;
    display: flex;
    flex-direction: column;
    position: absolute;
    z-index: 99999;
    padding: 2px;
    background-color: white;

    button:hover {
      background-color: #fafafa;
    }
  }

  .menu-cover {
    position: fixed;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    z-index: 1;
  }

  .menu-item {
    background-color: transparent;
    border: none;
    border-bottom: 0.55px solid whitesmoke;
    height: 35px;
    outline: outline;
    display: table-cell;
    vertical-align: middle;
    text-align: left;
    padding: 0 10px;

    svg {
      display: inline-block;
    }

    :focus {
      outline: none !important;
    }
    span {
      font-size: 10px;
      padding: 0px 10px;
    }
  }
`;
function MenuItem$1({
  icon,
  label,
  onClick
}) {
  return /* @__PURE__ */ jsxs("button", {
    type: "button",
    className: "menu-item",
    onClick,
    children: [icon, /* @__PURE__ */ jsx("span", {
      children: label
    })]
  });
}
function MenuList$1({
  items,
  boxBounding,
  onClick
}) {
  return /* @__PURE__ */ jsx("div", {
    className: "menu",
    style: {
      transform: `translate(${boxBounding.width}px, -${boxBounding.height}px) `
    },
    children: items == null ? void 0 : items.map((item) => {
      return /* @__PURE__ */ jsx(MenuItem$1, __spreadProps(__spreadValues({}, item), {
        onClick: () => onClick(item)
      }), item.id);
    })
  });
}
function MenuButton({
  style: style2,
  component,
  toolTip = "",
  className,
  items = [],
  onClick = () => null
}) {
  var _a;
  const menuButtonRef = react.exports.useRef(null);
  const [isShown, showMenu] = react.exports.useState(false);
  const closeMenuButton = react.exports.useCallback(() => {
    showMenu(false);
  }, []);
  const handleClick = react.exports.useCallback(() => {
    showMenu((flag) => !flag);
  }, []);
  const clickHandler = react.exports.useCallback((e2) => {
    showMenu(false);
    onClick(e2);
  }, [onClick]);
  return /* @__PURE__ */ jsxs("div", {
    style: {
      height: "auto"
    },
    css: menuStyles$1,
    children: [/* @__PURE__ */ jsx("button", {
      ref: menuButtonRef,
      type: "button",
      css: style2,
      onClick: handleClick,
      className,
      style: {
        boxSizing: "border-box"
      },
      children: /* @__PURE__ */ jsx(ToolTip$1, {
        title: toolTip,
        popupPlacement: "right",
        children: component
      })
    }), isShown && /* @__PURE__ */ jsx(MenuList$1, {
      items,
      boxBounding: (_a = menuButtonRef.current) == null ? void 0 : _a.getBoundingClientRect(),
      onClick: clickHandler
    }), isShown && /* @__PURE__ */ jsx("div", {
      className: "menu-cover",
      onClick: closeMenuButton
    })]
  });
}
function generateNumbersPowerOfX(start, end, options2) {
  const { power = 2, format: format2 = formatNumber } = options2 || {};
  let values = [];
  for (let i = start; i <= end; i++) {
    const result = power ** i;
    values.push({
      key: result,
      label: format2(result),
      value: result
    });
  }
  return values;
}
function formatNumber(number) {
  if (number >= 1024 * 1024) {
    return `${number / (1024 * 1024)}M`;
  } else if (number >= 1024) {
    return `${number / 1024}K`;
  } else {
    return number;
  }
}
function IsotopesViewer(_k) {
  var _l = _k, {
    value = ""
  } = _l, othersProps = __objRest(_l, [
    "value"
  ]);
  return /* @__PURE__ */ jsx$1("div", __spreadProps(__spreadValues({}, othersProps), {
    dangerouslySetInnerHTML: {
      __html: value.replace(/(?<isotope>[0-9]+)/g, "<sup>$<isotope></sup>")
    }
  }));
}
const styles$D = {
  container: {
    backgroundColor: "#fd000c",
    borderRadius: "5px",
    padding: "0.4rem"
  },
  text: {
    color: "white",
    margin: "0.5px",
    fontSize: "0.9em",
    listStyle: "inside"
  }
};
const getErrors = (errorObj) => {
  const result = [];
  function errorsIterators(obj) {
    Object.keys(obj).forEach((key) => {
      if (typeof obj[key] === "object") {
        errorsIterators(obj[key]);
      } else {
        result.push(obj[key]);
      }
    });
  }
  errorsIterators(errorObj);
  return result;
};
function FormikErrorsSummary({
  style: style2
}) {
  const {
    errors,
    isValid
  } = useFormikContext();
  const errorList = react.exports.useMemo(() => {
    return getErrors(errors);
  }, [errors]);
  if (isValid)
    return /* @__PURE__ */ jsx$1("div", {});
  return /* @__PURE__ */ jsx$1("ul", {
    style: __spreadValues(__spreadValues({}, styles$D.container), style2 == null ? void 0 : style2.container),
    children: errorList.map((errorText, index2) => {
      return /* @__PURE__ */ jsx$1("li", {
        style: __spreadValues(__spreadValues({}, styles$D.text), style2 == null ? void 0 : style2.text),
        children: errorText
      }, index2);
    })
  });
}
const FormikSelect = function FormikSelect2(props) {
  const _a = props, {
    name: name2 = "",
    value,
    onChange = () => null
  } = _a, resProps = __objRest(_a, [
    "name",
    "value",
    "onChange"
  ]);
  const {
    values,
    setFieldValue
  } = useFormikContext();
  const changeHandler = react.exports.useCallback((value2) => {
    onChange(value2);
    setFieldValue(name2, value2);
  }, [name2, onChange, setFieldValue]);
  react.exports.useEffect(() => {
    if (value) {
      setFieldValue(name2, value);
    }
  }, [name2, setFieldValue, value]);
  return /* @__PURE__ */ jsx$1(Select, __spreadValues({
    name: name2,
    defaultValue: value ? value : get_1(values, name2),
    onChange: changeHandler
  }, resProps));
};
const styles$C = css`
  .row {
    align-items: center;
  }

  .inner-content {
    flex: 1;
  }

  .custom-label {
    width: 160px;
    font-weight: 500;
  }

  .nucleus-label {
    padding: 0 10px;
    color: black;
    font-weight: 700;

    &.disabled {
      opacity: 0.5;
      color: black;
    }
  }
  .warning {
    color: #c40000;
    font-weight: bold;
    font-size: 13px;
    text-align: justify;
    margin-top: 30px;
  }

  .warning-container {
    margin-top: 5px;
    display: flex;
    input {
      margin: 5px 5px 5px 0;
    }
  }

  .middle-x {
    padding: 0 10px;
  }

  .group-label {
    width: 100%;
    display: block;
    border-bottom: 1px solid #efefef;
    padding-bottom: 5px;
    font-weight: 600;
    color: #005d9e;
  }
`;
const NUMBER_OF_POINTS_1D = generateNumbersPowerOfX(12, 19);
const NUMBER_OF_POINTS_2D = generateNumbersPowerOfX(10, 10, {
  format: (value) => value
});
const predictionFormValidation$1 = create().shape({
  name: create$2().required().label("Name"),
  frequency: create$1().integer().required().label("Frequency"),
  "1d": create({
    "1H": create({
      from: create$1().integer().required().label("1H ' From ' "),
      to: create$1().integer().required().label("1H ' To ' ")
    }),
    "13C": create().shape({
      from: create$1().integer().required().label("13C ' From ' "),
      to: create$1().integer().required().label("13C ' To ' ")
    }),
    lineWidth: create$1().integer().min(1).required().label("Line Width"),
    nbPoints: create$1().integer().required().label("1D Number Of Points")
  }),
  "2d": create({
    nbPoints: create({
      x: create$1().integer().required().label("2D Number Of Points"),
      y: create$1().integer().required().label("2D Number Of Points")
    })
  }),
  spectra: create({
    proton: create$3(),
    carbon: create$3(),
    cosy: create$3(),
    hsqc: create$3(),
    hmbc: create$3()
  }).test("check-options", "You must check one of the options to start prediction", (obj) => {
    if (Object.values(obj).includes(true)) {
      return true;
    }
    return false;
  })
});
function PredictSpectraModal({
  onClose = () => null,
  molfile
}) {
  const refForm = react.exports.useRef();
  const dispatch = useDispatch();
  const alert2 = useAlert();
  const [isApproved, setApproved] = react.exports.useState(false);
  const [predictionPreferences, setPredictionPreferences] = useStateWithLocalStorage("nmrium-prediction-preferences");
  const {
    toolOptions: {
      data: {
        predictionIndex
      }
    }
  } = useChartData();
  const handleSave = react.exports.useCallback(() => {
    refForm.current.submitForm();
  }, []);
  const initValues = react.exports.useMemo(() => {
    const _a = predictionPreferences, {
      isApproved: isAgree
    } = _a, options2 = __objRest(_a, [
      "isApproved"
    ]);
    setApproved(isAgree);
    return Object.assign(defaultPredictionOptions, options2, {
      name: `Prediction ${predictionIndex + 1}`
    });
  }, [predictionPreferences, predictionIndex]);
  const submitHandler = react.exports.useCallback((values) => {
    void (async () => {
      setPredictionPreferences(__spreadProps(__spreadValues({}, values), {
        isApproved
      }));
      dispatch({
        type: SET_LOADING_FLAG,
        isLoading: true
      });
      const predictedSpectra = Object.entries(values.spectra).reduce((acc, [key, value]) => {
        if (value) {
          acc.push(key);
        }
        return acc;
      }, []).join(" , ");
      const hideLoading = await alert2.showLoading(`Predict ${predictedSpectra} in progress`);
      dispatch({
        type: PREDICT_SPECTRA,
        payload: {
          mol: molfile,
          options: values
        }
      });
      hideLoading();
      onClose();
    })();
  }, [alert2, dispatch, isApproved, molfile, onClose, setPredictionPreferences]);
  const approveCheckHandler = react.exports.useCallback((e2) => {
    setApproved(e2.target.checked);
  }, []);
  return /* @__PURE__ */ jsxs("div", {
    css: [ModalStyles, styles$C],
    children: [/* @__PURE__ */ jsxs("div", {
      className: "header handle",
      children: [/* @__PURE__ */ jsx("span", {
        children: "Prediction of NMR spectrum"
      }), /* @__PURE__ */ jsx(CloseButton$1, {
        onClick: onClose,
        className: "close-bt"
      })]
    }), /* @__PURE__ */ jsxs("div", {
      className: "inner-content",
      children: [/* @__PURE__ */ jsxs(FormikForm, {
        ref: refForm,
        initialValues: initValues,
        validationSchema: predictionFormValidation$1,
        onSubmit: submitHandler,
        children: [/* @__PURE__ */ jsx(FormikErrorsSummary, {}), /* @__PURE__ */ jsxs("div", {
          className: "row margin-10",
          children: [/* @__PURE__ */ jsx("span", {
            className: "custom-label",
            children: "Name :"
          }), /* @__PURE__ */ jsx(FormikInput, {
            name: "name",
            style: {
              input: {
                width: "200px",
                textAlign: "left"
              }
            }
          })]
        }), /* @__PURE__ */ jsxs("div", {
          className: "row margin-10",
          children: [/* @__PURE__ */ jsx("span", {
            className: "custom-label",
            children: "Spectrometer Frequency :"
          }), /* @__PURE__ */ jsx(FormikSelect, {
            data: FREQUENCIES,
            style: {
              width: 290,
              height: 30,
              margin: 0
            },
            name: "frequency"
          })]
        }), /* @__PURE__ */ jsx("span", {
          className: "group-label",
          children: "1D Options "
        }), /* @__PURE__ */ jsxs("div", {
          className: "row margin-10 padding-h-10",
          children: [/* @__PURE__ */ jsx(IsotopesViewer, {
            value: "1H",
            className: "custom-label"
          }), /* @__PURE__ */ jsx(Label, {
            title: "From",
            children: /* @__PURE__ */ jsx(FormikInput, {
              name: "1d.1H.from",
              type: "number"
            })
          }), /* @__PURE__ */ jsx(Label, {
            title: "To",
            style: {
              label: {
                padding: "0 10px"
              }
            },
            children: /* @__PURE__ */ jsx(FormikInput, {
              name: "1d.1H.to",
              type: "number"
            })
          })]
        }), /* @__PURE__ */ jsxs("div", {
          className: "row margin-10 padding-h-10",
          children: [/* @__PURE__ */ jsx(IsotopesViewer, {
            value: "13C",
            className: "custom-label"
          }), /* @__PURE__ */ jsx(Label, {
            title: "From",
            children: /* @__PURE__ */ jsx(FormikInput, {
              name: "1d.13C.from",
              type: "number"
            })
          }), /* @__PURE__ */ jsx(Label, {
            title: "To",
            style: {
              label: {
                padding: "0 10px"
              }
            },
            children: /* @__PURE__ */ jsx(FormikInput, {
              name: "1d.13C.to",
              type: "number"
            })
          })]
        }), /* @__PURE__ */ jsxs("div", {
          className: "row margin-10 padding-h-10",
          children: [/* @__PURE__ */ jsx("span", {
            className: "custom-label",
            children: "Line Width : "
          }), /* @__PURE__ */ jsx(FormikInput, {
            name: "1d.lineWidth",
            type: "number",
            style: {
              input: {
                margin: 0
              }
            }
          }), /* @__PURE__ */ jsx("span", {
            style: {
              paddingLeft: "0.4rem"
            },
            children: " Hz "
          })]
        }), /* @__PURE__ */ jsxs("div", {
          className: "row margin-10 padding-h-10",
          children: [/* @__PURE__ */ jsx("span", {
            className: "custom-label",
            children: "Number of Points : "
          }), /* @__PURE__ */ jsx(FormikSelect, {
            data: NUMBER_OF_POINTS_1D,
            name: "1d.nbPoints",
            style: {
              width: 290,
              height: 30,
              margin: 0
            }
          })]
        }), /* @__PURE__ */ jsx("span", {
          className: "group-label",
          children: "2D Options "
        }), /* @__PURE__ */ jsxs("div", {
          className: "row margin-10 padding-h-10",
          children: [/* @__PURE__ */ jsx("span", {
            className: "custom-label",
            children: "Number of Points : "
          }), /* @__PURE__ */ jsx(FormikSelect, {
            data: NUMBER_OF_POINTS_2D,
            name: "2d.nbPoints.x",
            style: {
              margin: 0,
              height: 30
            }
          }), /* @__PURE__ */ jsx("span", {
            className: "middle-x",
            children: " X "
          }), /* @__PURE__ */ jsx(FormikSelect, {
            data: NUMBER_OF_POINTS_2D,
            name: "2d.nbPoints.y",
            style: {
              margin: 0,
              height: 30
            }
          })]
        }), /* @__PURE__ */ jsx("div", {
          className: "row margin-10",
          children: /* @__PURE__ */ jsx("span", {
            className: "group-label",
            children: "Spectra "
          })
        }), /* @__PURE__ */ jsxs("div", {
          className: "row margin-10 padding-h-10",
          style: {
            justifyContent: "space-between"
          },
          children: [/* @__PURE__ */ jsxs("div", {
            className: "row",
            children: [/* @__PURE__ */ jsx(FormikCheckBox, {
              name: "spectra.proton"
            }), /* @__PURE__ */ jsx(IsotopesViewer, {
              value: "1H",
              className: "nucleus-label"
            })]
          }), /* @__PURE__ */ jsxs("div", {
            className: "row",
            children: [/* @__PURE__ */ jsx(FormikCheckBox, {
              name: "spectra.carbon"
            }), /* @__PURE__ */ jsx(IsotopesViewer, {
              value: "13C",
              className: "nucleus-label"
            })]
          }), /* @__PURE__ */ jsxs("div", {
            className: "row",
            children: [/* @__PURE__ */ jsx(FormikCheckBox, {
              name: "spectra.cosy"
            }), /* @__PURE__ */ jsx(IsotopesViewer, {
              value: "COSY",
              className: "nucleus-label"
            })]
          }), /* @__PURE__ */ jsxs("div", {
            className: "row",
            children: [/* @__PURE__ */ jsx(FormikCheckBox, {
              name: "spectra.hsqc"
            }), /* @__PURE__ */ jsx(IsotopesViewer, {
              value: "HSQC",
              className: "nucleus-label"
            })]
          }), /* @__PURE__ */ jsxs("div", {
            className: "row",
            children: [/* @__PURE__ */ jsx(FormikCheckBox, {
              name: "spectra.hmbc"
            }), /* @__PURE__ */ jsx(IsotopesViewer, {
              value: "HMBC",
              className: "nucleus-label"
            })]
          })]
        })]
      }), /* @__PURE__ */ jsx("p", {
        className: "warning",
        children: "In order to predict spectra we are calling an external service and the chemical structure will leave your browser! You should never predict spectra for confidential molecules."
      }), /* @__PURE__ */ jsxs("div", {
        className: "warning-container",
        children: [/* @__PURE__ */ jsx(CheckBox, {
          onChange: approveCheckHandler,
          checked: isApproved
        }, String(isApproved)), /* @__PURE__ */ jsx("p", {
          children: "I confirm that the chemical structure is not confidential."
        })]
      })]
    }), /* @__PURE__ */ jsx("div", {
      className: "footer-container",
      children: /* @__PURE__ */ jsx(Button.Done, {
        onClick: handleSave,
        disabled: !isApproved,
        children: "Predict spectrum"
      })
    })]
  });
}
const toolbarStyle = css`
  display: flex;
  flex-direction: row;
  border-bottom: 0.55px solid rgb(240, 240, 240);
  padding: 0px 5px;

  button svg {
    fill: #4e4e4e;
  }

  button {
    background-color: transparent;
    border: none;
    padding: 5px;
  }

  p {
    margin: 0;
    text-align: right;
    width: 100%;
    line-height: 22px;
    padding: 0px 10px;
  }
`;
const MOL_EXPORT_MENU = [{
  id: "molfile",
  icon: /* @__PURE__ */ jsx(FaCopy, {}),
  label: "Copy as molfile"
}, {
  id: "png",
  icon: /* @__PURE__ */ jsx(FaFileImage, {}),
  label: "Copy as PNG"
}, {
  id: "svg",
  icon: /* @__PURE__ */ jsx(FaDownload, {}),
  label: "Export as SVG"
}];
function MoleculePanelHeader({
  currentIndex,
  molecules,
  onMoleculeIndexChange = () => null,
  onOpenMoleculeEditor = () => null,
  actionsOptions = {}
}) {
  const {
    rootRef
  } = useGlobal();
  const alert2 = useAlert();
  const dispatch = useDispatch();
  const modal = useModal();
  const assignmentData = useAssignmentData();
  const saveAsSVGHandler = react.exports.useCallback(() => {
    if (!rootRef)
      return;
    exportAsSVG(rootRef, `molSVG${currentIndex}`, "molFile");
  }, [rootRef, currentIndex]);
  const saveAsPNGHandler = react.exports.useCallback(() => {
    if (!rootRef)
      return;
    copyPNGToClipboard(rootRef, `molSVG${currentIndex}`);
    alert2.success("MOL copied as PNG to clipboard");
  }, [rootRef, alert2, currentIndex]);
  const saveAsMolHandler = react.exports.useCallback(() => {
    if (molecules[currentIndex]) {
      void copyTextToClipboard(molecules[currentIndex].molfile).then((flag) => {
        if (flag) {
          alert2.success("MOLFile copied to clipboard");
        } else {
          alert2.error("copied not completed");
        }
      });
    }
  }, [alert2, currentIndex, molecules]);
  const exportHandler = react.exports.useCallback(({
    id: id2
  }) => {
    switch (id2) {
      case "molfile":
        saveAsMolHandler();
        break;
      case "png":
        saveAsPNGHandler();
        break;
      case "svg":
        saveAsSVGHandler();
        break;
    }
  }, [saveAsMolHandler, saveAsPNGHandler, saveAsSVGHandler]);
  const handlePaste = react.exports.useCallback(() => {
    void navigator.clipboard.readText().then((molfile) => {
      dispatch({
        type: ADD_MOLECULE,
        molfile
      });
    });
  }, [dispatch]);
  const handleDelete = react.exports.useCallback(() => {
    var _a;
    if ((_a = molecules[currentIndex]) == null ? void 0 : _a.key) {
      onMoleculeIndexChange(0);
      dispatch({
        type: DELETE_MOLECULE,
        payload: {
          key: molecules[currentIndex].key,
          assignmentData
        }
      });
    }
  }, [molecules, currentIndex, onMoleculeIndexChange, dispatch, assignmentData]);
  const openPredictSpectraModal = react.exports.useCallback(() => {
    modal.show(/* @__PURE__ */ jsx(PredictSpectraModal, {
      molfile: molecules[currentIndex]
    }), {
      position: positions.TOP_CENTER,
      enableResizing: true,
      width: 600
    });
  }, [modal, molecules, currentIndex]);
  const floatMoleculeHandler = react.exports.useCallback(() => {
    dispatch({
      type: FLOAT_MOLECULE_OVER_SPECTRUM,
      payload: {
        key: molecules[currentIndex].key
      }
    });
  }, [currentIndex, dispatch, molecules]);
  return /* @__PURE__ */ jsxs("div", {
    css: toolbarStyle,
    children: [!actionsOptions.hideExport && /* @__PURE__ */ jsx(MenuButton, {
      component: /* @__PURE__ */ jsx(FaFileExport, {}),
      toolTip: "Export As",
      items: MOL_EXPORT_MENU,
      onClick: exportHandler
    }), !actionsOptions.hidePast && /* @__PURE__ */ jsx(ToolTip$1, {
      title: "Paste molfile",
      popupPlacement: "left",
      children: /* @__PURE__ */ jsx("button", {
        className: "bar-button",
        type: "button",
        onClick: handlePaste,
        children: /* @__PURE__ */ jsx(FaPaste, {})
      })
    }), !actionsOptions.hideAdd && /* @__PURE__ */ jsx(ToolTip$1, {
      title: "Add Molecule",
      popupPlacement: "left",
      children: /* @__PURE__ */ jsx("button", {
        className: "bar-button",
        type: "button",
        onClick: onOpenMoleculeEditor,
        "data-test-id": "panel-structures-button-add",
        children: /* @__PURE__ */ jsx(FaPlus, {})
      })
    }), !actionsOptions.hideDelete && /* @__PURE__ */ jsx(ToolTip$1, {
      title: "Delete Molecule",
      popupPlacement: "left",
      children: /* @__PURE__ */ jsx("button", {
        className: "bar-button",
        type: "button",
        onClick: handleDelete,
        children: /* @__PURE__ */ jsx(FaRegTrashAlt, {})
      })
    }), !actionsOptions.hidePredict && molecules && molecules.length > 0 && /* @__PURE__ */ jsx(ButtonToolTip, {
      popupTitle: "Predict Spectra",
      popupPlacement: "left",
      onClick: openPredictSpectraModal,
      children: /* @__PURE__ */ jsx(SvgFt, {})
    }), (molecules == null ? void 0 : molecules[currentIndex]) && /* @__PURE__ */ jsx(ToggleButton$2, {
      defaultValue: molecules[currentIndex].isFloat,
      popupTitle: "Float Molecule",
      popupPlacement: "left",
      onClick: floatMoleculeHandler,
      children: /* @__PURE__ */ jsx(IoOpenOutline, {})
    }, molecules[currentIndex].isFloat), /* @__PURE__ */ jsxs("p", {
      children: [molecules && molecules.length > 0 && `${+(currentIndex + 1)} / ${molecules.length}`, " "]
    })]
  });
}
const styles$B = {
  panel: css({
    display: "flex",
    overflow: "auto",
    flexGrow: 1,
    width: "100%",
    height: "100%",
    flexDirection: "column"
  }),
  innerPanel: css({
    display: "flex",
    flex: "1",
    flexDirection: "column",
    overflow: "auto"
  }),
  molecule: css({
    display: "flex",
    flex: "1"
  }),
  toolbar: css({
    display: "flex",
    borderBottom: "0.55px solid rgb(240, 240, 240)",
    padding: "0px 10px",
    justifyContent: "end",
    height: 22
  }),
  slider: css({
    display: "flex",
    flexDirection: "column",
    justifyContent: "center",
    alignItems: "center",
    flexGrow: 1,
    minHeight: 0
  }),
  items: css({
    display: "flex",
    flexDirection: "column",
    flex: "1 1 0%",
    height: "100%",
    minHeight: 0
  })
};
function MoleculePanelInner({
  zones,
  ranges,
  molecules: moleculesProp,
  activeTab,
  displayerMode,
  onMoleculeChange,
  actionsOptions,
  children
}) {
  const [currentIndex, setCurrentIndex] = react.exports.useState(0);
  const [molecules, setMolecules] = react.exports.useState([]);
  const dispatch = useDispatch();
  const modal = useModal();
  const {
    currentDiaIDsToHighlight,
    handleOnAtomHover,
    handleOnClickAtom,
    assignedDiaIDsMerged
  } = useAtomAssignment({
    zones,
    ranges,
    activeTab,
    displayerMode
  });
  react.exports.useEffect(() => {
    if (moleculesProp) {
      setMolecules((prevMolecules) => {
        if (moleculesProp.length > prevMolecules.length) {
          setCurrentIndex(molecules.length);
        }
        return moleculesProp;
      });
    }
  }, [molecules.length, moleculesProp]);
  react.exports.useEffect(() => {
    onMoleculeChange == null ? void 0 : onMoleculeChange(molecules[currentIndex] || null);
  }, [currentIndex, molecules, onMoleculeChange]);
  const handleReplaceMolecule = react.exports.useCallback((key, molfile) => {
    dispatch({
      type: SET_MOLECULE,
      molfile,
      key
    });
  }, [dispatch]);
  const openMoleculeEditorHandler = react.exports.useCallback((molecule) => {
    modal.show(/* @__PURE__ */ jsx(MoleculeStructureEditorModal, {
      selectedMolecule: molecule
    }), {
      position: positions.TOP_CENTER,
      width: 700,
      height: 500
    });
  }, [modal]);
  const moleculeIndexHandler = react.exports.useCallback((index2) => {
    setCurrentIndex(index2);
  }, []);
  return /* @__PURE__ */ jsxs("div", {
    css: styles$B.panel,
    children: [/* @__PURE__ */ jsx(MoleculePanelHeader, {
      currentIndex,
      molecules,
      onOpenMoleculeEditor: () => openMoleculeEditorHandler(),
      onMoleculeIndexChange: moleculeIndexHandler,
      actionsOptions
    }), /* @__PURE__ */ jsxs("div", {
      css: styles$B.innerPanel,
      children: [/* @__PURE__ */ jsx("div", {
        css: styles$B.molecule,
        children: /* @__PURE__ */ jsx(NextPrev$1, {
          onChange: (slideIndex) => setCurrentIndex(slideIndex),
          defaultIndex: currentIndex,
          children: molecules && molecules.length > 0 ? molecules.map((mol, index2) => {
            var _a;
            return /* @__PURE__ */ jsxs("div", {
              css: styles$B.items,
              children: [/* @__PURE__ */ jsx("div", {
                css: styles$B.toolbar,
                children: /* @__PURE__ */ jsxs("span", {
                  children: [/* @__PURE__ */ jsx(MF, {
                    mf: mol.mf
                  }), " - ", (_a = mol.mw) == null ? void 0 : _a.toFixed(2)]
                })
              }), /* @__PURE__ */ jsx("div", {
                css: styles$B.slider,
                className: "mol-svg-container",
                onDoubleClick: () => openMoleculeEditorHandler(mol),
                style: {
                  backgroundColor: (index2 + 1) % 2 !== 0 ? "#fafafa" : "white"
                },
                children: /* @__PURE__ */ jsx(ResponsiveChart, {
                  children: ({
                    height,
                    width
                  }) => {
                    return /* @__PURE__ */ jsx(OCLnmr, {
                      OCL: full,
                      id: `molSVG${index2}`,
                      width,
                      height,
                      molfile: mol.molfile || "",
                      setMolfile: (molfile) => handleReplaceMolecule(mol.key, molfile),
                      setSelectedAtom: handleOnClickAtom,
                      atomHighlightColor: currentDiaIDsToHighlight && currentDiaIDsToHighlight.length > 0 ? "red" : "#FFD700",
                      atomHighlightOpacity: 0.35,
                      highlights: currentDiaIDsToHighlight && currentDiaIDsToHighlight.length > 0 ? currentDiaIDsToHighlight : assignedDiaIDsMerged,
                      setHoverAtom: handleOnAtomHover
                    });
                  }
                })
              })]
            }, mol.key);
          }) : /* @__PURE__ */ jsx("div", {
            css: styles$B.slider,
            style: {
              height: "100%"
            },
            onClick: () => openMoleculeEditorHandler(),
            children: /* @__PURE__ */ jsx("span", {
              children: "Click to draw molecule"
            })
          })
        })
      }), children]
    })]
  });
}
const MemoizedMoleculePanel = react.exports.memo(MoleculePanelInner);
const emptyData$7 = {
  ranges: {},
  zones: {}
};
function MoleculePanel({
  onMoleculeChange,
  children,
  actionsOptions
}) {
  const {
    molecules,
    displayerMode,
    activeTab
  } = useChartData();
  const data = useSpectrum(emptyData$7);
  const ranges = (data == null ? void 0 : data.ranges) || {};
  const zones = (data == null ? void 0 : data.zones) || {};
  return /* @__PURE__ */ jsx(MemoizedMoleculePanel, {
    molecules,
    displayerMode,
    activeTab,
    ranges,
    zones,
    onMoleculeChange,
    actionsOptions,
    children
  });
}
const baseList = [{
  key: 1,
  value: "manual",
  label: "Manual"
}];
function AlignSpectraModal({
  onClose = () => null,
  nucleus
}) {
  const refForm = react.exports.useRef();
  const dispatch = useDispatch();
  const List = react.exports.useMemo(() => {
    const list = REFERENCES[nucleus] ? Object.entries(REFERENCES[nucleus]).map((item) => ({
      key: item[0],
      value: item[0],
      label: item[0]
    }), []) : [];
    return baseList.concat(list);
  }, [nucleus]);
  const handleSave = react.exports.useCallback(() => {
    refForm.current.submitForm();
  }, []);
  const submitHandler = react.exports.useCallback((values) => {
    dispatch({
      type: ALIGN_SPECTRA,
      payload: values
    });
    onClose();
  }, [dispatch, onClose]);
  react.exports.useEffect(() => {
    function handler(event) {
      const [from, to] = event.range;
      refForm.current.setValues(__spreadProps(__spreadValues({}, refForm.current.values), {
        from,
        to
      }));
    }
    Emitter.on("brushEnd", handler);
    return () => {
      Emitter.off("brushEnd", handler);
    };
  }, []);
  const optionChangeHandler = react.exports.useCallback((id2) => {
    const value = REFERENCES[nucleus][id2];
    const _a = value || {
      delta: 0
    }, {
      delta = 0
    } = _a, resValues = __objRest(_a, [
      "delta"
    ]);
    refForm.current.setValues(__spreadValues(__spreadProps(__spreadValues({}, refForm.current.values), {
      targetX: delta
    }), resValues));
  }, [nucleus]);
  return /* @__PURE__ */ jsxs("div", {
    css: ModalStyles,
    children: [/* @__PURE__ */ jsxs("div", {
      className: "header handle",
      children: [/* @__PURE__ */ jsx("span", {
        children: "Spectra calibration"
      }), /* @__PURE__ */ jsx(CloseButton$1, {
        onClick: onClose,
        className: "close-bt"
      })]
    }), /* @__PURE__ */ jsx("div", {
      className: "inner-content",
      style: {
        flex: 1
      },
      children: /* @__PURE__ */ jsxs(FormikForm, {
        ref: refForm,
        initialValues: {
          from: -1,
          to: 1,
          nbPeaks: 1,
          targetX: 0
        },
        onSubmit: submitHandler,
        children: [/* @__PURE__ */ jsxs("div", {
          className: "row margin-10",
          children: [/* @__PURE__ */ jsx("span", {
            className: "custom-label",
            children: "Options :"
          }), /* @__PURE__ */ jsx(Select, {
            data: List,
            style: {
              width: 270,
              height: 30,
              marginBottom: "20px"
            },
            onChange: optionChangeHandler
          })]
        }), /* @__PURE__ */ jsxs("div", {
          className: "row margin-10",
          children: [/* @__PURE__ */ jsx("span", {
            className: "custom-label",
            children: "Range :"
          }), /* @__PURE__ */ jsx(Label, {
            title: "From : ",
            children: /* @__PURE__ */ jsx(FormikInput, {
              name: "from",
              type: "number"
            })
          }), /* @__PURE__ */ jsx(Label, {
            title: "To : ",
            children: /* @__PURE__ */ jsx(FormikInput, {
              name: "to",
              type: "number"
            })
          })]
        }), /* @__PURE__ */ jsx("div", {
          className: " margin-10",
          children: /* @__PURE__ */ jsx(Label, {
            className: "custom-label",
            title: "Number of Peaks : ",
            children: /* @__PURE__ */ jsx(FormikInput, {
              name: "nbPeaks",
              type: "number"
            })
          })
        }), /* @__PURE__ */ jsx("div", {
          className: " margin-10",
          children: /* @__PURE__ */ jsx(Label, {
            className: "custom-label",
            title: "Target PPM :",
            children: /* @__PURE__ */ jsx(FormikInput, {
              name: "targetX",
              type: "number"
            })
          })
        })]
      })
    }), /* @__PURE__ */ jsx("div", {
      className: "footer-container",
      children: /* @__PURE__ */ jsx(Button.Done, {
        onClick: handleSave,
        children: "Done"
      })
    })]
  });
}
function calculate(code, args = null) {
  try {
    return new Function("args", `return ${code}`)(args);
  } catch (e2) {
    return e2;
  }
}
const initCode = `function run(data) {

  return JSON.stringify(data,undefined, 2);
  
}(args);
`;
function MultipleAnalysisCodeEditor({
  data
}) {
  const {
    values,
    setFieldValue
  } = useFormikContext();
  const [code, setCode] = react.exports.useState(values.code ? values.code : initCode);
  const [result, setResult] = react.exports.useState("");
  react.exports.useEffect(() => {
    const evalResult = calculate(code, data);
    if (evalResult instanceof Error) {
      setResult(evalResult.message);
    } else {
      setFieldValue("code", code);
      setResult(evalResult);
    }
  }, [code, data, setFieldValue]);
  return /* @__PURE__ */ jsxs("div", {
    style: {
      marginTop: "20px"
    },
    children: [/* @__PURE__ */ jsx("textarea", {
      value: code,
      onChange: (event) => setCode(event.target.value),
      style: {
        fontFamily: '"Fira code", "Fira Mono", monospace',
        fontSize: 12,
        padding: "1em",
        width: "90%",
        backgroundColor: "#fcfcfc",
        marginBottom: "10px",
        minHeight: "100px",
        overflow: "auto",
        maxHeight: "200px"
      }
    }), /* @__PURE__ */ jsx("p", {
      style: {
        marginBottom: "5px"
      },
      children: "Result:"
    }), /* @__PURE__ */ jsx("textarea", {
      value: result,
      readOnly: true,
      style: {
        border: "0.55px solid #f3f3f3",
        fontFamily: '"Fira code", "Fira Mono", monospace',
        fontSize: 12,
        padding: "1em",
        width: "90%",
        marginBottom: "10px",
        minHeight: "100px",
        overflow: "auto",
        maxHeight: "200px"
      }
    })]
  });
}
var MultipleAnalysisCodeEditor$1 = react.exports.memo(MultipleAnalysisCodeEditor);
const styles$A = css`
  width: 100%;
  thead {
    border-bottom: 1px solid lightgray;
    background-color: #fafafa;
    font-size: 12px;
  }

  td,
  th {
    padding: 3px 5px;
    text-align: center;
  }

  .operation-col {
    width: 30px;
  }

  .input {
    height: 25px !important;
    width: 100% !important;
    margin: 0 !important;
  }

  .input.disbale {
    background-color: #e8e8e8;
    border-radius: 5px;
  }

  .label,
  .index {
    width: 100px;
  }

  .counter {
    width: 50px;
  }

  .add {
    background-color: transparent;
    border: 0;
    outline: none;
    svg {
      font-szie: 14px;
      fill: green;
    }
  }
`;
function MultipleSpectraAnalysisPreferences({
  data,
  onAfterSave
}, ref) {
  const dispatch = useDispatch();
  const refForm = react.exports.useRef();
  const [columns, setColumns] = react.exports.useState({});
  react.exports.useImperativeHandle(ref, () => ({
    saveSetting() {
      refForm.current.submitForm();
    }
  }));
  react.exports.useEffect(() => {
    const result = Object.keys(data.columns).reduce((acc, key) => {
      acc[key] = __spreadProps(__spreadValues({}, data.columns[key]), {
        tempKey: key
      });
      return acc;
    }, {});
    setColumns(result);
    refForm.current.setValues({
      columns: result,
      code: data.code
    });
  }, [data]);
  const columnsKeys = react.exports.useMemo(() => {
    return Object.keys(columns);
  }, [columns]);
  const preferncesSchema = react.exports.useMemo(() => {
    function columnSchema() {
      return columnsKeys.reduce((acc, key) => {
        acc[key] = create().shape(__spreadProps(__spreadValues({
          tempKey: create$2().required().test("unique", "must be unique column name", (colmnName) => {
            const formData = refForm.current.values.columns;
            return Object.keys(formData).reduce((acc2, colKey) => {
              if (formData[colKey].tempKey === colmnName) {
                acc2.push(colmnName);
              }
              return acc2;
            }, []).length === 1;
          })
        }, columns[key].type === COLUMNS_TYPES.FORMULA ? {
          formula: create$2().required()
        } : {}), {
          index: create$2().required()
        }));
        return acc;
      }, {});
    }
    return create().shape({
      columns: create().shape(columnSchema())
    });
  }, [columns, columnsKeys, refForm]);
  const submitHandler = react.exports.useCallback((values) => {
    onAfterSave == null ? void 0 : onAfterSave(true);
    const result = Object.entries(values.columns).reduce((acc, [key, value]) => {
      acc[key] = __spreadValues(__spreadValues({}, columns[key]), value);
      return acc;
    }, {});
    dispatch({
      type: SET_ANALYZE_SPECTRA_COLUMNS,
      payload: {
        code: values.code,
        columns: result
      }
    });
  }, [columns, dispatch, onAfterSave]);
  const addNewColumn = react.exports.useCallback((index2) => {
    setColumns((prevData) => {
      return __spreadProps(__spreadValues({}, prevData), {
        [`temp${index2}`]: {
          tempKey: "",
          type: "FORMULA",
          valueKey: "value",
          formula: "",
          index: index2
        }
      });
    });
  }, []);
  return /* @__PURE__ */ jsxs(FormikForm, {
    ref: refForm,
    initialValues: {
      columns,
      code: null
    },
    validationSchema: preferncesSchema,
    onSubmit: submitHandler,
    children: [columnsKeys && /* @__PURE__ */ jsxs("table", {
      css: styles$A,
      children: [/* @__PURE__ */ jsx("thead", {
        children: /* @__PURE__ */ jsxs("tr", {
          children: [/* @__PURE__ */ jsx("th", {
            className: "counter",
            children: "#"
          }), /* @__PURE__ */ jsx("th", {
            className: "label",
            children: "Label"
          }), /* @__PURE__ */ jsx("th", {
            children: "value"
          }), /* @__PURE__ */ jsx("th", {
            className: "index",
            children: "index"
          })]
        })
      }), /* @__PURE__ */ jsx("tbody", {
        children: columnsKeys.map((key, index2) => {
          return /* @__PURE__ */ jsxs("tr", {
            children: [/* @__PURE__ */ jsx("td", {
              className: "counter",
              children: index2 + 1
            }), /* @__PURE__ */ jsx("td", {
              className: "label",
              children: /* @__PURE__ */ jsx(FormikInput, {
                name: `columns.${key}.tempKey`,
                value: columns[key].tempKey
              }, key)
            }), /* @__PURE__ */ jsx("td", {
              children: columns[key].type === COLUMNS_TYPES.FORMULA ? /* @__PURE__ */ jsx(FormikInput, {
                name: `columns.${key}.formula`,
                value: columns[key].formula
              }) : /* @__PURE__ */ jsx("div", {
                className: "input disbale"
              })
            }), /* @__PURE__ */ jsx("td", {
              className: "index",
              children: /* @__PURE__ */ jsx(FormikInput, {
                name: `columns.${key}.index`,
                value: columns[key].index
              })
            }), /* @__PURE__ */ jsx("td", {
              className: "operation-col",
              children: columnsKeys.length === index2 + 1 && /* @__PURE__ */ jsx("button", {
                className: "add",
                type: "button",
                onClick: () => addNewColumn(index2 + 1),
                children: /* @__PURE__ */ jsx(FaPlus, {})
              })
            })]
          }, key);
        })
      })]
    }), /* @__PURE__ */ jsx(MultipleAnalysisCodeEditor$1, {
      data
    })]
  });
}
var MultipleSpectraAnalysisPreferences$1 = react.exports.forwardRef(MultipleSpectraAnalysisPreferences);
const styles$z = {
  container: css`
    background-color: white;
    position: absolute;
    height: auto;
    z-index: 99999999999999;
    box-shadow: 0 19px 38px rgba(0, 0, 0, 0.3), 0 15px 12px rgba(0, 0, 0, 0.22);
    border-radius: 10px;
    margin-bottom: 20px;
    overflow: hidden;
  `,
  ul: css`
    list-style-type: none;
    padding: 0;
    margin: 0;
  `,
  li: css`
    text-align: center;
    color: black;
    border-bottom: 0.55px solid #f9f9f9;
    min-width: 150px;
    width: fit-content;
    &:last-of-type {
      border-bottom: none;
    }

    &:hover {
      background-color: gray;
      color: white;
    }
  `,
  label: css`
    padding: 5px 20px;
    display: block;
  `
};
function DropDownList({
  data = [],
  onSelect,
  renderItem = null
}) {
  const ref = react.exports.useRef(null);
  react.exports.useLayoutEffect(() => {
    var _a;
    if (ref.current) {
      const containerRect = (_a = ref.current) == null ? void 0 : _a.getBoundingClientRect();
      if (containerRect.right > window.innerWidth) {
        ref.current.style.right = `${containerRect.right - window.innerWidth}px`;
      }
    }
  }, []);
  return /* @__PURE__ */ jsx("div", {
    css: styles$z.container,
    ref,
    children: /* @__PURE__ */ jsx("ul", {
      css: styles$z.ul,
      children: data.map((item, index2) => /* @__PURE__ */ jsx("li", {
        css: styles$z.li,
        onClick: () => onSelect(index2),
        children: (renderItem == null ? void 0 : renderItem(item)) || /* @__PURE__ */ jsx("span", {
          css: styles$z.label,
          children: item.label
        })
      }, item.key))
    })
  });
}
const styles$y = {
  container: css`
    position: relative;
    padding: 2px;
    border-radius: 10px;
    width: max-content;
    display: inline-block;
    border: 0.55px solid lightgray;
    font-size: 10px;
  `,
  button: css`
    width: 100%;
  `
};
function DropDownButton(props) {
  const {
    data,
    selectedKey,
    onSelect,
    formatSelectedValue = (item2) => item2.label,
    renderItem = null,
    style: style2
  } = props;
  const [open, setOpen] = react.exports.useState(false);
  const [item, setItem] = react.exports.useState();
  const drop = react.exports.useRef(null);
  react.exports.useEffect(() => {
    if (selectedKey) {
      const item2 = data.find((i) => i.key === selectedKey) || null;
      setItem(item2);
    }
  }, [selectedKey, data]);
  react.exports.useEffect(() => {
    function handleClick() {
      setOpen(false);
    }
    window.addEventListener("click", handleClick);
    return () => window.removeEventListener("click", handleClick);
  }, []);
  const selectHandler = react.exports.useCallback((index2) => {
    setItem(data[index2]);
    onSelect == null ? void 0 : onSelect(data[index2]);
  }, [data, onSelect]);
  return /* @__PURE__ */ jsxs("div", {
    className: "dropdown",
    ref: drop,
    css: [styles$y.container, style2],
    children: [/* @__PURE__ */ jsx("button", {
      css: styles$y.button,
      type: "button",
      onClick: (event) => {
        setOpen((open2) => !open2);
        event.stopPropagation();
      },
      children: !item ? /* @__PURE__ */ jsx(FaEllipsisH, {}) : formatSelectedValue(item)
    }), open && /* @__PURE__ */ jsx(DropDownList, {
      data,
      onSelect: selectHandler,
      renderItem
    })]
  });
}
const styles$x = (styles2) => css`
  position: relative;

  .delete {
    position: absolute;
    right: 0px;
    top: 0px;
  }

  .container {
    display: flex;
    flex-direction: column;
    padding: 0;
    margin: 0;
  }

  .dropDown-container {
    justify-content: flex-start;
    align-items: flex-start;
  }

  .label-container {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    min-height: 45px;
  }

  .label {
    text-align: center;
  }

  ${styles2}
`;
const columnsFilters = [{
  key: COLUMNS_VALUES_KEYS.RELATIVE,
  label: "Relative"
}, {
  key: COLUMNS_VALUES_KEYS.ABSOLUTE,
  label: "Absolute"
}, {
  key: COLUMNS_VALUES_KEYS.MIN,
  label: "Min Intensity"
}, {
  key: COLUMNS_VALUES_KEYS.MAX,
  label: "Max Intensity"
}];
function ColumnHeader({
  charLabel,
  rangeLabel,
  data,
  onColumnFilter
}) {
  const dispatch = useDispatch();
  const deleteHandler = react.exports.useCallback(() => {
    dispatch({
      type: DELETE_ANALYZE_SPECTRA_RANGE,
      colKey: charLabel
    });
  }, [charLabel, dispatch]);
  return /* @__PURE__ */ jsxs("div", {
    css: styles$x,
    children: [/* @__PURE__ */ jsxs("div", {
      className: "container",
      children: [data.type === COLUMNS_TYPES.NORMAL && /* @__PURE__ */ jsx("div", {
        className: "dropDown-container",
        children: /* @__PURE__ */ jsx(DropDownButton, {
          data: columnsFilters,
          formatSelectedValue: (item) => item.label.substring(0, 3),
          selectedKey: data.valueKey,
          onSelect: onColumnFilter
        })
      }), /* @__PURE__ */ jsxs("div", {
        className: "label-container",
        children: [/* @__PURE__ */ jsxs("span", {
          className: "label",
          children: [" ", charLabel]
        }), /* @__PURE__ */ jsx("span", {
          className: "label",
          children: rangeLabel
        })]
      })]
    }), /* @__PURE__ */ jsx(DeleteButton, {
      onDelete: deleteHandler
    })]
  });
}
function MultipleSpectraAnalysisTable({
  data,
  activeTab
}) {
  const format2 = useFormatNumberByNucleus(activeTab);
  const codeEvaluation = react.exports.useMemo(() => {
    const code = get_1(data, "code", "");
    return calculate(code, data);
  }, [data]);
  const dispatch = useDispatch();
  const columnFilterHandler = react.exports.useCallback((columnKey, valueKey) => {
    dispatch({
      type: FILTER_SPECTRA_COLUMN,
      payload: {
        columnKey,
        valueKey
      }
    });
  }, [dispatch]);
  const tableColumns = react.exports.useMemo(() => {
    const columns = [{
      Header: "#",
      index: 0,
      Cell: ({
        row
      }) => row.index + 1
    }];
    function cellHandler(row, columnKey, valueKey) {
      const value = row.original[columnKey][valueKey];
      const result = value instanceof Error ? /* @__PURE__ */ jsx$1("span", {
        style: {
          color: "red"
        },
        children: value.message
      }) : format2(value);
      return result;
    }
    function headerHandler(columnData, columnKey) {
      return /* @__PURE__ */ jsx$1(ColumnHeader, {
        charLabel: columnKey,
        data: columnData,
        onColumnFilter: (item) => columnFilterHandler(columnKey, item.key),
        rangeLabel: columnData.from && columnData.to ? `${format2(columnData.from)} - ${format2(columnData.to)}` : ""
      });
    }
    if (data.columns) {
      Object.keys(data.columns).forEach((columnKey) => {
        const {
          valueKey,
          index: columnIndex
        } = data.columns[columnKey];
        addCustomColumn(columns, {
          index: columnIndex + 1,
          Cell: ({
            row
          }) => cellHandler(row, columnKey, valueKey),
          Header: () => headerHandler(data.columns[columnKey], columnKey),
          id: columnKey
        });
      });
    }
    return columns.sort((object1, object2) => object1.index - object2.index);
  }, [columnFilterHandler, data.columns, format2]);
  return data.values && data.values.length > 0 ? /* @__PURE__ */ jsxs$1(react.exports.Fragment, {
    children: [/* @__PURE__ */ jsx$1(ReactTable$1, {
      data: data.values,
      columns: tableColumns
    }), /* @__PURE__ */ jsx$1("div", {
      style: {
        width: "100%",
        padding: "10px"
      },
      dangerouslySetInnerHTML: {
        __html: codeEvaluation
      }
    })]
  }) : /* @__PURE__ */ jsx$1(NoTableData, {});
}
var MultipleSpectraAnalysisTable$1 = react.exports.memo(MultipleSpectraAnalysisTable);
function MultipleSpectraAnalysisPanelInner({
  activeTab,
  spectraAnalysis
}) {
  const [isFlipped, setFlipStatus] = react.exports.useState(false);
  const settingRef = react.exports.useRef();
  const alert2 = useAlert();
  const modal = useModal();
  const dispatch = useDispatch();
  const data = react.exports.useMemo(() => {
    const {
      values,
      options: {
        columns,
        code
      }
    } = spectraAnalysis[activeTab] || {
      values: {},
      options: {
        columns: {},
        code: null
      }
    };
    return {
      values: Object.values(values),
      columns,
      code
    };
  }, [activeTab, spectraAnalysis]);
  const settingsPanelHandler = react.exports.useCallback(() => {
    setFlipStatus(!isFlipped);
  }, [isFlipped]);
  const saveSettingHandler = react.exports.useCallback(() => {
    settingRef.current.saveSetting();
  }, []);
  const afterSaveHandler = react.exports.useCallback(() => {
    setFlipStatus(false);
  }, []);
  const showTrackerHandler = react.exports.useCallback((flag) => {
    Emitter.emit("showYSpectraTrackers", flag);
  }, []);
  const openAlignSpectra = react.exports.useCallback(() => {
    dispatch({
      type: RESET_SELECTED_TOOL
    });
    modal.show(/* @__PURE__ */ jsx(AlignSpectraModal, {
      nucleus: activeTab
    }), {
      isBackgroundBlur: false,
      position: positions.TOP_CENTER,
      width: 500
    });
  }, [activeTab, modal, dispatch]);
  const copyToClipboardHandler = react.exports.useCallback(() => {
    void (async () => {
      const data2 = getDataAsString(spectraAnalysis, activeTab);
      const success = await copyTextToClipboard(data2);
      if (success) {
        alert2.success("Data copied to clipboard");
      } else {
        alert2.error("copy to clipboard failed");
      }
    })();
  }, [activeTab, alert2, spectraAnalysis]);
  return /* @__PURE__ */ jsxs("div", {
    css: [tablePanelStyle, isFlipped && css`
            .table-container th {
              position: relative;
            }
          `],
    children: [!isFlipped && /* @__PURE__ */ jsxs(DefaultPanelHeader$1, {
      deleteToolTip: "Delete All Peaks",
      showSettingButton: true,
      canDelete: false,
      onSettingClick: settingsPanelHandler,
      children: [/* @__PURE__ */ jsx(ButtonToolTip, {
        popupTitle: "Copy To Clipboard",
        onClick: copyToClipboardHandler,
        children: /* @__PURE__ */ jsx(FaFileExport, {})
      }), /* @__PURE__ */ jsx(ButtonToolTip, {
        popupTitle: "Spectra calibration",
        onClick: openAlignSpectra,
        children: /* @__PURE__ */ jsx(SvgOverlay, {
          style: {
            fontSize: "18px"
          }
        })
      }), /* @__PURE__ */ jsx(ToggleButton$2, {
        popupTitle: "Y Spectra Tracker",
        popupPlacement: "right",
        onClick: showTrackerHandler,
        children: /* @__PURE__ */ jsx(IoPulseOutline, {})
      })]
    }), isFlipped && /* @__PURE__ */ jsx(PreferencesHeader$1, {
      onSave: saveSettingHandler,
      onClose: settingsPanelHandler
    }), /* @__PURE__ */ jsx("div", {
      className: "inner-container",
      children: !isFlipped ? /* @__PURE__ */ jsx(MultipleSpectraAnalysisTable$1, {
        data,
        activeTab
      }) : /* @__PURE__ */ jsx(MultipleSpectraAnalysisPreferences$1, {
        data,
        onAfterSave: afterSaveHandler,
        ref: settingRef
      })
    })]
  });
}
const MemoizedMultipleSpectraAnalysisPanel = react.exports.memo(MultipleSpectraAnalysisPanelInner);
function MultipleSpectraAnalysisPanel() {
  const {
    activeTab,
    spectraAnalysis,
    displayerKey
  } = useChartData();
  if (!activeTab) {
    return /* @__PURE__ */ jsx("div", {});
  }
  return /* @__PURE__ */ jsx(MemoizedMultipleSpectraAnalysisPanel, {
    activeTab,
    spectraAnalysis,
    displayerKey
  });
}
const styles$w = {
  container: {
    padding: 10,
    backgroundColor: "#f1f1f1",
    height: "100%",
    overflowY: "auto"
  },
  groupContainer: {
    padding: "5px",
    borderRadius: "5px",
    margin: "10px 0px",
    backgroundColor: "white"
  },
  row: {
    display: "flex",
    margin: "5px 0px"
  },
  header: {
    borderBottom: "1px solid #e8e8e8",
    paddingBottom: "5px",
    fontWeight: "bold",
    color: "#4a4a4a"
  },
  inputLabel: {
    flex: 2,
    fontSize: "11px",
    fontWeight: "bold",
    color: "#232323"
  },
  input: {
    width: "30%",
    textAlign: "center"
  }
};
const formatFields$2 = [{
  id: 1,
  label: "Peak Number :",
  checkController: "showPeakNumber",
  formatController: "peakNumberFormat"
}, {
  id: 2,
  label: "Peak Index : ",
  checkController: "showPeakIndex",
  formatController: "peakIndexFormat"
}, {
  id: 3,
  label: "\u03B4 (ppm) :",
  checkController: "showDeltaPPM",
  formatController: "deltaPPMFormat"
}, {
  id: 4,
  label: "\u03B4 (Hz) :",
  checkController: "showDeltaHz",
  formatController: "deltaHzFormat"
}, {
  id: 5,
  label: "Peak Width",
  checkController: "showPeakWidth",
  formatController: "peakWidthFormat"
}, {
  id: 6,
  label: "Intensity :",
  checkController: "showIntensity",
  formatController: "intensityFormat"
}];
function PeaksPreferencesInner({
  nucleus,
  preferences,
  innerRef
}) {
  const alert2 = useAlert();
  const formRef = react.exports.useRef(null);
  const updateValues = react.exports.useCallback(() => {
    if (nucleus) {
      const defaultValues = nucleus.reduce((acc, nucleusLabel) => {
        acc[nucleusLabel] = peaksDefaultValues;
        return acc;
      }, {});
      const peaksPreferences = getValue(preferences.current, `formatting.panels.peaks`);
      formRef.current.setValues(peaksPreferences ? peaksPreferences : defaultValues);
    }
  }, [nucleus, preferences]);
  react.exports.useEffect(() => {
    updateValues();
  }, [updateValues]);
  const saveHandler = react.exports.useCallback((values) => {
    preferences.dispatch({
      type: "SET_PANELS_PREFERENCES",
      payload: {
        key: "peaks",
        value: values
      }
    });
    alert2.success("Peaks preferences saved successfully");
  }, [alert2, preferences]);
  react.exports.useImperativeHandle(innerRef, () => ({
    saveSetting: () => {
      formRef.current.submitForm();
    }
  }), []);
  return /* @__PURE__ */ jsx$1("div", {
    style: styles$w.container,
    children: /* @__PURE__ */ jsx$1(FormikForm, {
      onSubmit: saveHandler,
      ref: formRef,
      children: nucleus == null ? void 0 : nucleus.map((nucleusLabel) => /* @__PURE__ */ jsxs$1("div", {
        style: styles$w.groupContainer,
        children: [/* @__PURE__ */ jsx$1(IsotopesViewer, {
          style: styles$w.header,
          value: nucleusLabel
        }), formatFields$2.map((field) => /* @__PURE__ */ jsx$1(FormikColumnFormatField$1, {
          label: field.label,
          checkControllerName: `${nucleusLabel}.${field.checkController}`,
          formatControllerName: `${nucleusLabel}.${field.formatController}`,
          hideFormat: field.formatController === "deltaPPMFormat"
        }, field.id))]
      }, nucleusLabel))
    })
  });
}
const MemoizedPeaksPreferences = react.exports.memo(PeaksPreferencesInner);
function PeaksPreferences(props, ref) {
  const nucleus = useNucleus();
  const preferences = usePreferences();
  return /* @__PURE__ */ jsx$1(MemoizedPeaksPreferences, {
    innerRef: ref,
    nucleus,
    preferences
  });
}
var PeaksPreferences$1 = react.exports.forwardRef(PeaksPreferences);
function PeaksTable({
  activeTab,
  preferences,
  data,
  info
}) {
  const dispatch = useDispatch();
  const format2 = useFormatNumberByNucleus(info.nucleus);
  const deletePeakHandler = react.exports.useCallback((e2, row) => {
    e2.preventDefault();
    e2.stopPropagation();
    const params = row.original;
    dispatch({
      type: DELETE_PEAK_NOTATION,
      data: {
        id: params.id,
        xIndex: params.xIndex
      }
    });
  }, [dispatch]);
  const peaksPreferences = react.exports.useMemo(() => getValue(preferences.current, `formatting.panels.peaks.[${activeTab}]`, peaksDefaultValues), [activeTab, preferences]);
  const saveDeltaPPMRefsHandler = react.exports.useCallback((event, row) => {
    const shiftValue = parseFloat(event.target.value) - parseFloat(row.value);
    dispatch({
      type: SHIFT_SPECTRUM,
      shiftValue
    });
  }, [dispatch]);
  const COLUMNS2 = react.exports.useMemo(() => [{
    showWhen: "showPeakNumber",
    index: 1,
    Header: "#",
    Cell: ({
      row
    }) => row.index + 1,
    style: {
      width: "1%",
      maxWidth: "40px",
      minWidth: "40px"
    }
  }, {
    showWhen: "showPeakIndex",
    index: 2,
    Header: "index",
    accessor: (row) => FormatNumber(row.xIndex, peaksPreferences.peakIndexFormat)
  }, {
    showWhen: "showDeltaPPM",
    index: 3,
    Header: "\u03B4 (ppm)",
    accessor: (row) => format2(row.value),
    Cell: ({
      row
    }) => /* @__PURE__ */ jsx$1(EditableColumn$1, {
      value: format2(row.original.value),
      onSave: (event) => saveDeltaPPMRefsHandler(event, row.original),
      type: "number"
    })
  }, {
    showWhen: "showDeltaHz",
    index: 4,
    Header: "\u03B4 (Hz)",
    accessor: (row) => FormatNumber(row.valueHz, peaksPreferences.deltaHzFormat)
  }, {
    showWhen: "showIntensity",
    index: 5,
    Header: "Intensity",
    style: {
      maxWidth: "80px"
    },
    accessor: (row) => FormatNumber(row.intensity, peaksPreferences.intensityFormat)
  }, {
    showWhen: "showPeakWidth",
    index: 6,
    Header: "Peak Width",
    accessor: (row) => FormatNumber(row.peakWidth, peaksPreferences.peakWidthFormat)
  }], [format2, peaksPreferences, saveDeltaPPMRefsHandler]);
  const initialColumns = react.exports.useMemo(() => [{
    index: 20,
    Header: "",
    style: {
      width: "1%",
      maxWidth: "24px",
      minWidth: "24px"
    },
    id: "delete-button",
    Cell: ({
      row
    }) => /* @__PURE__ */ jsx$1("button", {
      type: "button",
      className: "delete-button",
      onClick: (e2) => deletePeakHandler(e2, row),
      children: /* @__PURE__ */ jsx$1(FaRegTrashAlt, {})
    })
  }], [deletePeakHandler]);
  const tableColumns = react.exports.useMemo(() => {
    let columns = [...initialColumns];
    for (const col of COLUMNS2) {
      const _a = col, {
        showWhen
      } = _a, colParams = __objRest(_a, [
        "showWhen"
      ]);
      if (peaksPreferences[showWhen]) {
        addCustomColumn(columns, colParams);
      }
    }
    return columns.sort((object1, object2) => object1.index - object2.index);
  }, [COLUMNS2, initialColumns, peaksPreferences]);
  return data && data.length > 0 ? /* @__PURE__ */ jsx$1(ReactTable$1, {
    data,
    columns: tableColumns,
    approxItemHeight: 20,
    enableVirtualScroll: true
  }) : /* @__PURE__ */ jsx$1(NoTableData, {});
}
var PeaksTable$1 = react.exports.memo(PeaksTable);
function PeaksPanelInner({
  peaks,
  info,
  xDomain,
  activeTab,
  preferences
}) {
  var _a;
  const [filterIsActive, setFilterIsActive] = react.exports.useState(false);
  const [isFlipped, setFlipStatus] = react.exports.useState(false);
  const format2 = useFormatNumberByNucleus(info.nucleus);
  const dispatch = useDispatch();
  const modal = useModal();
  const settingRef = react.exports.useRef();
  const yesHandler = react.exports.useCallback(() => {
    dispatch({
      type: DELETE_PEAK_NOTATION,
      data: null
    });
  }, [dispatch]);
  const handleDeleteAll = react.exports.useCallback(() => {
    modal.showConfirmDialog({
      message: "All records will be deleted, Are You sure?",
      buttons: [{
        text: "Yes",
        handler: yesHandler
      }, {
        text: "No"
      }]
    });
  }, [modal, yesHandler]);
  const settingsPanelHandler = react.exports.useCallback(() => {
    setFlipStatus(!isFlipped);
  }, [isFlipped]);
  const saveSettingHandler = react.exports.useCallback(() => {
    settingRef.current.saveSetting();
    setFlipStatus(false);
  }, []);
  const handleOnFilter = react.exports.useCallback(() => {
    setFilterIsActive(!filterIsActive);
  }, [filterIsActive]);
  const filteredPeaks = react.exports.useMemo(() => {
    function isInRange(value) {
      const factor = 1e5;
      return value * factor >= xDomain[0] * factor && value * factor <= xDomain[1] * factor;
    }
    if (peaks == null ? void 0 : peaks.values) {
      const _peaks = filterIsActive ? peaks.values.filter((peak) => isInRange(peak.x)) : peaks.values;
      return _peaks.map((peak) => {
        const value = Number(format2(peak.x));
        return {
          value,
          valueHz: (info == null ? void 0 : info.originFrequency) ? Number(value) * info.originFrequency : "",
          id: peak.id,
          intensity: peak.y,
          peakWidth: peak.width ? peak.width : "",
          isConstantlyHighlighted: isInRange(value)
        };
      }).sort((prev, next) => prev.value - next.value);
    }
    return [];
  }, [filterIsActive, format2, info, peaks, xDomain]);
  return /* @__PURE__ */ jsxs("div", {
    css: [tablePanelStyle, isFlipped && css`
            .table-container {
              table,
              th {
                position: relative !important;
              }
            }
          `],
    children: [!isFlipped && /* @__PURE__ */ jsx(DefaultPanelHeader$1, {
      counter: (_a = peaks == null ? void 0 : peaks.values) == null ? void 0 : _a.length,
      onDelete: handleDeleteAll,
      deleteToolTip: "Delete All Peaks",
      onFilter: handleOnFilter,
      filterToolTip: filterIsActive ? "Show all peaks" : "Hide peaks out of view",
      filterIsActive,
      counterFiltered: filteredPeaks.length,
      showSettingButton: true,
      onSettingClick: settingsPanelHandler
    }), isFlipped && /* @__PURE__ */ jsx(PreferencesHeader$1, {
      onSave: saveSettingHandler,
      onClose: settingsPanelHandler
    }), /* @__PURE__ */ jsx("div", {
      className: "inner-container",
      children: !isFlipped ? /* @__PURE__ */ jsx(PeaksTable$1, {
        data: filteredPeaks,
        activeTab,
        preferences,
        info
      }) : /* @__PURE__ */ jsx(PeaksPreferences$1, {
        ref: settingRef
      })
    })]
  });
}
const MemoizedPeaksPanel = react.exports.memo(PeaksPanelInner);
const emptyData$6 = {
  peaks: null,
  info: {}
};
function PeaksPanel$1() {
  const {
    xDomain,
    activeTab
  } = useChartData();
  const {
    peaks,
    info
  } = useSpectrum(emptyData$6);
  const preferences = usePreferences();
  return /* @__PURE__ */ jsx(MemoizedPeaksPanel, {
    peaks,
    info,
    xDomain,
    activeTab,
    preferences
  });
}
const styles$v = css`
  overflow: auto;
  width: 400px;
  .innerContainer {
    padding: 5px;
    width: 100%;
    height: 180px;
    border: none;
  }

  .mainButtonsContainer {
    padding: 5px 0px;
    border-bottom: 0.55px solid #ebebeb;
    display: flex;
    justify-content: space-between;
  }

  button {
    background-color: transparent;
    border: none;
    padding: 0 5px;
  }

  button:disabled {
    opacity: 0.6;
  }
`;
function CopyClipboardModal({
  text,
  onClose,
  onCopyClick
}) {
  return /* @__PURE__ */ jsxs("div", {
    css: styles$v,
    children: [/* @__PURE__ */ jsxs("div", {
      className: "mainButtonsContainer handle",
      children: [/* @__PURE__ */ jsx("button", {
        type: "button",
        onClick: () => onCopyClick(text),
        children: /* @__PURE__ */ jsx(FaCopy, {})
      }), /* @__PURE__ */ jsx(CloseButton$1, {
        onClick: onClose
      })]
    }), /* @__PURE__ */ jsx("div", {
      className: "innerContainer",
      dangerouslySetInnerHTML: {
        __html: text
      }
    })]
  });
}
const style$6 = css`
  .btn {
    background-color: transparent;
    border: none;
  }

  .icon svg {
    font-size: 12px;
  }

  .preview-publication-icon svg {
    font-size: 13px;
  }

  button {
    margin-right: 2px;
  }
`;
function RangesHeader({
  ranges,
  info,
  onUnlink,
  onFilterActivated,
  onSettingClick,
  isFilterActive,
  filterCounter,
  showMultiplicityTrees,
  showJGraph,
  showRangesIntegrals
}) {
  var _a;
  const dispatch = useDispatch();
  const modal = useModal();
  const alert2 = useAlert();
  const preferences = usePreferences();
  const assignmentData = useAssignmentData();
  const currentSum = get_1(ranges, "options.sum", null);
  const changeRangesSumHandler = react.exports.useCallback((value) => {
    dispatch({
      type: CHANGE_RANGE_SUM,
      value
    });
    modal.close();
  }, [dispatch, modal]);
  const showChangeRangesSumModal = react.exports.useCallback(() => {
    modal.show(/* @__PURE__ */ jsx(ChangeSumModal, {
      onClose: () => modal.close(),
      onSave: changeRangesSumHandler,
      header: currentSum ? `Set new Ranges Sum (Current: ${Number(currentSum).toFixed(2)})` : "Set new Ranges Sum",
      sumOptions: ranges == null ? void 0 : ranges.options
    }));
  }, [changeRangesSumHandler, currentSum, modal, ranges == null ? void 0 : ranges.options]);
  const removeAssignments2 = react.exports.useCallback(() => {
    onUnlink();
  }, [onUnlink]);
  const handleOnRemoveAssignments = react.exports.useCallback(() => {
    modal.showConfirmDialog({
      message: "All assignments will be removed. Are you sure?",
      buttons: [{
        text: "Yes",
        handler: removeAssignments2
      }, {
        text: "No"
      }]
    });
  }, [removeAssignments2, modal]);
  const handleDeleteAll = react.exports.useCallback(() => {
    modal.showConfirmDialog({
      message: "All ranges will be deleted. Are You sure?",
      buttons: [{
        text: "Yes",
        handler: () => {
          dispatch({
            type: DELETE_RANGE,
            payload: {
              data: {
                assignmentData
              }
            }
          });
        }
      }, {
        text: "No"
      }]
    });
  }, [assignmentData, dispatch, modal]);
  const handleSetShowMultiplicityTrees = react.exports.useCallback(() => {
    dispatch({
      type: SHOW_MULTIPLICTY_TREES
    });
  }, [dispatch]);
  const handleShowIntegrals = react.exports.useCallback(() => {
    dispatch({
      type: SHOW_RANGES_INTEGRALS
    });
  }, [dispatch]);
  const handleShowJGraph2 = react.exports.useCallback(() => {
    dispatch({
      type: SHOW_J_GRAPH
    });
  }, [dispatch]);
  const saveToClipboardHandler = react.exports.useCallback((value) => {
    void (async () => {
      const success = await copyHTMLToClipboard(value);
      if (success) {
        alert2.success("Data copied to clipboard");
      } else {
        alert2.error("copy to clipboard failed");
      }
    })();
  }, [alert2]);
  const saveAsHTMLHandler = react.exports.useCallback(() => {
    const {
      originFrequency: observedFrequency,
      nucleus
    } = info;
    const format2 = get_1(preferences.current, `formatting.nuclei[${nucleus.toLowerCase()}]`, "0.0");
    const nbDecimalDelta = getNumberOfDecimals(format2.ppm);
    const nbDecimalJ = getNumberOfDecimals(format2.hz);
    const result = rangesToACS(ranges.values, {
      nucleus,
      nbDecimalDelta,
      nbDecimalJ,
      observedFrequency
    });
    modal.show(/* @__PURE__ */ jsx(CopyClipboardModal, {
      text: result,
      onCopyClick: saveToClipboardHandler,
      onClose: () => modal.close()
    }), {});
  }, [info, modal, preferences, ranges.values, saveToClipboardHandler]);
  const changeSumConstantFlagHandler = react.exports.useCallback((flag) => {
    dispatch({
      type: CHANGE_RANGES_SUM_FLAG,
      payload: flag
    });
  }, [dispatch]);
  return /* @__PURE__ */ jsx("div", {
    css: style$6,
    children: /* @__PURE__ */ jsxs(DefaultPanelHeader$1, {
      counter: (_a = ranges == null ? void 0 : ranges.values) == null ? void 0 : _a.length,
      onDelete: handleDeleteAll,
      deleteToolTip: "Delete All Ranges",
      onFilter: onFilterActivated,
      filterToolTip: isFilterActive ? "Show all ranges" : "Hide ranges out of view",
      filterIsActive: isFilterActive,
      counterFiltered: filterCounter,
      showSettingButton: true,
      onSettingClick,
      children: [/* @__PURE__ */ jsx(ButtonToolTip, {
        popupTitle: "Preview publication string",
        popupPlacement: "right",
        onClick: saveAsHTMLHandler,
        className: "btn preview-publication-icon",
        children: /* @__PURE__ */ jsx(FaFileExport, {})
      }), /* @__PURE__ */ jsx(ButtonToolTip, {
        popupTitle: currentSum ? `Change Ranges Sum (${Number(currentSum).toFixed(2)})` : "Change Ranges Sum",
        popupPlacement: "right",
        onClick: showChangeRangesSumModal,
        className: "btn icon",
        children: /* @__PURE__ */ jsx(SvgSum, {})
      }), /* @__PURE__ */ jsx(ButtonToolTip, {
        popupTitle: "Remove all Assignments",
        popupPlacement: "right",
        onClick: handleOnRemoveAssignments,
        disabled: !ranges || !ranges.values || ranges.values.length === 0,
        className: "btn icon",
        children: /* @__PURE__ */ jsx(FaUnlink, {})
      }), /* @__PURE__ */ jsx(ToggleButton$2, {
        popupTitle: showMultiplicityTrees ? "Hide Multiplicity Trees in Spectrum" : "Show Multiplicity Trees in Spectrum",
        popupPlacement: "right",
        onClick: handleSetShowMultiplicityTrees,
        disabled: !ranges || !ranges.values || ranges.values.length === 0,
        children: /* @__PURE__ */ jsx(FaSitemap, {
          style: {
            pointerEvents: "none",
            fontSize: "12px"
          }
        })
      }), /* @__PURE__ */ jsx(ToggleButton$2, {
        popupTitle: showJGraph ? "Hide J Graph" : "Show J Graph",
        popupPlacement: "right",
        onClick: handleShowJGraph2,
        disabled: !ranges || !ranges.values || ranges.values.length === 0,
        children: /* @__PURE__ */ jsx(FaChartBar, {
          style: {
            pointerEvents: "none",
            fontSize: "12px"
          }
        })
      }), /* @__PURE__ */ jsx(ToggleButton$2, {
        popupTitle: showRangesIntegrals ? "Hide integrals" : "Show integrals",
        popupPlacement: "right",
        onClick: handleShowIntegrals,
        defaultValue: showRangesIntegrals,
        disabled: !ranges || !ranges.values || ranges.values.length === 0,
        children: /* @__PURE__ */ jsx(SvgIntegrate, {
          style: {
            pointerEvents: "none",
            fontSize: "12px"
          }
        })
      }), /* @__PURE__ */ jsx(ToggleButton$2, {
        className: "icon",
        popupTitle: "fix integral values",
        popupPlacement: "right",
        onClick: changeSumConstantFlagHandler,
        children: /* @__PURE__ */ jsx(ImLink, {})
      })]
    })
  });
}
const styles$u = {
  container: {
    padding: 10,
    backgroundColor: "#f1f1f1",
    height: "100%",
    overflowY: "auto"
  },
  groupContainer: {
    padding: "5px",
    borderRadius: "5px",
    margin: "10px 0px",
    backgroundColor: "white"
  },
  row: {
    display: "flex",
    margin: "5px 0px"
  },
  header: {
    borderBottom: "1px solid #e8e8e8",
    paddingBottom: "5px",
    fontWeight: "bold",
    color: "#4a4a4a"
  },
  inputLabel: {
    flex: 2
  },
  inputWrapper: {
    width: "100px",
    flex: "4",
    borderRadius: "5px"
  }
};
const formatFields$1 = [{
  id: 1,
  label: "From :",
  checkController: "showFrom",
  formatController: "fromFormat"
}, {
  id: 2,
  label: "To :",
  checkController: "showTo",
  formatController: "toFormat"
}, {
  id: 3,
  label: "Absolute :",
  checkController: "showAbsolute",
  formatController: "absoluteFormat"
}, {
  id: 4,
  label: "Relative :",
  checkController: "showRelative",
  formatController: "relativeFormat"
}];
function RangesPreferencesInner({
  nucleus,
  preferences,
  innerRef
}) {
  const alert2 = useAlert();
  const formRef = react.exports.useRef();
  const updateValues = react.exports.useCallback(() => {
    if (nucleus) {
      const defaultValues = nucleus.reduce((acc, nucleusLabel) => {
        acc[nucleusLabel] = getRangeDefaultValues(nucleusLabel);
        return acc;
      }, {});
      const rangesPreferences = getValue(preferences.current, `formatting.panels.ranges`);
      formRef.current.setValues(rangesPreferences ? rangesPreferences : defaultValues);
    }
  }, [nucleus, preferences]);
  react.exports.useEffect(() => {
    updateValues();
  }, [updateValues]);
  const saveHandler = react.exports.useCallback((values) => {
    preferences.dispatch({
      type: "SET_PANELS_PREFERENCES",
      payload: {
        key: "ranges",
        value: values
      }
    });
    alert2.success("ranges preferences saved successfully");
  }, [alert2, preferences]);
  react.exports.useImperativeHandle(innerRef, () => ({
    saveSetting: () => {
      formRef.current.submitForm();
    }
  }), []);
  return /* @__PURE__ */ jsx$1("div", {
    style: styles$u.container,
    children: /* @__PURE__ */ jsx$1(FormikForm, {
      onSubmit: saveHandler,
      ref: formRef,
      children: nucleus == null ? void 0 : nucleus.map((nucleusLabel) => /* @__PURE__ */ jsxs$1("div", {
        style: styles$u.groupContainer,
        children: [/* @__PURE__ */ jsx$1(IsotopesViewer, {
          style: styles$u.header,
          value: nucleusLabel
        }), formatFields$1.map((field) => /* @__PURE__ */ jsx$1(FormikColumnFormatField$1, {
          label: field.label,
          checkControllerName: `${nucleusLabel}.${field.checkController}`,
          formatControllerName: `${nucleusLabel}.${field.formatController}`
        }, field.id)), /* @__PURE__ */ jsx$1(Label, {
          title: "J Graph tolerance (Hz) :",
          style: {
            label: styles$u.inputLabel,
            wrapper: styles$u.inputWrapper
          },
          children: /* @__PURE__ */ jsx$1(FormikInput, {
            name: `${nucleusLabel}.jGraphTolerance`,
            type: "number"
          })
        })]
      }, nucleusLabel))
    })
  });
}
const MemoizedRangesPreferences = react.exports.memo(RangesPreferencesInner);
function RangesPreferences(prop, ref) {
  const nucleus = useNucleus();
  const preferences = usePreferences();
  return /* @__PURE__ */ jsx$1(MemoizedRangesPreferences, {
    innerRef: ref,
    preferences,
    nucleus
  });
}
var RangesPreferences$1 = react.exports.forwardRef(RangesPreferences);
function useTableSortBy(items, config = null) {
  const [sortConfig, setSortConfig] = react.exports.useState(config);
  const sortedItems = react.exports.useMemo(() => {
    const sortableItems = items.slice();
    if (sortConfig !== null) {
      sortableItems.sort((a, b) => {
        if (sortConfig.direction === "asc") {
          return get_1(a, sortConfig.key, 0) - get_1(b, sortConfig.key, 0);
        } else if (sortConfig.direction === "desc") {
          return get_1(b, sortConfig.key, 0) - get_1(a, sortConfig.key, 0);
        }
        return 0;
      });
    }
    return sortableItems;
  }, [items, sortConfig]);
  const sortHandler = react.exports.useCallback((event) => {
    var _a;
    const key = (_a = event.currentTarget) == null ? void 0 : _a.id;
    let direction = "asc";
    if (key && sortConfig && sortConfig.key === key) {
      switch (sortConfig.direction) {
        case "asc":
          direction = "desc";
          break;
        case "desc":
          direction = "original";
          break;
        default:
          direction = "asc";
          break;
      }
    }
    setSortConfig({
      key,
      direction
    });
  }, [sortConfig]);
  const isSortedDesc = react.exports.useCallback((columnName) => {
    const defaultContent = {
      flag: null,
      content: " "
    };
    if (!sortConfig || sortConfig.key !== columnName) {
      return defaultContent;
    }
    switch (sortConfig.direction) {
      case "desc":
        return {
          flag: true,
          content: " \u25BC"
        };
      case "asc":
        return {
          flag: false,
          content: " \u25B2"
        };
      default:
        return defaultContent;
    }
  }, [sortConfig]);
  return {
    items: sortedItems,
    isSortedDesc,
    onSort: {
      onClick: sortHandler
    }
  };
}
function isColumnVisible(preferences, key) {
  return get_1(preferences, key, false);
}
function AbsoluteColumn({
  rowSpanTags,
  value,
  onHoverRange,
  format: format2
}) {
  return /* @__PURE__ */ jsx$1("td", __spreadProps(__spreadValues(__spreadValues({}, rowSpanTags), onHoverRange), {
    children: FormatNumber(value, format2)
  }));
}
const FormikOnChange = (props) => {
  const {
    onChange = () => null,
    enableValidation = true
  } = props;
  const {
    values,
    errors
  } = useFormikContext();
  react.exports.useEffect(() => {
    if (enableValidation) {
      if (Object.keys(errors).length === 0) {
        onChange(values);
      }
    } else {
      onChange(values);
    }
  }, [values, enableValidation, errors, onChange]);
  return null;
};
const styles$t = {
  container: css`
    text-align: center;
    width: 100%;
    height: 100%;
    padding: 0.4rem;
  `,
  inputInfo: css`
    font-size: 10px;
    color: black;
    font-weight: bold;
  `,
  infoText: css`
    padding: 10px;
    font-size: 13px;
  `,
  signalContainer: css`
    border: 0.55px solid #dedede;
  `,
  inputContainer: css`
    display: flex;
    justify-content: center;
  `,
  addSignalBtn: css`
    margin-top: 15px;
    margin-top: 20px;
    width: 100%;
    background-color: #fcfcfc;
    border-top: 0.55px solid #dedede;
    align-items: center;
    justify-content: center;
    display: flex;
    padding: 0.4rem;
    font-size: 12px;

    & :disabled {
      opacity: 0.6;
    }
  `
};
function AddSignalFormTab({
  onFocus,
  onBlur,
  range: range2
}, ref) {
  const {
    values,
    setFieldValue
  } = useFormikContext();
  const {
    activeTab
  } = useChartData();
  const format2 = useFormatNumberByNucleus(activeTab);
  const saveHandler = react.exports.useCallback((val) => {
    const newSignal = {
      multiplicity: "m",
      kind: "signal",
      delta: Number(val.newSignalDelta),
      js: [{
        multiplicity: translateMultiplet("m"),
        coupling: ""
      }]
    };
    const _signals = values.signals.slice().concat(newSignal);
    setFieldValue("signals", _signals);
    setFieldValue("activeTab", String(_signals.length - 1));
  }, [setFieldValue, values.signals]);
  const validation2 = react.exports.useMemo(() => {
    return create().shape({
      newSignalDelta: create$1().test(`test-range`, "", function testNewSignalDelta(value) {
        const {
          path,
          createError
        } = this;
        if (value && value > range2.from && value < range2.to) {
          return true;
        }
        const errorMessage = ` ${value ? value.toFixed(5) : 0} ppm out of the range`;
        return createError({
          path,
          message: errorMessage
        });
      }).required()
    });
  }, [range2]);
  const triggerSubmitHandler = react.exports.useCallback(() => {
    ref.current.submitForm();
  }, [ref]);
  return /* @__PURE__ */ jsx("div", {
    css: styles$t.container,
    children: /* @__PURE__ */ jsxs("div", {
      children: [/* @__PURE__ */ jsx("p", {
        css: styles$t.infoText,
        children: "Edit or select a delta value of new signal (ppm):"
      }), /* @__PURE__ */ jsxs(FormikForm, {
        ref,
        validationSchema: validation2,
        initialValues: {
          newSignalDelta: (range2.from + range2.to) / 2
        },
        onSubmit: saveHandler,
        children: [/* @__PURE__ */ jsx("div", {
          css: styles$t.inputContainer,
          children: /* @__PURE__ */ jsx(FormikInput, {
            name: "newSignalDelta",
            type: "number",
            placeholder: `\u{1D6C5} (ppm)`,
            onFocus,
            onBlur,
            style: {
              input: {
                width: "250px",
                height: "30px"
              }
            },
            checkErrorAfterInputTouched: false
          })
        }), /* @__PURE__ */ jsxs("p", {
          css: styles$t.inputInfo,
          children: ["[ ", `${format2(range2.from)} ppm - ${format2(range2.to)} ppm`, " ]"]
        }), /* @__PURE__ */ jsx(Button, {
          css: styles$t.addSignalBtn,
          onClick: triggerSubmitHandler,
          children: /* @__PURE__ */ jsx(FaPlus, {
            title: "Add new signal"
          })
        })]
      })]
    })
  });
}
var AddSignalFormTab$1 = react.exports.forwardRef(AddSignalFormTab);
const style$5 = {
  input: {
    width: "50px",
    height: "26px",
    borderWidth: 0,
    margin: "0 5px"
  }
};
function DeltaInput({
  signal,
  index: index2,
  onFocus
}) {
  return /* @__PURE__ */ jsxs$1("div", {
    style: {
      display: "flex",
      alignItems: "center"
    },
    children: [/* @__PURE__ */ jsx$1("span", {
      children: "\u{1D6C5}: "
    }), /* @__PURE__ */ jsx$1(FormikInput, {
      name: `signals.${index2}.delta`,
      type: "number",
      placeholder: "J (Hz)",
      onFocus,
      style: style$5,
      checkErrorAfterInputTouched: false
    }), /* @__PURE__ */ jsx$1("span", {
      children: signal.js.map((_coupling) => translateMultiplet(_coupling.multiplicity)).join("")
    })]
  });
}
const CouplingsTableStyle = css`
  border-spacing: 0;
  border: 1px solid #dedede;
  width: 100%;
  height: 100%;
  font-size: 12px;

  th,
  td {
    text-align: center;
    margin: 0;
    padding: 0.3rem;
    border-bottom: 1px solid #f5f5f5;

    button {
      background-color: transparent;
      border: none;
    }

    .add-button {
      color: blue;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .delete-button {
      border-radius: 25%;
      padding: 0;
      padding-left: 0.3rem;
      padding-right: 0.3rem;
    }
    .delete-button:hover {
      .icon {
        color: red;
      }
    }

    input {
      background-color: transparent;
      border: 0.5px solid #dedede;
      height: 100%;
      width: 100%;
      text-align: center;
    }
    .selectBox {
      background-color: transparent;
      border: 0.5px solid #dedede;
      height: 100%;
      width: 100% !important;
      text-align: center;
      margin: 0;
    }
  }

  tr {
    :last-child {
      background-color: #fcfcfc;
    }
  }
`;
function CouplingsTable({
  push,
  remove,
  onFocus,
  onBlur
}) {
  const {
    values,
    setFieldValue
  } = useFormikContext();
  const multiplicityChangeHandler = react.exports.useCallback((value, name2) => {
    if (!hasCouplingConstant(value)) {
      setFieldValue(name2, "");
    }
  }, [setFieldValue]);
  const multipletsList = react.exports.useMemo(() => {
    return Multiplets.map((multiplet) => __spreadProps(__spreadValues({
      key: multiplet.value
    }, multiplet), {
      value: multiplet.label
    }));
  }, []);
  return /* @__PURE__ */ jsx("table", {
    css: CouplingsTableStyle,
    children: /* @__PURE__ */ jsxs("tbody", {
      children: [/* @__PURE__ */ jsxs("tr", {
        children: [/* @__PURE__ */ jsx("th", {
          children: "#"
        }), /* @__PURE__ */ jsx("th", {
          children: "Multiplicity"
        }), /* @__PURE__ */ jsx("th", {
          children: "J (Hz)"
        }), /* @__PURE__ */ jsx("th", {
          children: ""
        })]
      }), get_1(values, `signals[${values.activeTab}].js`, []).map((_coupling, i) => /* @__PURE__ */ jsxs("tr", {
        children: [/* @__PURE__ */ jsx("td", {
          children: i + 1
        }), /* @__PURE__ */ jsx("td", {
          children: /* @__PURE__ */ jsx(FormikSelect, {
            className: "selectBox",
            name: `signals.${values.activeTab}.js.${i}.multiplicity`,
            data: multipletsList,
            onChange: (value) => multiplicityChangeHandler(value, `signals.${values.activeTab}.js.${i}.coupling`)
          })
        }), /* @__PURE__ */ jsx("td", {
          children: /* @__PURE__ */ jsx(FormikInput, {
            name: `signals.${values.activeTab}.js.${i}.coupling`,
            type: "number",
            placeholder: "J (Hz)",
            disabled: !hasCouplingConstant(_coupling.multiplicity),
            onFocus,
            onBlur,
            style: {
              input: {
                width: "100%",
                height: "26px"
              }
            },
            checkErrorAfterInputTouched: false
          })
        }), /* @__PURE__ */ jsx("td", {
          children: /* @__PURE__ */ jsx(Button, {
            className: "delete-button",
            onClick: () => {
              remove(i);
            },
            children: /* @__PURE__ */ jsx(FaRegTrashAlt, {
              className: "icon",
              title: "Delete coupling"
            })
          })
        })]
      }, `editCouplings${values.activeTab}${i}`)), /* @__PURE__ */ jsx("tr", {}), /* @__PURE__ */ jsx("tr", {
        children: /* @__PURE__ */ jsx("td", {
          colSpan: 4,
          children: /* @__PURE__ */ jsx(Button, {
            className: "add-button",
            onClick: () => push({
              multiplicity: translateMultiplet("m"),
              coupling: ""
            }),
            children: /* @__PURE__ */ jsx(FaPlus, {
              title: "Add new coupling"
            })
          })
        })
      })]
    })
  });
}
var CouplingsTable$1 = react.exports.memo(CouplingsTable);
const SignalFormTabStyle = css`
  border-spacing: 0;
  width: 100%;
  font-size: 12px;
  height: 100%;

  margin: 0;
  padding: 0.4rem;
  text-align: center;
`;
function SignalFormTab$1({
  onFocus,
  onBlur
}) {
  const {
    values
  } = useFormikContext();
  return /* @__PURE__ */ jsx("div", {
    css: SignalFormTabStyle,
    children: /* @__PURE__ */ jsx(FieldArray, {
      name: `signals.${values.activeTab}.js`,
      render: ({
        push,
        remove
      }) => /* @__PURE__ */ jsx("div", {
        children: /* @__PURE__ */ jsx(CouplingsTable$1, {
          push,
          remove,
          onFocus,
          onBlur
        })
      })
    })
  });
}
var SignalFormTab$2 = react.exports.memo(SignalFormTab$1);
const textStyles$1 = css`
  text-align: center;
  width: 100%;

  .errorText {
    color: red;
  }

  .infoText {
    padding: 10px;
    margin: 10px 0;
    font-size: 14px;
    text-align: left;
    color: white;
    background-color: #5f5f5f;
    border-radius: 5px;
  }
`;
const tabStylesAddition$1 = css`
  color: red;
`;
const tabStyles$1 = css`
  display: inline-grid;
  list-style: none;
  padding: 0.5rem 1.5rem;
`;
function SignalsForm$1({
  range: range2
}) {
  const newSignalFormRef = react.exports.useRef();
  const [activeField, setActiveField] = react.exports.useState(null);
  const {
    values,
    setFieldValue,
    errors
  } = useFormikContext();
  const {
    activeTab
  } = useChartData();
  const {
    info
  } = useSpectrum({
    info: {}
  });
  const format2 = useFormatNumberByNucleus(activeTab);
  react.exports.useEffect(() => {
    function handle(event) {
      if ((info == null ? void 0 : info.originFrequency) && activeField) {
        if (values.activeTab === "addSignalTab") {
          newSignalFormRef.current.setValues({
            [activeField]: (event.range[1] - event.range[0]) / 2 + event.range[0]
          });
        } else if (activeField.includes("delta")) {
          setFieldValue(activeField, (event.range[1] - event.range[0]) / 2 + event.range[0]);
        } else {
          const value = Number(format2(Math.abs(event.range[0] - event.range[1]) * info.originFrequency));
          setFieldValue(activeField, value);
        }
      }
      setActiveField(null);
    }
    Emitter.on("brushEnd", handle);
    return () => {
      Emitter.off("brushEnd", handle);
    };
  }, [activeField, setFieldValue, values.activeTab, format2, info]);
  react.exports.useEffect(() => {
    function handle(event) {
      if (activeField) {
        if (values.activeTab === "addSignalTab") {
          newSignalFormRef.current.setValues({
            [activeField]: event.xPPM
          });
        } else if (activeField.includes("delta")) {
          setFieldValue(activeField, event.xPPM);
        }
      }
      setActiveField(null);
    }
    Emitter.on("mouseClick", handle);
    return () => {
      Emitter.off("mouseClick", handle);
    };
  }, [values.activeTab, activeField, setFieldValue]);
  const handleOnFocus = react.exports.useCallback((event) => {
    setActiveField(event.target.name);
  }, [setActiveField]);
  const tapClickHandler = react.exports.useCallback(({
    tabid
  }) => {
    setFieldValue("activeTab", tabid);
  }, [setFieldValue]);
  const handleDeleteSignal2 = react.exports.useCallback(({
    tabid
  }) => {
    const _signals = values.signals.filter((_signal, i) => i !== Number(tabid));
    setFieldValue("signals", _signals);
  }, [setFieldValue, values.signals]);
  react.exports.useEffect(() => {
    setFieldValue("activeTab", values.signals.length > 0 ? (values.signals.length - 1).toString() : "addSignalTab");
  }, [setFieldValue, values.signals.length]);
  const tabContainsErrors = react.exports.useCallback((i) => {
    return (errors == null ? void 0 : errors.signals) && (errors == null ? void 0 : errors.signals[i]) ? true : false;
  }, [errors]);
  const signalFormTabs = react.exports.useMemo(() => {
    const signalTabs = values.signals.length > 0 ? values.signals.map((signal, i) => /* @__PURE__ */ jsx(Tab, {
      tabid: `${i}`,
      tabstyles: tabContainsErrors(i) ? tabStylesAddition$1 : tabStyles$1,
      canDelete: true,
      render: () => /* @__PURE__ */ jsx(DeltaInput, {
        signal,
        index: i,
        onFocus: handleOnFocus
      }),
      children: /* @__PURE__ */ jsx(SignalFormTab$2, {
        onFocus: handleOnFocus
      })
    }, `signalForm${i}`)) : [];
    const addSignalTab = /* @__PURE__ */ jsx(Tab, {
      tablabel: "+",
      tabid: "addSignalTab",
      canDelete: false,
      className: "add-signal-tab",
      children: /* @__PURE__ */ jsx(AddSignalFormTab$1, {
        onFocus: handleOnFocus,
        range: range2,
        ref: newSignalFormRef
      })
    }, "addSignalTab");
    return signalTabs.concat(addSignalTab);
  }, [handleOnFocus, range2, tabContainsErrors, values.signals]);
  const editSignalInfoText = /* @__PURE__ */ jsx("p", {
    className: "infoText",
    children: "Focus on an input field and press Shift + Drag & Drop to draw a coupling constant in spectrum view."
  });
  const addSignalInfoText = /* @__PURE__ */ jsx("p", {
    className: "infoText",
    children: "Focus on the input field and press Shift + Left mouse click to select new signal delta value in spectrum view."
  });
  return /* @__PURE__ */ jsxs("div", {
    children: [/* @__PURE__ */ jsx("div", {
      css: textStyles$1,
      children: errors.signals && (errors.signals.noSignals || errors.signals.noCouplings) ? /* @__PURE__ */ jsxs("div", {
        children: [/* @__PURE__ */ jsx("p", {
          className: "errorText",
          children: errors.signals.noSignals || errors.signals.noCouplings[0].message
        }), errors.signals.noSignals ? addSignalInfoText : null]
      }) : values.activeTab === "addSignalTab" ? addSignalInfoText : editSignalInfoText
    }), /* @__PURE__ */ jsx(Tabs$1, {
      activeTab: values.activeTab,
      onClick: tapClickHandler,
      onDelete: handleDeleteSignal2,
      children: signalFormTabs
    })]
  });
}
var SignalsForm$2 = react.exports.memo(SignalsForm$1);
const useValidation$1 = () => react.exports.useMemo(() => {
  return create().shape({
    signals: create$4().of(create().shape({
      j: create$4().of(create().shape({
        multiplicity: create$2().required(),
        coupling: create$5().test("checkValue", "", function testCoupling(value) {
          const { path, createError } = this;
          const hasCoupling = hasCouplingConstant(this.parent.multiplicity);
          if (!hasCoupling && isNaN(value) || hasCoupling && !isNaN(value)) {
            return true;
          }
          return createError({
            path,
            message: `${path} is required`
          });
        })
      })).min(1, "There must be at least one coupling in a signal")
    })).min(1, "There must be at least one signal in a range!")
  });
}, []);
const styles$s = css`
  width: 600px;
  height: 500px;
  padding: 5px;
  button:focus {
    outline: none;
  }
  .header {
    height: 24px;
    border-bottom: 1px solid #f0f0f0;
    display: flex;
    align-items: center;
    span {
      color: #464646;
      font-size: 15px;
      flex: 1;
      border-left: 1px solid #ececec;
      padding-left: 6px;
    }

    button {
      background-color: transparent;
      border: none;
      padding: 5px;

      svg {
        height: 16px;
      }
    }
  }
  .container {
    display: flex;
    margin: 30px 5px;
    input,
    button {
      padding: 5px;
      border: 1px solid gray;
      border-radius: 5px;
      height: 36px;
      margin: 2px;
    }
    input {
      flex: 10;
    }
    button {
      flex: 2;
      color: white;
      background-color: gray;
    }
  }
`;
function EditRangeModal({
  onSaveEditRangeModal = () => null,
  onCloseEditRangeModal = () => null,
  onZoomEditRangeModal = () => null,
  range: range2,
  automaticZoom = true
}) {
  const formRef = react.exports.useRef(null);
  const {
    activeTab
  } = useChartData();
  const dispatch = useDispatch();
  const format2 = useFormatNumberByNucleus(activeTab);
  const validation2 = useValidation$1();
  const handleOnZoom = react.exports.useCallback(() => {
    onZoomEditRangeModal(range2);
  }, [onZoomEditRangeModal, range2]);
  react.exports.useEffect(() => {
    if (automaticZoom) {
      handleOnZoom();
    }
  }, [automaticZoom, handleOnZoom]);
  const handleOnClose = react.exports.useCallback(() => {
    onCloseEditRangeModal();
  }, [onCloseEditRangeModal]);
  const getCouplings2 = react.exports.useCallback((couplings) => couplings.filter((coupling) => coupling.coupling !== "").map((coupling) => {
    return __spreadProps(__spreadValues({}, coupling), {
      multiplicity: translateMultiplet(coupling.multiplicity)
    });
  }), []);
  const getSignals = react.exports.useCallback((signals) => {
    return signals.map((signal) => {
      return __spreadProps(__spreadValues({
        id: generateID()
      }, signal), {
        multiplicity: signal.js.map((_coupling) => translateMultiplet(_coupling.multiplicity)).join(""),
        js: getCouplings2(signal.js)
      });
    });
  }, [getCouplings2]);
  const handleOnSave = react.exports.useCallback((formValues) => {
    void (async () => {
      const _range = __spreadValues({}, range2);
      _range.signals = getSignals(formValues.signals);
      await onSaveEditRangeModal(_range);
      handleOnClose();
    })();
  }, [getSignals, handleOnClose, onSaveEditRangeModal, range2]);
  const data = react.exports.useMemo(() => {
    const signals = range2.signals.map((signal) => {
      let counterJ = 0;
      const couplings = [];
      signal.multiplicity.split("").forEach((_multiplicity) => {
        let coupling = {
          multiplicity: _multiplicity,
          coupling: ""
        };
        if (hasCouplingConstant(_multiplicity)) {
          coupling = __spreadValues({}, signal.js[counterJ]);
          coupling.coupling = Number(format2(coupling.coupling));
          counterJ++;
        }
        coupling.multiplicity = translateMultiplet(coupling.multiplicity);
        couplings.push(coupling);
      });
      return __spreadProps(__spreadValues({}, signal), {
        js: couplings
      });
    });
    return {
      activeTab: "0",
      signals
    };
  }, [format2, range2]);
  const changeHandler = react.exports.useCallback((values) => {
    const signals = getSignals(values.signals);
    dispatch({
      type: CHANGE_TEMP_RANGE,
      payload: {
        tempRange: Object.assign({}, range2, {
          signals
        })
      }
    });
  }, [dispatch, getSignals, range2]);
  return /* @__PURE__ */ jsx("div", {
    css: styles$s,
    children: /* @__PURE__ */ jsxs(FormikForm, {
      ref: formRef,
      initialValues: data,
      validationSchema: validation2,
      onSubmit: handleOnSave,
      children: [/* @__PURE__ */ jsxs("div", {
        className: "header handle",
        children: [/* @__PURE__ */ jsx(Button, {
          onClick: handleOnZoom,
          className: "zoom-button",
          children: /* @__PURE__ */ jsx(FaSearchPlus, {
            title: "Set to default view on range in spectrum"
          })
        }), /* @__PURE__ */ jsx("span", {
          children: ` Range and Signal edition: ${format2(range2.from)} ppm to ${format2(range2.to)} ppm`
        }), /* @__PURE__ */ jsx(SaveButton$1, {
          onClick: () => formRef.current.submitForm(),
          popupTitle: "Save and exit"
        }), /* @__PURE__ */ jsx(CloseButton$1, {
          onClick: handleOnClose
        })]
      }), /* @__PURE__ */ jsx(SignalsForm$2, {
        range: range2
      }), /* @__PURE__ */ jsx(FormikOnChange, {
        onChange: changeHandler
      })]
    })
  });
}
function useEditRangeModal(range2) {
  const dispatch = useDispatch();
  const modal = useModal();
  const assignmentData = useAssignmentData();
  const zoomRange = react.exports.useCallback(() => {
    const margin = Math.abs(range2.from - range2.to);
    dispatch({
      type: SET_X_DOMAIN,
      xDomain: [range2.from - margin, range2.to + margin]
    });
  }, [dispatch, range2.from, range2.to]);
  const deleteRange = react.exports.useCallback(() => {
    dispatch({
      type: DELETE_RANGE,
      payload: {
        data: {
          id: range2.id,
          assignmentData
        }
      }
    });
  }, [assignmentData, dispatch, range2.id]);
  const changeRangeSignalKind = react.exports.useCallback((value) => {
    dispatch({
      type: CHANGE_RANGE_SIGNAL_KIND,
      payload: {
        data: {
          rowData: range2,
          value
        }
      }
    });
  }, [dispatch, range2]);
  const saveEditRangeHandler = react.exports.useCallback((editedRowData) => {
    dispatch({
      type: SAVE_EDITED_RANGE,
      payload: {
        editedRowData,
        assignmentData
      }
    });
  }, [assignmentData, dispatch]);
  const closeEditRangeHandler = react.exports.useCallback(() => {
    dispatch({
      type: RESET_SELECTED_TOOL
    });
    modal.close();
  }, [dispatch, modal]);
  const editRange = react.exports.useCallback(() => {
    dispatch({
      type: SET_SELECTED_TOOL,
      payload: {
        selectedTool: options.editRange.id,
        tempRange: range2
      }
    });
    modal.show(/* @__PURE__ */ jsx$1(EditRangeModal, {
      onCloseEditRangeModal: closeEditRangeHandler,
      onSaveEditRangeModal: saveEditRangeHandler,
      onZoomEditRangeModal: zoomRange,
      range: range2
    }), {
      position: positions.MIDDLE_RIGHT,
      transition: transitions.SCALE,
      isBackgroundBlur: false
    });
  }, [closeEditRangeHandler, dispatch, modal, range2, saveEditRangeHandler, zoomRange]);
  return react.exports.useMemo(() => ({
    editRange,
    deleteRange,
    zoomRange,
    changeRangeSignalKind
  }), [changeRangeSignalKind, deleteRange, editRange, zoomRange]);
}
const styles$r = css`
  width: 66px;
  padding: 0 !important;
  button {import useEditRangeModal from './../../../hooks/useEditRangeModal';

    background-color: transparent;
    border: none;
    padding: 5px;
  }

  button:disabled {
    opacity: 0.6;
  }
`;
const selectBoxStyle$1 = {
  marginLeft: 2,
  marginRight: 2,
  border: "none",
  height: "20px"
};
function ActionsColumn$1({
  rowData,
  onHoverSignal,
  rowSpanTags
}) {
  const {
    editRange,
    deleteRange,
    changeRangeSignalKind,
    zoomRange
  } = useEditRangeModal(rowData);
  return /* @__PURE__ */ jsxs(react.exports.Fragment, {
    children: [/* @__PURE__ */ jsx("td", __spreadProps(__spreadValues({}, onHoverSignal), {
      children: /* @__PURE__ */ jsx(Select, {
        onChange: changeRangeSignalKind,
        data: SignalKinds,
        defaultValue: rowData.tableMetaInfo.signal.kind,
        style: selectBoxStyle$1
      })
    })), /* @__PURE__ */ jsxs("td", __spreadProps(__spreadValues({}, rowSpanTags), {
      css: styles$r,
      children: [/* @__PURE__ */ jsx("button", {
        type: "button",
        className: "delete-button",
        onClick: deleteRange,
        children: /* @__PURE__ */ jsx(FaRegTrashAlt, {})
      }), /* @__PURE__ */ jsx("button", {
        type: "button",
        className: "zoom-button",
        onClick: zoomRange,
        children: /* @__PURE__ */ jsx(FaSearchPlus, {
          title: "Zoom to range in spectrum"
        })
      }), /* @__PURE__ */ jsx("button", {
        type: "button",
        className: "edit-button",
        onClick: editRange,
        children: /* @__PURE__ */ jsx(FaEdit, {
          color: "blue"
        })
      })]
    }))]
  });
}
function CouplingColumn({
  rowData,
  onHoverSignal
}) {
  const result = get_1(rowData, "tableMetaInfo.signal.js");
  return /* @__PURE__ */ jsx$1("td", __spreadProps(__spreadValues({}, onHoverSignal), {
    children: result == null ? void 0 : result.map((coupling) => !isNaN(coupling.coupling) ? coupling.coupling.toFixed(1) : "").join(",")
  }));
}
const spanStyle = {
  color: "red",
  fontWeight: "bold"
};
function RangeAssignmentsColumn({
  rowData,
  assignment,
  highlight,
  onUnlinkVisibilityChange,
  unlinkVisibility,
  onLink,
  onUnlink,
  rowSpanTags,
  onHover,
  highlightData
}) {
  var _a;
  const diaIDs = react.exports.useMemo(() => {
    return get_1(rowData, "diaIDs", 0);
  }, [rowData]);
  const visibilityChangeHandler = react.exports.useCallback((flag) => {
    onUnlinkVisibilityChange == null ? void 0 : onUnlinkVisibilityChange(flag);
  }, [onUnlinkVisibilityChange]);
  const spanCss = react.exports.useMemo(() => {
    var _a2;
    const flag = assignment.isActive || assignment.isOver || highlight.isActive && ((_a2 = highlightData.highlight.sourceData) == null ? void 0 : _a2.type) !== HighlightedSource.SIGNAL;
    return flag ? {
      color: "red",
      fontWeight: "bold"
    } : {
      color: "black",
      fontWeight: "normal"
    };
  }, [assignment.isActive, assignment.isOver, highlight.isActive, (_a = highlightData.highlight.sourceData) == null ? void 0 : _a.type]);
  return /* @__PURE__ */ jsx$1("td", __spreadProps(__spreadValues(__spreadValues({}, rowSpanTags), onHover), {
    onClick: (e2) => onLink == null ? void 0 : onLink(e2, assignment),
    children: rowData.nbAtoms !== void 0 && rowData.nbAtoms > 0 ? rowData.diaIDs && rowData.diaIDs.length > 0 ? /* @__PURE__ */ jsxs$1("div", {
      onMouseEnter: () => visibilityChangeHandler(true),
      onMouseLeave: () => visibilityChangeHandler(false),
      children: [rowData.nbAtoms, " ", " ( ", /* @__PURE__ */ jsx$1("span", {
        style: spanCss,
        children: diaIDs.length
      }), " ) ", /* @__PURE__ */ jsx$1("sup", {
        children: /* @__PURE__ */ jsx$1("button", {
          type: "button",
          style: {
            visibility: unlinkVisibility ? "visible" : "hidden",
            padding: 0,
            margin: 0
          },
          onClick: (e2) => onUnlink == null ? void 0 : onUnlink(e2, true),
          children: /* @__PURE__ */ jsx$1(FaMinusCircle, {
            color: "red"
          })
        })
      })]
    }) : assignment.isActive ? /* @__PURE__ */ jsxs$1("div", {
      children: [`${rowData.nbAtoms} (`, /* @__PURE__ */ jsx$1("span", {
        style: spanStyle,
        children: "0"
      }), ")"]
    }) : rowData.nbAtoms : assignment.isActive ? /* @__PURE__ */ jsxs$1("div", {
      children: ["0 (", /* @__PURE__ */ jsx$1("span", {
        style: spanStyle,
        children: "0"
      }), ")"]
    }) : ""
  }));
}
var RangeAssignmentsColumn$1 = react.exports.memo(RangeAssignmentsColumn);
function RangeColumn({
  value,
  rowSpanTags,
  onHoverRange,
  format: format2
}) {
  return /* @__PURE__ */ jsx$1("td", __spreadProps(__spreadValues(__spreadValues({}, rowSpanTags), onHoverRange), {
    children: FormatNumber(value, format2)
  }));
}
var RangeColumn$1 = react.exports.memo(RangeColumn);
function RelativeColumn({
  rowData,
  rowSpanTags,
  onHoverRange,
  format: format2
}) {
  const dispatch = useDispatch();
  const integralVal = react.exports.useMemo(() => {
    const flag = checkRangeKind$1(rowData);
    const formattedValue = FormatNumber(rowData.integration, format2);
    return flag ? formattedValue : `[ ${formattedValue} ]`;
  }, [format2, rowData]);
  const saveHandler = react.exports.useCallback((event) => {
    dispatch({
      type: CHANGE_RANGE_RELATIVE,
      payload: {
        data: {
          value: event.target.value,
          id: rowData.id
        }
      }
    });
  }, [dispatch, rowData.id]);
  return /* @__PURE__ */ jsx$1("td", __spreadProps(__spreadValues(__spreadValues({}, rowSpanTags), onHoverRange), {
    children: /* @__PURE__ */ jsx$1(EditableColumn$1, {
      value: integralVal,
      onSave: saveHandler,
      type: "number",
      style: {
        padding: "0.1rem 0.4rem"
      }
    })
  }));
}
function SignalAssignmentsColumn$1({
  rowData,
  onHover,
  assignment,
  highlight,
  onUnlinkVisibilityChange,
  unlinkVisibility,
  onLink,
  onUnlink
}) {
  const diaIDs = react.exports.useMemo(() => {
    return get_1(rowData, "tableMetaInfo.signal.diaIDs", []);
  }, [rowData]);
  const tdCss = react.exports.useMemo(() => {
    return assignment.isActive || highlight.isActive ? {
      color: "red",
      fontWeight: "bold"
    } : void 0;
  }, [assignment.isActive, highlight.isActive]);
  const visibilityChangeHandler = react.exports.useCallback((flag) => {
    onUnlinkVisibilityChange == null ? void 0 : onUnlinkVisibilityChange(flag);
  }, [onUnlinkVisibilityChange]);
  const assignHandler = react.exports.useCallback((e2) => {
    onLink == null ? void 0 : onLink(e2, assignment);
  }, [assignment, onLink]);
  return /* @__PURE__ */ jsx$1("td", __spreadProps(__spreadValues({}, onHover), {
    onClick: assignHandler,
    style: tdCss,
    children: diaIDs && diaIDs.length > 0 ? /* @__PURE__ */ jsxs$1("div", {
      onMouseEnter: () => visibilityChangeHandler(true),
      onMouseLeave: () => visibilityChangeHandler(false),
      children: [diaIDs.length, " ", /* @__PURE__ */ jsx$1("sup", {
        children: /* @__PURE__ */ jsx$1("button", {
          type: "button",
          style: {
            visibility: unlinkVisibility ? "visible" : "hidden",
            padding: 0,
            margin: 0
          },
          onClick: (e2) => onUnlink == null ? void 0 : onUnlink(e2, false),
          children: /* @__PURE__ */ jsx$1(FaMinusCircle, {
            color: "red"
          })
        })
      })]
    }) : assignment.isActive ? "0" : ""
  }));
}
var SignalAssignmentsColumn$2 = react.exports.memo(SignalAssignmentsColumn$1);
function useFormat(preferences) {
  return (value, keysPath, prefix = "", suffix = "") => {
    const format2 = get_1(preferences, keysPath, "0.000");
    return FormatNumber(value, format2, prefix, suffix);
  };
}
function SignalDeltaColumn$1({
  rowData,
  onHoverSignal,
  preferences
}) {
  const dispatch = useDispatch();
  const signal = rowData.tableMetaInfo.signal;
  const format2 = useFormat(preferences);
  const saveHandler = react.exports.useCallback((event) => {
    dispatch({
      type: CHANGE_RANGE_SIGNAL_VALUE,
      payload: {
        value: event.target.value,
        rangeID: rowData.id,
        signalID: signal.id
      }
    });
  }, [dispatch, rowData.id, signal.id]);
  if (!signal)
    return /* @__PURE__ */ jsx$1("td", {
      children: ""
    });
  return /* @__PURE__ */ jsx$1("td", __spreadProps(__spreadValues({}, onHoverSignal), {
    children: !checkMultiplicity(signal.multiplicity, ["m"]) ? `${format2(rowData.from, "fromFormat")} - ${format2(rowData.to, "toFormat")}` : /* @__PURE__ */ jsx$1(EditableColumn$1, {
      value: signal.delta.toFixed(3),
      onSave: saveHandler,
      type: "number",
      style: {
        padding: "0.1rem 0.4rem"
      }
    })
  }));
}
const HighlightedRowStyle$1 = css`
  background-color: #ff6f0057;
`;
const ConstantlyHighlightedRowStyle$1 = css`
  background-color: #f5f5dc;
`;
function RangesTableRow({
  rowData,
  onUnlink,
  onContextMenu,
  preferences
}) {
  var _a, _b, _c;
  const assignmentData = useAssignmentData();
  const assignmentRange = useAssignment(rowData.id);
  const highlightRange = useHighlight([assignmentRange.id].concat(((_a = assignmentRange.assigned) == null ? void 0 : _a.x) || []).concat(filterForIDsWithAssignment(assignmentData, rowData.signals.map((_signal) => _signal.id))), {
    type: HighlightedSource.RANGE
  });
  const highlightRangeAssignmentsColumn = useHighlight(((_b = assignmentRange.assigned) == null ? void 0 : _b.x) || [], {
    type: HighlightedSource.RANGE
  });
  const assignmentSignal = useAssignment(rowData.tableMetaInfo.id);
  const highlightSignal = useHighlight([assignmentSignal.id].concat(((_c = assignmentSignal.assigned) == null ? void 0 : _c.x) || []), {
    type: HighlightedSource.SIGNAL
  });
  const highlightData = useHighlightData();
  const [unlinkRangeButtonVisibility, showUnlinkRangeButton] = react.exports.useState(false);
  const [unlinkSignalButtonVisibility, showUnlinkSignalButton] = react.exports.useState(false);
  const getFormat = useFormat(preferences);
  const rowSpanTags = react.exports.useMemo(() => {
    return {
      rowSpan: rowData.tableMetaInfo.rowSpan,
      style: get_1(rowData.tableMetaInfo, "hide", false) ? {
        display: "none"
      } : void 0
    };
  }, [rowData.tableMetaInfo]);
  const unlinkHandler = react.exports.useCallback((e2, isOnRangeLevel) => {
    if (e2) {
      e2.stopPropagation();
    }
    if (isOnRangeLevel !== void 0) {
      if (isOnRangeLevel) {
        onUnlink(rowData);
        showUnlinkRangeButton(false);
        assignmentRange.removeAll("x");
      } else {
        onUnlink(rowData, get_1(rowData, "tableMetaInfo.signalIndex", void 0));
        showUnlinkSignalButton(false);
        assignmentSignal.removeAll("x");
      }
    } else {
      showUnlinkRangeButton(false);
      showUnlinkSignalButton(false);
    }
  }, [assignmentRange, assignmentSignal, onUnlink, rowData]);
  const linkHandler = react.exports.useCallback((e2, assignment) => {
    e2.stopPropagation();
    assignment.setActive("x");
  }, []);
  const onHoverRange = react.exports.useMemo(() => {
    return {
      onMouseEnter: () => {
        assignmentRange.show("x");
        highlightRange.show();
      },
      onMouseLeave: () => {
        assignmentRange.hide();
        highlightRange.hide();
      }
    };
  }, [assignmentRange, highlightRange]);
  const onHoverRangeAssignmentsColumn = react.exports.useMemo(() => {
    return {
      onMouseEnter: () => {
        assignmentRange.show("x");
        highlightRangeAssignmentsColumn.show();
      },
      onMouseLeave: () => {
        assignmentRange.hide();
        highlightRangeAssignmentsColumn.hide();
      }
    };
  }, [assignmentRange, highlightRangeAssignmentsColumn]);
  const onHoverSignal = react.exports.useMemo(() => {
    return {
      onMouseEnter: () => {
        assignmentSignal.show("x");
        highlightSignal.show();
      },
      onMouseLeave: () => {
        assignmentSignal.hide();
        highlightSignal.hide();
      }
    };
  }, [assignmentSignal, highlightSignal]);
  const trCss = react.exports.useMemo(() => {
    return highlightRange.isActive || assignmentRange.isActive ? HighlightedRowStyle$1 : get_1(rowData, "tableMetaInfo.isConstantlyHighlighted", false) ? ConstantlyHighlightedRowStyle$1 : null;
  }, [assignmentRange.isActive, highlightRange.isActive, rowData]);
  return /* @__PURE__ */ jsxs("tr", {
    onContextMenu: (e2) => onContextMenu(e2, rowData),
    css: trCss,
    children: [/* @__PURE__ */ jsx("td", __spreadProps(__spreadValues(__spreadValues({}, rowSpanTags), onHoverRange), {
      children: rowData.tableMetaInfo.rowIndex + 1
    })), isColumnVisible(preferences, "showFrom") && /* @__PURE__ */ jsx(RangeColumn$1, {
      value: rowData.from,
      rowSpanTags,
      onHoverRange,
      format: getFormat("showFrom", void 0)
    }), isColumnVisible(preferences, "showTo") && /* @__PURE__ */ jsx(RangeColumn$1, {
      value: rowData.to,
      rowSpanTags,
      onHoverRange,
      format: getFormat("toFormat", void 0)
    }), /* @__PURE__ */ jsx(SignalDeltaColumn$1, {
      rowData,
      onHoverSignal,
      preferences
    }), isColumnVisible(preferences, "showRelative") && /* @__PURE__ */ jsx(RelativeColumn, {
      rowData,
      rowSpanTags,
      onHoverRange,
      format: getFormat("relativeFormat", void 0)
    }), isColumnVisible(preferences, "showAbsolute") && /* @__PURE__ */ jsx(AbsoluteColumn, {
      value: rowData.absolute,
      rowSpanTags,
      onHoverRange,
      format: getFormat("absoluteFormat", void 0)
    }), /* @__PURE__ */ jsx("td", __spreadProps(__spreadValues({}, onHoverSignal), {
      children: get_1(rowData, "tableMetaInfo.signal.multiplicity", "")
    })), /* @__PURE__ */ jsx(CouplingColumn, {
      rowData,
      onHoverSignal
    }), /* @__PURE__ */ jsx(SignalAssignmentsColumn$2, {
      rowData,
      assignment: assignmentSignal,
      highlight: highlightSignal,
      onHover: onHoverSignal,
      unlinkVisibility: unlinkSignalButtonVisibility,
      onUnlinkVisibilityChange: (flag) => showUnlinkSignalButton(flag),
      onLink: linkHandler,
      onUnlink: unlinkHandler
    }), /* @__PURE__ */ jsx(RangeAssignmentsColumn$1, {
      rowData,
      assignment: assignmentRange,
      highlight: highlightRangeAssignmentsColumn,
      onHover: onHoverRangeAssignmentsColumn,
      unlinkVisibility: unlinkRangeButtonVisibility,
      onUnlinkVisibilityChange: (flag) => showUnlinkRangeButton(flag),
      onLink: linkHandler,
      onUnlink: unlinkHandler,
      rowSpanTags,
      highlightData
    }), /* @__PURE__ */ jsx(ActionsColumn$1, {
      rowData,
      onHoverSignal,
      onHoverRange,
      rowSpanTags
    })]
  });
}
function useMapRanges(data) {
  return react.exports.useMemo(() => {
    const _rangesData = [];
    data.forEach((range2, i) => {
      if (range2.signals.length === 1) {
        _rangesData.push(__spreadProps(__spreadValues({
          rowKey: generateID()
        }, range2), {
          tableMetaInfo: __spreadProps(__spreadValues({}, range2.tableMetaInfo), {
            signal: range2.signals[0],
            rowIndex: i,
            signalIndex: 0,
            id: range2.signals[0].id
          })
        }));
      } else if (range2.signals.length > 1) {
        range2.signals.forEach((signal, j) => {
          let hide = false;
          let rowSpan = null;
          if (j < range2.signals.length - 1) {
            if (j === 0) {
              rowSpan = range2.signals.length;
            } else {
              hide = true;
            }
          } else {
            hide = true;
          }
          _rangesData.push(__spreadProps(__spreadValues({
            rowKey: generateID()
          }, range2), {
            tableMetaInfo: __spreadProps(__spreadValues({}, range2.tableMetaInfo), {
              signal,
              rowSpan,
              hide,
              rowIndex: i,
              signalIndex: j,
              id: signal.id
            })
          }));
        });
      }
    });
    return _rangesData;
  }, [data]);
}
const tableStyle$2 = css`
  border-spacing: 0;
  border: 1px solid #dedede;
  width: 100%;
  font-size: 12px;
  .react-contextmenu-wrapper {
    display: contents;
  }
  tr {
    :last-child {
      td {
        border-bottom: 0;
      }
    }
  }
  th {
    position: sticky;
    top: 0;
    background-color: white;
    z-index: 1;
  }
  th,
  td {
    white-space: nowrap;
    text-align: center;
    margin: 0;
    padding: 0.1rem 0.4rem;
    border-bottom: 1px solid #dedede;
    border-right: 1px solid #dedede;

    :last-child {
      border-right: 0;
    }
    button {
      background-color: transparent;
      border: none;
    }
  }
`;
function RangesTable({
  tableData,
  onUnlink,
  context,
  activeTab,
  preferences
}) {
  const element = activeTab == null ? void 0 : activeTab.replace(/[0-9]/g, "");
  const contextRef = react.exports.useRef();
  const {
    items: sortedData,
    isSortedDesc,
    onSort
  } = useTableSortBy(tableData);
  const data = useMapRanges(sortedData);
  const isVisible = (key) => {
    return get_1(preferences, key, false);
  };
  const contextMenuHandler = react.exports.useCallback((e2, rowData) => {
    if (!checkModifierKeyActivated(e2)) {
      e2.preventDefault();
      contextRef.current.handleContextMenu(e2, rowData);
    }
  }, [contextRef]);
  return /* @__PURE__ */ jsxs(react.exports.Fragment, {
    children: [/* @__PURE__ */ jsxs("table", {
      css: tableStyle$2,
      children: [/* @__PURE__ */ jsx("thead", {
        children: /* @__PURE__ */ jsxs("tr", {
          children: [/* @__PURE__ */ jsx("th", {
            children: "#"
          }), isVisible("showFrom") ? /* @__PURE__ */ jsxs("th", __spreadProps(__spreadValues({
            id: "from"
          }, onSort), {
            children: ["From", isSortedDesc("from").content]
          })) : null, isVisible("showTo") ? /* @__PURE__ */ jsxs("th", __spreadProps(__spreadValues({
            id: "to"
          }, onSort), {
            children: ["To ", isSortedDesc("to").content]
          })) : null, /* @__PURE__ */ jsx("th", {
            children: "\u03B4 (ppm) "
          }), isVisible("showRelative") ? /* @__PURE__ */ jsxs("th", __spreadProps(__spreadValues({
            id: "integration"
          }, onSort), {
            children: ["Rel. ", element, " ", isSortedDesc("integration").content]
          })) : null, isVisible("showAbsolute") ? /* @__PURE__ */ jsx("th", {
            children: "Absolute"
          }) : null, /* @__PURE__ */ jsx("th", {
            children: "Mult."
          }), /* @__PURE__ */ jsx("th", {
            children: "J (Hz)"
          }), /* @__PURE__ */ jsx("th", {
            children: /* @__PURE__ */ jsx(FaLink, {
              style: {
                fontSize: 10
              }
            })
          }), /* @__PURE__ */ jsx("th", {
            children: "\u03A3"
          }), /* @__PURE__ */ jsx("th", {
            children: "Kind"
          }), /* @__PURE__ */ jsx("th", {
            children: ""
          })]
        })
      }), /* @__PURE__ */ jsx("tbody", {
        children: data == null ? void 0 : data.map((range2) => {
          return /* @__PURE__ */ jsx(RangesTableRow, {
            rowData: range2,
            onUnlink,
            onContextMenu: (e2, rowData) => contextMenuHandler(e2, rowData),
            preferences
          }, range2.rowKey);
        })
      })]
    }), /* @__PURE__ */ jsx(ContextMenu$1, {
      ref: contextRef,
      context
    })]
  });
}
function RangesTablePanelInner({
  ranges,
  data,
  info,
  xDomain,
  preferences,
  activeTab,
  molecules,
  showMultiplicityTrees,
  showJGraph,
  showRangesIntegrals
}) {
  const [isFilterActive, setFilterIsActive] = react.exports.useState(false);
  const assignmentData = useAssignmentData();
  const dispatch = useDispatch();
  const alert2 = useAlert();
  const [isFlipped, setFlipStatus] = react.exports.useState(false);
  const settingRef = react.exports.useRef();
  const rangesData = react.exports.useMemo(() => {
    const isInView2 = (from, to) => {
      const factor = 1e4;
      to = to * factor;
      from = from * factor;
      return to >= xDomain[0] * factor && from <= xDomain[1] * factor || from <= xDomain[0] * factor && to >= xDomain[1] * factor;
    };
    const getFilteredRanges = (ranges2) => {
      return ranges2.filter((range2) => isInView2(range2.from, range2.to));
    };
    if (ranges.values) {
      const _ranges = isFilterActive ? getFilteredRanges(ranges.values) : ranges.values;
      return _ranges.map((range2) => {
        return __spreadProps(__spreadValues({}, range2), {
          tableMetaInfo: {
            isConstantlyHighlighted: isInView2(range2.from, range2.to)
          }
        });
      });
    }
    return [];
  }, [isFilterActive, ranges.values, xDomain]);
  const unlinkRangeHandler = react.exports.useCallback((rangeData, signalIndex = -1) => {
    dispatch({
      type: UNLINK_RANGE,
      payload: {
        rangeData,
        assignmentData,
        signalIndex
      }
    });
  }, [assignmentData, dispatch]);
  const saveJSONToClipboardHandler = react.exports.useCallback(async (value) => {
    if (data.x && data.re) {
      const {
        x,
        re
      } = data;
      const {
        from,
        to
      } = value;
      const {
        fromIndex,
        toIndex
      } = xGetFromToIndex(x, {
        from,
        to
      });
      const dataToClipboard = __spreadValues({
        x: Array.from(x.slice(fromIndex, toIndex)),
        y: Array.from(re.slice(fromIndex, toIndex))
      }, value);
      const success = await copyTextToClipboard(JSON.stringify(dataToClipboard, void 0, 2));
      if (success) {
        alert2.show("Data copied to clipboard");
      } else {
        alert2.error("copy to clipboard failed");
      }
    }
  }, [data, alert2]);
  const rangesPreferences = react.exports.useMemo(() => {
    const _preferences = get_1(preferences.current, `formatting.panels.ranges.[${activeTab}]`) || getRangeDefaultValues(activeTab);
    return _preferences;
  }, [activeTab, preferences]);
  const contextMenu = react.exports.useMemo(() => [{
    label: "Copy to clipboard",
    onClick: saveJSONToClipboardHandler
  }], [saveJSONToClipboardHandler]);
  const filterHandler = react.exports.useCallback(() => {
    setFilterIsActive(!isFilterActive);
  }, [isFilterActive]);
  const settingsPanelHandler = react.exports.useCallback(() => {
    setFlipStatus(!isFlipped);
  }, [isFlipped]);
  const saveSettingHandler = react.exports.useCallback(() => {
    settingRef.current.saveSetting();
    setFlipStatus(false);
  }, []);
  return /* @__PURE__ */ jsx(Fragment, {
    children: /* @__PURE__ */ jsxs("div", {
      css: [tablePanelStyle, isFlipped && css`
              th {
                position: relative;
              }
            `],
      children: [!isFlipped && /* @__PURE__ */ jsx(RangesHeader, {
        ranges,
        info,
        activeTab,
        molecules,
        showRangesIntegrals,
        showMultiplicityTrees,
        showJGraph,
        isFilterActive,
        onUnlink: unlinkRangeHandler,
        onFilterActivated: filterHandler,
        onSettingClick: settingsPanelHandler,
        filterCounter: rangesData.length
      }), isFlipped && /* @__PURE__ */ jsx(PreferencesHeader$1, {
        onSave: saveSettingHandler,
        onClose: settingsPanelHandler
      }), /* @__PURE__ */ jsx("div", {
        className: "inner-container",
        children: !isFlipped ? /* @__PURE__ */ jsx("div", {
          className: "table-container",
          children: rangesData && rangesData.length > 0 ? /* @__PURE__ */ jsx(RangesTable, {
            activeTab,
            tableData: rangesData,
            onUnlink: unlinkRangeHandler,
            context: contextMenu,
            preferences: rangesPreferences
          }) : /* @__PURE__ */ jsx(NoTableData, {})
        }) : /* @__PURE__ */ jsx(RangesPreferences$1, {
          ref: settingRef
        })
      })]
    })
  });
}
const MemoizedRangesTablePanel = react.exports.memo(RangesTablePanelInner);
const emptyData$5 = {
  ranges: {},
  data: {},
  info: {}
};
function RangesTablePanel() {
  const {
    displayerKey,
    xDomain,
    activeTab,
    molecules,
    toolOptions: {
      selectedTool,
      data: {
        showMultiplicityTrees,
        showRangesIntegrals,
        showJGraph
      }
    }
  } = useChartData();
  const {
    ranges,
    data,
    info
  } = useSpectrum(emptyData$5);
  const preferences = usePreferences();
  return /* @__PURE__ */ jsx(MemoizedRangesTablePanel, {
    ranges,
    data,
    info,
    showMultiplicityTrees,
    showJGraph,
    showRangesIntegrals,
    selectedTool,
    displayerKey,
    preferences,
    xDomain,
    activeTab,
    molecules
  });
}
function SpectraPanelHeaderInner({
  data,
  activeSpectrum,
  activeTab,
  displayerMode,
  spectrums
}) {
  const modal = useModal();
  const alert2 = useAlert();
  const dispatch = useDispatch();
  const handleDelete = react.exports.useCallback(() => {
    modal.showConfirmDialog({
      message: "All records will be deleted, Are You sure?",
      buttons: [{
        text: "Yes",
        handler: () => {
          dispatch({
            type: DELETE_SPECTRA
          });
        }
      }, {
        text: "No"
      }]
    });
  }, [dispatch, modal]);
  const showAllSpectrumsHandler = react.exports.useCallback(() => {
    const spectrumsPerTab = spectrums.map((datum) => {
      return datum.id;
    });
    dispatch({
      type: CHANGE_VISIBILITY,
      id: spectrumsPerTab
    });
  }, [dispatch, spectrums]);
  const hideAllSpectrumsHandler = react.exports.useCallback(() => {
    dispatch({
      type: CHANGE_VISIBILITY,
      id: []
    });
  }, [dispatch]);
  const addMissingProjectionHandler2 = react.exports.useCallback(() => {
    function getMissingProjection2(SpectrumsData) {
      let nucleus = activeTab.split(",");
      nucleus = nucleus[0] === nucleus[1] ? [nucleus[0]] : nucleus;
      const missingNucleus2 = [];
      for (const n of nucleus) {
        const hasSpectrums = SpectrumsData.some((d) => d.info.nucleus === n);
        if (!hasSpectrums) {
          missingNucleus2.push(n);
        }
      }
      return missingNucleus2;
    }
    const missingNucleus = getMissingProjection2(data);
    if (missingNucleus.length > 0) {
      dispatch({
        type: ADD_MISSING_PROJECTION,
        nucleus: missingNucleus
      });
    } else {
      alert2.error("Nothing to calculate");
    }
  }, [activeTab, alert2, data, dispatch]);
  const setSameTopHandler = react.exports.useCallback(() => {
    dispatch({
      type: SET_SPECTRA_SAME_TOP
    });
  }, [dispatch]);
  const resetScaleHandler = react.exports.useCallback(() => {
    dispatch({
      type: RESET_SPECTRA_SCALE
    });
  }, [dispatch]);
  return /* @__PURE__ */ jsxs$1(DefaultPanelHeader$1, {
    onDelete: handleDelete,
    counter: spectrums == null ? void 0 : spectrums.length,
    deleteToolTip: "Delete all spectra",
    children: [/* @__PURE__ */ jsx$1(ButtonToolTip, {
      popupTitle: "Hide all spectra",
      onClick: hideAllSpectrumsHandler,
      children: /* @__PURE__ */ jsx$1(FaEyeSlash, {})
    }), /* @__PURE__ */ jsx$1(ButtonToolTip, {
      popupTitle: "Show all spectra",
      onClick: showAllSpectrumsHandler,
      children: /* @__PURE__ */ jsx$1(FaEye, {})
    }), activeSpectrum && activeTab && activeTab.split(",").length > 1 && /* @__PURE__ */ jsx$1(ButtonToolTip, {
      popupTitle: "Add missing projection",
      onClick: addMissingProjectionHandler2,
      children: /* @__PURE__ */ jsx$1(FaCreativeCommonsSamplingPlus, {})
    }), displayerMode === DISPLAYER_MODE.DM_1D && spectrums.length > 1 && /* @__PURE__ */ jsxs$1(Fragment$1, {
      children: [/* @__PURE__ */ jsx$1(ButtonToolTip, {
        popupTitle: "Reset Scale",
        onClick: resetScaleHandler,
        children: /* @__PURE__ */ jsx$1(SvgResetScale, {})
      }), /* @__PURE__ */ jsx$1(ButtonToolTip, {
        popupTitle: "Same Top",
        onClick: setSameTopHandler,
        children: /* @__PURE__ */ jsx$1(SvgSameTop, {})
      })]
    }), /* @__PURE__ */ jsx$1(SpectraAutomaticPickingButton, {})]
  });
}
const MemoizedSpectraPanelHeader = react.exports.memo(SpectraPanelHeaderInner);
function SpectrumsTabs$1({
  spectrums
}) {
  const {
    data,
    activeSpectrum,
    activeTab,
    displayerMode
  } = useChartData();
  return /* @__PURE__ */ jsx$1(MemoizedSpectraPanelHeader, {
    data,
    activeSpectrum,
    activeTab,
    displayerMode,
    spectrums
  });
}
function ColorIndicator1D({
  color,
  activated
}) {
  return /* @__PURE__ */ jsx$1("div", {
    style: {
      backgroundColor: color,
      height: "12px",
      width: "12px",
      opacity: activated ? 1 : 0.1,
      display: "inline-block"
    }
  });
}
function ColorIndicator2D({
  positiveColor,
  negativeColor,
  activated
}) {
  return /* @__PURE__ */ jsx$1("svg", {
    width: "12",
    height: "12",
    viewBox: "0 0 12 12",
    opacity: activated ? 1 : 0.1,
    children: /* @__PURE__ */ jsxs$1("g", {
      children: [/* @__PURE__ */ jsx$1("path", {
        d: "M0,0H12L0,12Z",
        fill: positiveColor,
        strokeWidth: "0"
      }), /* @__PURE__ */ jsx$1("path", {
        d: "M12,12H0L12,0Z",
        fill: negativeColor,
        strokeWidth: "0"
      })]
    })
  });
}
function ColorIndicator(props) {
  const {
    style: style2,
    onClick = () => null,
    activated
  } = props;
  return /* @__PURE__ */ jsx$1("button", {
    style: style2,
    type: "button",
    onClick,
    children: props.dimension === 2 ? /* @__PURE__ */ jsx$1(ColorIndicator2D, __spreadProps(__spreadValues({}, props.color), {
      activated
    })) : /* @__PURE__ */ jsx$1(ColorIndicator1D, __spreadValues({
      activated
    }, props.color))
  });
}
var ColorIndicator$1 = react.exports.memo(ColorIndicator);
function ShowHideMarkersButton({
  data,
  onChangeMarkersVisibility,
  markersVisible,
  style: style2
}) {
  const isMarkerVisible = (id2) => {
    return markersVisible.findIndex((v) => v.id === id2) !== -1 ? true : false;
  };
  return /* @__PURE__ */ jsx$1("button", {
    style: __spreadProps(__spreadValues({}, style2), {
      opacity: isMarkerVisible(data.id) && data.peaks && data.peaks.values.length > 0 ? 1 : 0.1
    }),
    type: "button",
    onClick: () => onChangeMarkersVisibility(data),
    disabled: data.peaks && data.peaks.values.length === 0,
    children: /* @__PURE__ */ jsx$1(SvgPeaks, {})
  });
}
function ShowHideSpectrumButton({
  data,
  onChangeVisibility,
  style: style2
}) {
  const isVisible = (id2, key) => {
    return data ? data.display[key] : true;
  };
  return /* @__PURE__ */ jsxs$1(Fragment$1, {
    children: [data.info.dimension === 1 && /* @__PURE__ */ jsx$1("button", {
      "data-test-id": "hide-show-spectrum-button",
      style: style2,
      type: "button",
      onClick: () => onChangeVisibility(data, "isVisible"),
      children: /* @__PURE__ */ jsx$1(FaEye, {
        style: __spreadValues({}, isVisible(data.id, "isVisible") ? {
          opacity: 1,
          strokeWidth: "1px",
          fill: data.display.color
        } : {
          opacity: 0.1,
          fill: data.display.color
        })
      })
    }), data.info.dimension === 2 && /* @__PURE__ */ jsxs$1("div", {
      style: {
        minWidth: "40px"
      },
      children: [/* @__PURE__ */ jsx$1("button", {
        style: __spreadProps(__spreadValues({}, style2), {
          width: "20px",
          minWidth: "20px"
        }),
        type: "button",
        onClick: () => onChangeVisibility(data, "isPositiveVisible"),
        children: /* @__PURE__ */ jsx$1(FaEye, {
          style: __spreadValues({}, isVisible(data.id, "isPositiveVisible") ? {
            opacity: 1,
            strokeWidth: "1px",
            fill: data.display.positiveColor
          } : {
            opacity: 0.1,
            fill: data.display.positiveColor
          })
        })
      }), /* @__PURE__ */ jsx$1("button", {
        style: __spreadProps(__spreadValues({}, style2), {
          width: "20px",
          minWidth: "20px"
        }),
        type: "button",
        onClick: () => onChangeVisibility(data, "isNegativeVisible"),
        children: /* @__PURE__ */ jsx$1(FaEye, {
          style: __spreadValues({}, isVisible(data.id, "isNegativeVisible") ? {
            opacity: 1,
            strokeWidth: "1px",
            fill: data.display.negativeColor
          } : {
            opacity: 0.1,
            fill: data.display.negativeColor
          })
        })
      })]
    })]
  });
}
const styles$q = {
  button: {
    backgroundColor: "transparent",
    border: "none",
    width: "26px",
    minWidth: "26px"
  },
  row: {
    display: "flex",
    alignContent: "center",
    height: "25px",
    borderBottom: "0.55px solid #f1f1f1"
  },
  name: {
    flex: 1,
    height: "100%",
    display: "flex"
  },
  info: {
    flex: "1 1 1px",
    height: "100%",
    display: "block",
    alignItems: "center",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    lineHeight: "24px"
  },
  icon: {
    display: "flex",
    margin: "auto",
    justifyContent: "center"
  }
};
function SpectrumListItem({
  activeSpectrum,
  markersVisible,
  data,
  onChangeVisibility,
  onChangeMarkersVisibility,
  onChangeActiveSpectrum,
  onOpenSettingModal,
  onContextMenu
}) {
  var _a, _b;
  const formatValueAsHTML = (value) => {
    if (value) {
      value = value.replace(/(?<value>[0-9]+)/g, "<sub>$<value></sub>");
    }
    return value;
  };
  const activated = activeSpectrum && activeSpectrum.id === data.id;
  const {
    color,
    name: name2,
    positiveColor,
    negativeColor
  } = data.display;
  return /* @__PURE__ */ jsxs$1("div", {
    style: __spreadValues(__spreadValues({}, styles$q.row), activated ? {
      backgroundColor: "#fafafa"
    } : {
      opacity: activeSpectrum ? 0.2 : 1
    }),
    onContextMenu,
    children: [/* @__PURE__ */ jsx$1(ShowHideSpectrumButton, {
      data,
      onChangeVisibility,
      style: styles$q.button
    }), /* @__PURE__ */ jsxs$1("div", {
      "data-test-id": "activate-deactivate-spectrum-button",
      style: styles$q.name,
      onClick: () => onChangeActiveSpectrum(data),
      children: [/* @__PURE__ */ jsx$1("div", {
        style: __spreadProps(__spreadValues({}, styles$q.icon), {
          width: "16px"
        }),
        children: data.info.isFid ? /* @__PURE__ */ jsx$1(SvgFid, {}) : data.info.dimension === 2 ? /* @__PURE__ */ jsx$1(Svg2D, {}) : /* @__PURE__ */ jsx$1(SvgFt, {})
      }), /* @__PURE__ */ jsx$1("span", {
        style: styles$q.info,
        children: name2
      }), /* @__PURE__ */ jsx$1("div", {
        style: styles$q.info,
        dangerouslySetInnerHTML: {
          __html: data.info && formatValueAsHTML(data.info.solvent)
        }
      }), /* @__PURE__ */ jsxs$1("span", {
        style: styles$q.info,
        children: [/* @__PURE__ */ jsx$1("span", {
          style: {
            borderLeft: "0.55px solid #e5e5e5",
            paddingRight: "5px"
          }
        }), (_a = data.info) == null ? void 0 : _a.experiment]
      }), /* @__PURE__ */ jsx$1("span", {
        style: styles$q.info,
        children: (_b = data.info) == null ? void 0 : _b.pulse
      })]
    }), /* @__PURE__ */ jsx$1(ShowHideMarkersButton, {
      data,
      style: __spreadValues(__spreadValues({}, styles$q.icon), styles$q.button),
      onChangeMarkersVisibility,
      markersVisible
    }), /* @__PURE__ */ jsx$1(ColorIndicator$1, {
      style: styles$q.button,
      dimension: data.info.dimension,
      color: {
        positiveColor,
        color,
        negativeColor
      },
      activated,
      onClick: (event) => onOpenSettingModal(data, event)
    })]
  });
}
var SpectrumListItem$1 = react.exports.memo(SpectrumListItem);
function FormikColorPicker(props) {
  const {
    onColorChange = () => null,
    name: name2
  } = props;
  const {
    values,
    setFieldValue
  } = useFormikContext();
  const colorchangeHandler = react.exports.useCallback((color) => {
    onColorChange(color);
    setFieldValue(name2, `${color.hex}${Math.round(color.rgb.a * 255).toString(16)}`);
  }, [name2, onColorChange, setFieldValue]);
  return /* @__PURE__ */ jsx$1(lib.SketchPicker, {
    color: {
      hex: get_1(values, name2, "#000")
    },
    presetColors: COLORS,
    onChangeComplete: (e2) => colorchangeHandler(e2)
  });
}
var FormikColorPicker$1 = react.exports.memo(FormikColorPicker);
function PlotChart({
  data,
  sign,
  color,
  yLogBase: yLogBase2,
  hideHeading = false
}) {
  var _a, _b;
  return /* @__PURE__ */ jsxs$1(Plot, {
    width: 180,
    height: 220,
    children: [!hideHeading && /* @__PURE__ */ jsx$1(Heading, {
      title: "Sanplot"
    }), /* @__PURE__ */ jsx$1(LineSeries, {
      data: ((_a = data.sanPlot) == null ? void 0 : _a[sign]) || [],
      xAxis: "x",
      yAxis: "y",
      label: sign,
      lineStyle: {
        stroke: color,
        strokeWidth: 1.2
      },
      markerStyle: {
        fill: color,
        stroke: color
      }
    }), /* @__PURE__ */ jsx$1(LineSeries, {
      data: ((_b = data.lines) == null ? void 0 : _b[sign]) || [],
      xAxis: "x",
      yAxis: "y",
      label: "noise level",
      lineStyle: {
        stroke: "blue",
        strokeWidth: 0.8,
        strokeDasharray: "3, 3"
      },
      markerStyle: {
        fill: color,
        stroke: color
      }
    }), /* @__PURE__ */ jsx$1(Axis, {
      id: "x",
      label: "Pt",
      position: "bottom",
      tickLabelStyle: {
        fontSize: "0.6rem"
      },
      labelStyle: {
        fontSize: "0.6rem"
      }
    }), /* @__PURE__ */ jsx$1(Axis, {
      id: "y",
      label: `Intensity [Log${yLogBase2}]`,
      position: "left",
      tickLabelStyle: {
        fontSize: "0.6rem"
      },
      labelStyle: {
        fontSize: "0.7rem"
      }
    }), /* @__PURE__ */ jsx$1(Legend, {
      position: "embedded",
      bottom: 5,
      right: 60
    })]
  });
}
function processSnapPlot(dimension, data, yLogBase2) {
  const input = dimension === "1D" ? prepare1DData(data) : prepare2DData(data);
  const sanResult = xNoiseSanPlot(input);
  const sanPlot = {};
  const lines = {};
  for (let plotKey in sanResult.sanplot) {
    const { x, y } = xyReduce(sanResult.sanplot[plotKey]);
    let result = new Array(x.length);
    for (let i = 0; i < x.length; i++) {
      result[i] = { x: x[i], y: y[i] };
    }
    sanPlot[plotKey] = result;
    lines[plotKey] = getLine(sanResult[plotKey], result, { yLogBase: yLogBase2 });
  }
  return { sanPlot, lines };
}
function prepare1DData(data) {
  const length = data.re.length;
  const jump = Math.floor(length / 307200) || 1;
  const array2 = new Float64Array(length / jump >> 0);
  let index2 = 0;
  for (let i = 0; i < array2.length; i += jump) {
    array2[index2++] = data.re[i];
  }
  return array2;
}
function prepare2DData(data) {
  let cols = data.z[0].length;
  let rows = data.z.length;
  let jump = Math.floor(cols * rows / 204800) || 1;
  const array2 = new Float64Array(cols * rows / jump >> 0);
  let index2 = 0;
  for (let i = 0; i < array2.length; i += jump) {
    array2[index2++] = data.z[i / rows >> 0][i % rows];
  }
  return array2;
}
function getLine(value, data, options2) {
  const { log10, abs } = Math;
  const { yLogBase: yLogBase2 } = options2;
  const first = data.length > 0 ? data[0].x : 0;
  const last = data.length > 0 ? data[data.length - 1].x : 0;
  const inLogScale = log10(abs(value)) / log10(yLogBase2);
  return [
    { x: first, y: inLogScale },
    { x: last, y: inLogScale }
  ];
}
const yLogBase$1 = 2;
function Spectrum1DHistogram({
  color = "red",
  data
}) {
  const processedData = react.exports.useMemo(() => {
    return processSnapPlot("1D", data, yLogBase$1);
  }, [data]);
  return /* @__PURE__ */ jsxs$1("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center"
    },
    children: [/* @__PURE__ */ jsx$1("div", {
      style: {
        display: "block"
      },
      children: /* @__PURE__ */ jsx$1(PlotChart, {
        data: processedData,
        sign: "positive",
        color,
        yLogBase: yLogBase$1
      })
    }), /* @__PURE__ */ jsx$1("div", {
      style: {
        display: "block",
        width: 180,
        height: 180
      },
      children: /* @__PURE__ */ jsx$1(PlotChart, {
        data: processedData,
        sign: "negative",
        color,
        yLogBase: yLogBase$1,
        hideHeading: true
      })
    })]
  });
}
var Spectrum1DHistogram$1 = react.exports.memo(Spectrum1DHistogram);
function Spectrum1DSetting({
  data: SpectrumData,
  onSubmit
}) {
  const refForm = react.exports.useRef(null);
  const triggerSubmitHandler = react.exports.useCallback(() => {
    if (refForm.current) {
      refForm.current.submitForm();
    }
  }, []);
  return /* @__PURE__ */ jsx$1(FormikForm, {
    ref: refForm,
    initialValues: SpectrumData.display,
    onSubmit,
    children: /* @__PURE__ */ jsxs$1("div", {
      style: {
        display: "flex",
        flexDirection: "column",
        gap: "1.25rem"
      },
      children: [/* @__PURE__ */ jsx$1("div", {
        style: {
          display: "block",
          position: "relative"
        },
        children: /* @__PURE__ */ jsx$1(FormikColorPicker$1, {
          name: "color",
          onColorChange: triggerSubmitHandler
        })
      }), /* @__PURE__ */ jsx$1(Spectrum1DHistogram$1, {
        color: "red",
        data: SpectrumData.data
      })]
    })
  });
}
function FormikSlider(props) {
  const _a = props, {
    onAfterChange = () => null,
    name: name2
  } = _a, sliderProps = __objRest(_a, [
    "onAfterChange",
    "name"
  ]);
  const {
    values,
    setFieldValue
  } = useFormikContext();
  const changeHandler = react.exports.useCallback((value) => {
    onAfterChange(value);
    setFieldValue(name2, value);
  }, [name2, onAfterChange, setFieldValue]);
  return /* @__PURE__ */ jsx$1(u, __spreadValues({
    className: "horizontal-slider",
    thumbClassName: "thumb",
    trackClassName: "track",
    defaultValue: get_1(values, name2, [0, 100]),
    onAfterChange: changeHandler,
    renderThumb: (props2, state) => /* @__PURE__ */ jsx$1("div", __spreadProps(__spreadValues({}, props2), {
      children: /* @__PURE__ */ jsx$1("span", {
        children: state.valueNow
      })
    })),
    pearling: true,
    minDistance: 10
  }, sliderProps));
}
var FormikSlider$1 = react.exports.memo(FormikSlider);
const yLogBase = 2;
function Spectrum2DHistogram({
  color = "red",
  data
}) {
  const processedData = react.exports.useMemo(() => {
    return processSnapPlot("2D", data, yLogBase);
  }, [data]);
  return /* @__PURE__ */ jsxs$1("div", {
    children: [/* @__PURE__ */ jsx$1("div", {
      style: {
        textAlign: "center",
        paddingBottom: 5,
        paddingTop: 5
      },
      children: "San Plot"
    }), /* @__PURE__ */ jsxs$1("div", {
      style: {
        borderTop: "1px solid #ededed",
        marginTop: "10px",
        paddingTop: "10px",
        display: "flex",
        flexDirection: "row"
      },
      children: [/* @__PURE__ */ jsx$1(PlotChart, {
        data: processedData,
        sign: "positive",
        color,
        yLogBase
      }), /* @__PURE__ */ jsx$1(PlotChart, {
        data: processedData,
        sign: "negative",
        color,
        yLogBase,
        hideHeading: true
      })]
    })]
  });
}
var Spectrum2DHistogram$1 = react.exports.memo(Spectrum2DHistogram);
function Spectrum2DSetting({
  data: SpectrumData,
  onSubmit
}) {
  const refForm = react.exports.useRef(null);
  const style2 = css`
    .positive {
      display: inline-block;
      .track-1 {
        background-color: ${SpectrumData.display.positiveColor} !important;
      }
    }
    .negative {
      display: inline-block;

      .track-1 {
        background-color: ${SpectrumData.display.negativeColor} !important;
      }
    }
  `;
  const triggerSubmitHandler = react.exports.useCallback(() => {
    refForm.current.submitForm();
  }, []);
  return /* @__PURE__ */ jsx(FormikForm, {
    ref: refForm,
    initialValues: SpectrumData.display,
    onSubmit,
    children: /* @__PURE__ */ jsxs("div", {
      css: style2,
      children: [/* @__PURE__ */ jsxs("div", {
        className: "positive",
        children: [/* @__PURE__ */ jsx("span", {
          style: {
            padding: "0 10px"
          },
          children: "Positive"
        }), /* @__PURE__ */ jsx(FormikColorPicker$1, {
          name: "positiveColor",
          onColorChange: triggerSubmitHandler
        }), /* @__PURE__ */ jsxs("div", {
          style: {
            padding: "5px"
          },
          children: [/* @__PURE__ */ jsx("span", {
            className: "label",
            children: "contour Levels [ min - max ]"
          }), /* @__PURE__ */ jsx(FormikSlider$1, {
            name: "contourOptions.positive.contourLevels",
            onAfterChange: triggerSubmitHandler
          }), /* @__PURE__ */ jsx("span", {
            className: "label",
            children: "number of Layers "
          }), /* @__PURE__ */ jsx(FormikInput, {
            name: "contourOptions.positive.numberOfLayers",
            onChange: triggerSubmitHandler,
            type: "number"
          })]
        })]
      }), /* @__PURE__ */ jsxs("div", {
        className: "negative",
        children: [/* @__PURE__ */ jsx("span", {
          style: {
            padding: "0 10px"
          },
          children: "Negative"
        }), /* @__PURE__ */ jsx(FormikColorPicker$1, {
          name: "negativeColor",
          onColorChange: triggerSubmitHandler
        }), /* @__PURE__ */ jsxs("div", {
          style: {
            padding: "5px"
          },
          children: [/* @__PURE__ */ jsx("span", {
            className: "label",
            children: "contour Levels [ min - max ]"
          }), /* @__PURE__ */ jsx(FormikSlider$1, {
            name: "contourOptions.negative.contourLevels",
            onAfterChange: triggerSubmitHandler
          }), /* @__PURE__ */ jsx("span", {
            className: "label",
            children: "number of Layers "
          }), /* @__PURE__ */ jsx(FormikInput, {
            name: "contourOptions.negative.numberOfLayers",
            onChange: triggerSubmitHandler,
            type: "number"
          })]
        })]
      }), /* @__PURE__ */ jsx(Spectrum2DHistogram$1, {
        data: SpectrumData.data
      })]
    })
  });
}
const style$4 = css`
  position: fixed;
  z-index: 999999999;
  width:100%;
  height:100%;
  left:0;
  top:0;
  .inner-conatiner{
    position:absolute;
    display: flex;
    flex-direction: row-reverse;
    border-radius: 4px;
    background-color: white;
    box-shadow: rgba(0, 0, 0, 0.15) 0px 0px 0px 1px,
      rgba(0, 0, 0, 0.15) 0px 8px 16px;
      overflow: auto;
      height: 350px;
  }


  .sketch-picker {
    border-radius: none !important;
    box-shadow: none !important;
  }


  .horizontal-slider {
    width: 80%;
    height: 15px;
  }

  .thumb {
    height: 15px;
    line-height: 15px;
    width: 20px;
    text-align: center;
    color: black;
    border-radius: 5px;
    cursor: grab;
    font-size: 10px;
    background-image: -webkit-linear-gradient(top, #f4f1ee, #fff);
    background-image: linear-gradient(top, #f4f1ee, #fff);
  }

  .track {
    top: 0;
    bottom: 0;
    background: #eaeaea;
    border-radius: 999px;
    border-radius: 5px;
  }

  .track-1 {
    background: red;
  }
   
  .label{
    font-size: 12px;
    margin: 8px 0;
    display: block;
  }
 
  }
`;
function SpectrumSetting({
  position,
  data,
  onClose
}) {
  const dispatch = useDispatch();
  const {
    id: id2,
    info
  } = data;
  const submitHandler = react.exports.useCallback((values) => {
    dispatch({
      type: CHANGE_SPECTRUM_SETTING,
      id: id2,
      display: values
    });
  }, [dispatch, id2]);
  const clickHandler = react.exports.useCallback((e2) => {
    if (e2.target === e2.currentTarget) {
      onClose();
    }
  }, [onClose]);
  if (!position)
    return null;
  const {
    x,
    y
  } = position;
  return /* @__PURE__ */ jsx("div", {
    css: style$4,
    onClick: clickHandler,
    children: /* @__PURE__ */ jsx("div", {
      className: "inner-conatiner",
      style: {
        left: info.dimension === 2 ? x - 460 : x - 240,
        width: info.dimension === 2 ? 460 : 240,
        padding: info.dimension === 2 ? "10px 0" : "",
        top: y
      },
      children: info.dimension === 2 ? /* @__PURE__ */ jsx(Spectrum2DSetting, {
        onSubmit: submitHandler,
        data
      }) : /* @__PURE__ */ jsx(Spectrum1DSetting, {
        onSubmit: submitHandler,
        data
      })
    })
  });
}
function arePropsEqual() {
  return true;
}
var SpectrumSetting$1 = react.exports.memo(SpectrumSetting, arePropsEqual);
function SpectrumsTabsInner({
  data,
  activeSpectrum,
  activeTab,
  onTabChange
}) {
  const contextRef = react.exports.useRef();
  const [markersVisible, setMarkersVisible] = react.exports.useState([]);
  const [selectedSpectrumData, setSelectedSpectrum] = react.exports.useState(null);
  const [settingModalPosition, setSettingModalPosition] = react.exports.useState(null);
  const [isSettingModalDisplayed, setIsSettingModalDisplayed] = react.exports.useState(false);
  const alert2 = useAlert();
  const dispatch = useDispatch();
  react.exports.useEffect(() => {
    if (data) {
      const visibleMarkers = data.reduce((acc, datum) => {
        if (datum.info.dimension === 1 && datum.display.isPeaksMarkersVisible === true) {
          acc.push({
            id: datum.id
          });
        }
        return acc;
      }, []);
      setMarkersVisible(visibleMarkers);
    }
  }, [data, dispatch]);
  const spectrumsGroupByNucleus = react.exports.useMemo(() => {
    if (!data)
      return [];
    const groupByNucleus = GroupByInfoKey("nucleus");
    return groupByNucleus(data, true);
  }, [data]);
  react.exports.useEffect(() => {
    onTabChange({
      tab: activeTab,
      data: spectrumsGroupByNucleus[activeTab]
    });
  }, [activeTab, onTabChange, spectrumsGroupByNucleus]);
  const handleChangeMarkersVisibility = react.exports.useCallback((d) => {
    const currentIndex = markersVisible.findIndex((v) => v.id === d.id);
    const newChecked = [...markersVisible];
    if (currentIndex === -1) {
      newChecked.push({
        id: d.id
      });
    } else {
      newChecked.splice(currentIndex, 1);
    }
    dispatch({
      type: CHANGE_PEAKS_MARKERS_VISIBILITY,
      data: newChecked
    });
    setMarkersVisible(newChecked);
  }, [dispatch, markersVisible]);
  const onTabChangeHandler = react.exports.useCallback((tab) => {
    onTabChange({
      tab: tab.tabid,
      data: spectrumsGroupByNucleus[tab.tabid]
    });
    dispatch({
      type: SET_ACTIVE_TAB,
      tab: tab.tabid
    });
  }, [dispatch, onTabChange, spectrumsGroupByNucleus]);
  const contextMenu = react.exports.useMemo(() => [{
    label: "Copy to Clipboard",
    onClick: (spectrumData) => {
      void (async () => {
        const {
          x,
          y,
          info
        } = spectrumData;
        const success = await copyTextToClipboard(JSON.stringify({
          x,
          y,
          info
        }, void 0, 2));
        if (success) {
          alert2.success("Data copied to clipboard");
        } else {
          alert2.error("Copy to clipboard failed");
        }
      })();
    }
  }, {
    label: "Delete",
    onClick: (spectrumData) => {
      setTimeout(() => {
        dispatch({
          type: DELETE_SPECTRA,
          id: spectrumData.id
        });
      }, 0);
    }
  }], [alert2, dispatch]);
  const contextMenuHandler = react.exports.useCallback((e2, rowData) => {
    if (!checkModifierKeyActivated(e2)) {
      e2.preventDefault();
      contextRef.current.handleContextMenu(e2, rowData);
    }
  }, [contextRef]);
  const openSettingHandler = react.exports.useCallback((selectedSpectrum, event) => {
    setSettingModalPosition({
      x: event.nativeEvent.clientX,
      y: event.nativeEvent.clientY
    });
    setSelectedSpectrum(selectedSpectrum);
    setIsSettingModalDisplayed(true);
  }, []);
  const handleChangeVisibility = react.exports.useCallback((d, key) => {
    dispatch({
      type: CHANGE_VISIBILITY,
      id: d.id,
      key,
      value: !d.display[key]
    });
  }, [dispatch]);
  const handleChangeActiveSpectrum2 = react.exports.useCallback((d) => {
    setTimeout(() => {
      if (activeSpectrum && activeSpectrum.id === d.id) {
        dispatch({
          type: CHANGE_ACTIVE_SPECTRUM,
          data: null
        });
      } else {
        dispatch({
          type: CHANGE_ACTIVE_SPECTRUM,
          data: {
            id: d.id
          }
        });
      }
    }, 0);
  }, [activeSpectrum, dispatch]);
  const mouseLeaveHandler = react.exports.useCallback(() => {
    setIsSettingModalDisplayed(false);
  }, []);
  return /* @__PURE__ */ jsxs$1("div", {
    style: {
      height: "calc(100% - 25px)"
    },
    children: [/* @__PURE__ */ jsx$1(Tabs$1, {
      activeTab,
      onClick: onTabChangeHandler,
      children: spectrumsGroupByNucleus && Object.keys(spectrumsGroupByNucleus).map((group) => {
        var _a;
        return /* @__PURE__ */ jsx$1(Tab, {
          tablabel: group,
          tabid: group,
          children: (_a = spectrumsGroupByNucleus[group]) == null ? void 0 : _a.map((d) => /* @__PURE__ */ jsx$1(SpectrumListItem$1, {
            activeSpectrum,
            markersVisible,
            data: d,
            onChangeVisibility: handleChangeVisibility,
            onChangeMarkersVisibility: handleChangeMarkersVisibility,
            onChangeActiveSpectrum: handleChangeActiveSpectrum2,
            onOpenSettingModal: openSettingHandler,
            onContextMenu: (e2) => contextMenuHandler(e2, d)
          }, d.id))
        }, group);
      })
    }), /* @__PURE__ */ jsx$1(ContextMenu$1, {
      ref: contextRef,
      context: contextMenu
    }), isSettingModalDisplayed ? /* @__PURE__ */ jsx$1(SpectrumSetting$1, {
      onClose: mouseLeaveHandler,
      data: selectedSpectrumData,
      position: settingModalPosition
    }) : null]
  });
}
const MemoizedSpectra = react.exports.memo(SpectrumsTabsInner);
function SpectrumsTabs({
  onTabChange
}) {
  const {
    data,
    activeSpectrum,
    activeTab
  } = useChartData();
  return /* @__PURE__ */ jsx$1(MemoizedSpectra, {
    data,
    activeSpectrum,
    activeTab,
    onTabChange
  });
}
const styles$p = {
  overflow: "hidden",
  height: "100%",
  display: "flex",
  flexDirection: "column",
  width: "100%"
};
function SpectrumListPanel() {
  const [spectrums, setSpectrums] = react.exports.useState([]);
  const tabChangeHandler = react.exports.useCallback((e2) => {
    setSpectrums(e2.data ? e2.data : []);
  }, []);
  return /* @__PURE__ */ jsxs$1("div", {
    style: styles$p,
    children: [/* @__PURE__ */ jsx$1(SpectrumsTabs$1, {
      spectrums
    }), /* @__PURE__ */ jsx$1(SpectrumsTabs, {
      onTabChange: tabChangeHandler
    })]
  });
}
var SpectrumListPanel$1 = react.exports.memo(SpectrumListPanel);
const DefaultPathLengths = {
  hmbc: { from: 2, to: 3 },
  cosy: { from: 3, to: 4 },
  hsqc: { from: 1, to: 1 },
  hmqc: { from: 1, to: 1 },
  inadequate: { from: 1, to: 1 }
};
function isDefaultPathLength(pathLength, experimentType) {
  return DefaultPathLengths[experimentType] && pathLength.from === DefaultPathLengths[experimentType].from && pathLength.to === DefaultPathLengths[experimentType].to;
}
function getAtomType(nucleus) {
  return nucleus.split(/\d+/)[1];
}
function getLabelColor(correlationData, correlation) {
  const error = get_1(correlationData, `state.${correlation.atomType}.error`, null);
  if (error) {
    for (let { key, color } of ErrorColors) {
      if (key !== "incomplete" && (key === "notAttached" || key === "ambiguousAttachment") && get_1(error, `${key}`, []).some((index2) => correlationData.values[index2].id === correlation.id)) {
        return color;
      }
    }
  }
  return null;
}
function findSignalMatch1D(spectrum, link, factor, xDomain0, xDomain1) {
  var _a;
  if (spectrum && spectrum.info.dimension === 2) {
    const signal = findSignal2D(spectrum, link.signal.id);
    if (signal) {
      const otherAxis = link.axis === "x" ? "y" : "x";
      const delta = (_a = signal[otherAxis]) == null ? void 0 : _a.delta;
      if (delta !== void 0) {
        return delta * factor >= xDomain0 && delta * factor <= xDomain1;
      }
    }
  }
  return false;
}
function findSignalMatch2D(spectrum, link, factor, xDomain0, xDomain1, yDomain0, yDomain1) {
  if (spectrum && spectrum.info.dimension === 2) {
    const signal = findSignal2D(spectrum, link.signal.id);
    if ((signal == null ? void 0 : signal.x.delta) && (signal == null ? void 0 : signal.y.delta)) {
      return signal.x.delta * factor >= xDomain0 && signal.x.delta * factor <= xDomain1 && signal.y.delta * factor >= yDomain0 && signal.y.delta * factor <= yDomain1;
    }
  }
  return false;
}
function getAbbreviation(link) {
  var _a;
  let abbreviation = "X";
  if (link.experimentType === "hsqc" || link.experimentType === "hmqc") {
    abbreviation = !link.signal || link.signal.sign === 0 ? "S" : `S${link.signal.sign === 1 ? "+" : "-"}`;
  } else if (link.experimentType === "hmbc" || link.experimentType === "cosy" || link.experimentType === "tocsy") {
    abbreviation = "M";
  } else if (link.experimentType === "noesy" || link.experimentType === "roesy") {
    abbreviation = "NOE";
  } else if (link.experimentType === "inadequate") {
    abbreviation = "I";
  } else if (link.experimentType === "adequate") {
    abbreviation = "A";
  }
  const pathLength = (_a = link.signal.j) == null ? void 0 : _a.pathLength;
  if (pathLength) {
    const isDefaultCorrelation = DefaultPathLengths[link.experimentType] && pathLength.from >= DefaultPathLengths[link.experimentType].from && pathLength.from <= DefaultPathLengths[link.experimentType].to && pathLength.to >= DefaultPathLengths[link.experimentType].from && pathLength.to <= DefaultPathLengths[link.experimentType].to;
    return `${abbreviation}${isDefaultCorrelation ? "" : "*"}`;
  }
  return abbreviation;
}
function buildNewLink1D(link) {
  return buildLink(__spreadProps(__spreadValues({}, link), {
    edited: __spreadProps(__spreadValues({}, link.edited), {
      moved: true
    })
  }));
}
function buildNewLink2D(link, axis) {
  const linkIDs = link.id.split("_");
  return buildLink(__spreadProps(__spreadValues({}, link), {
    id: linkIDs[axis === "x" ? 0 : 1],
    axis,
    match: [],
    edited: __spreadProps(__spreadValues({}, link.edited), {
      moved: true
    })
  }));
}
function cloneCorrelationAndEditLink(correlation, link, axis, action) {
  const linkDim = getLinkDim(link);
  const _correlation = cloneDeep_1(correlation);
  const split = link.id.split("_");
  if (action === "add") {
    addLink(_correlation, linkDim === 1 ? buildNewLink1D(link) : buildNewLink2D(link, axis));
  } else if (action === "remove" || action === "unmove") {
    removeLink(_correlation, axis === "x" ? split[0] : split[1]);
  }
  return _correlation;
}
function getEditedCorrelations({
  correlationDim1,
  correlationDim2,
  selectedCorrelationIdDim1,
  selectedCorrelationIdDim2,
  action,
  link,
  correlations
}) {
  const selectedCorrelationDim1 = correlations.find((correlation) => correlation.id === selectedCorrelationIdDim1);
  const selectedCorrelationDim2 = correlations.find((correlation) => correlation.id === selectedCorrelationIdDim2);
  const hasChangedDim1 = (selectedCorrelationDim1 == null ? void 0 : selectedCorrelationDim1.id) !== correlationDim1.id;
  const hasChangedDim2 = correlationDim2 && (selectedCorrelationDim2 == null ? void 0 : selectedCorrelationDim2.id) !== (correlationDim2 == null ? void 0 : correlationDim2.id);
  const linkDim = getLinkDim(link);
  const editedCorrelations = [];
  const buildCorrelationDataOptions = {};
  if (action === "move") {
    if (linkDim === 1) {
      const _correlationDim1 = cloneCorrelationAndEditLink(correlationDim1, link, "x", "remove");
      let newCorrelationDim1;
      if (selectedCorrelationDim1) {
        newCorrelationDim1 = cloneCorrelationAndEditLink(hasChangedDim1 ? selectedCorrelationDim1 : _correlationDim1, link, "x", "add");
      } else {
        newCorrelationDim1 = buildCorrelation({
          atomType: correlationDim1.atomType,
          link: [buildNewLink1D(link)]
        });
      }
      editedCorrelations.push(_correlationDim1, newCorrelationDim1);
      buildCorrelationDataOptions.skipDataUpdate = true;
    } else if (linkDim === 2) {
      const _correlationDim1 = cloneCorrelationAndEditLink(correlationDim1, link, "x", "remove");
      editedCorrelations.push(_correlationDim1);
      const _correlationDim2 = cloneCorrelationAndEditLink(correlationDim2, link, "y", "remove");
      editedCorrelations.push(_correlationDim2);
      if (selectedCorrelationDim1 && selectedCorrelationDim2) {
        editedCorrelations.push(cloneCorrelationAndEditLink(hasChangedDim1 ? selectedCorrelationDim1 : _correlationDim1, link, "x", "add"));
        editedCorrelations.push(cloneCorrelationAndEditLink(hasChangedDim2 ? selectedCorrelationDim2 : _correlationDim2, link, "y", "add"));
      } else if (selectedCorrelationDim1 && selectedCorrelationIdDim2 === "new") {
        editedCorrelations.push(cloneCorrelationAndEditLink(hasChangedDim1 ? selectedCorrelationDim1 : _correlationDim1, link, "x", "add"));
        editedCorrelations.push(buildCorrelation({
          atomType: correlationDim2.atomType,
          link: [buildNewLink2D(link, "y")]
        }));
      } else if (selectedCorrelationIdDim1 === "new" && selectedCorrelationDim2) {
        editedCorrelations.push(buildCorrelation({
          atomType: correlationDim1.atomType,
          link: [buildNewLink2D(link, "x")]
        }));
        editedCorrelations.push(cloneCorrelationAndEditLink(hasChangedDim2 ? selectedCorrelationDim2 : _correlationDim2, link, "y", "add"));
      } else if (selectedCorrelationIdDim1 === "new" && selectedCorrelationIdDim2 === "new") {
        editedCorrelations.push(buildCorrelation({
          atomType: correlationDim1.atomType,
          link: [buildNewLink2D(link, "x")]
        }));
        editedCorrelations.push(buildCorrelation({
          atomType: correlationDim2.atomType,
          link: [buildNewLink2D(link, "y")]
        }));
      }
      buildCorrelationDataOptions.skipDataUpdate = true;
    }
  } else if (action === "remove") {
    const _correlationDim1 = cloneCorrelationAndEditLink(correlationDim1, link, "x", "remove");
    editedCorrelations.push(_correlationDim1);
    if (getLinkDim(link) === 2) {
      const _correlationDim2 = cloneCorrelationAndEditLink(correlationDim2, link, "y", "remove");
      editedCorrelations.push(_correlationDim2);
    }
  } else if (action === "unmove") {
    if (linkDim === 1) {
      if (selectedCorrelationDim1) {
        editedCorrelations.push(cloneCorrelationAndEditLink(selectedCorrelationDim1, link, "x", "unmove"));
      }
    } else if (linkDim === 2) {
      if (selectedCorrelationDim1 && selectedCorrelationDim2) {
        editedCorrelations.push(cloneCorrelationAndEditLink(selectedCorrelationDim1, link, "x", "unmove"));
        editedCorrelations.push(cloneCorrelationAndEditLink(selectedCorrelationDim2, link, "y", "unmove"));
      }
    }
  } else if (action === "setPathLength") {
    editedCorrelations.push(cloneCorrelationAndSetPathLength(correlationDim1, link, "x"));
    editedCorrelations.push(cloneCorrelationAndSetPathLength(correlationDim2, link, "y"));
  }
  return { editedCorrelations, buildCorrelationDataOptions };
}
function cloneCorrelationAndSetPathLength(correlation, editedLink, axis) {
  var _a, _b;
  const _correlation = cloneDeep_1(correlation);
  const linkDim = getLinkDim(editedLink);
  if (linkDim === 2) {
    const editedLinkID = editedLink.id.split("_")[axis === "x" ? 0 : 1];
    const _link = _correlation.link.find((link) => link.id === editedLinkID);
    if (_link) {
      const newPathLength = (_a = editedLink.signal.j) == null ? void 0 : _a.pathLength;
      if (isDefaultPathLength(newPathLength, _link.experimentType)) {
        (_b = _link.signal.j) == null ? true : delete _b.pathLength;
        if (_link.signal.j && Object.keys(_link.signal.j).length === 0) {
          delete _link.signal.j;
        }
        delete _link.edited.pathLength;
      } else {
        if (!_link.signal.j) {
          _link.signal.j = { pathLength: newPathLength };
        } else {
          _link.signal.j.pathLength = newPathLength;
        }
        _link.edited.pathLength = true;
      }
    }
  }
  return _correlation;
}
function convertValuesString(valuesString, key) {
  valuesString = valuesString.toLowerCase().replace(/\s+/g, "").split(",").map((token) => token === "sp" ? "sp1" : token).join(",");
  valuesString = valuesString.replaceAll("sp", "");
  let values = [];
  const regex = /^(?:[0-9],{0,1})+$/g;
  if (regex.test(valuesString)) {
    values = valuesString.split(",").filter((char) => char.length > 0).map((char) => Number(char));
  }
  values = values.filter((value) => value >= (key === "protonsCount" ? 0 : 1) && (key === "protonsCount" || value <= 3));
  return values.filter((index2, i, a) => a.indexOf(index2) === i);
}
function isInView(spectraData, activeTab, activeSpectrum, xDomain, yDomain, displayerMode, correlation) {
  if (correlation.pseudo === true) {
    return false;
  }
  if (activeSpectrum === null || !correlation.link.some((link) => link.experimentID === activeSpectrum.id)) {
    return false;
  }
  const atomTypesInView = activeTab.split(",").map((tab) => getAtomType(tab));
  const factor = 1e4;
  const xDomain0 = xDomain[0] * factor;
  const xDomain1 = xDomain[1] * factor;
  const yDomain0 = yDomain[0] * factor;
  const yDomain1 = yDomain[1] * factor;
  if (displayerMode === DISPLAYER_MODE.DM_1D) {
    const firstLink1D = correlation.link.find((link) => getLinkDim(link) === 1);
    if (!firstLink1D) {
      return false;
    }
    let delta = getLinkDelta(firstLink1D);
    if (delta === void 0) {
      return false;
    }
    delta *= factor;
    const spectrum = findSpectrum(spectraData, firstLink1D.experimentID, true);
    if (spectrum && atomTypesInView[0] === correlation.atomType && delta >= xDomain0 && delta <= xDomain1) {
      return true;
    }
    if (correlation.link.some((link) => {
      const spectrum2 = findSpectrum(spectraData, link.experimentID, true);
      return findSignalMatch1D(spectrum2, link, factor, xDomain0, xDomain1);
    })) {
      return true;
    }
  } else if (displayerMode === DISPLAYER_MODE.DM_2D) {
    if (!atomTypesInView.includes(correlation.atomType)) {
      return false;
    }
    const firstLink2D = correlation.link.find((link) => getLinkDim(link) === 2);
    if (!firstLink2D) {
      return false;
    }
    const spectrum = findSpectrum(spectraData, firstLink2D.experimentID, true);
    if (findSignalMatch2D(spectrum, firstLink2D, factor, xDomain0, xDomain1, yDomain0, yDomain1)) {
      return true;
    } else {
      if (correlation.link.some((link) => {
        const spectrum2 = findSpectrum(spectraData, link.experimentID, true);
        return findSignalMatch2D(spectrum2, link, factor, xDomain0, xDomain1, yDomain0, yDomain1);
      })) {
        return true;
      }
    }
  }
  return false;
}
function IsInView({ correlation }) {
  const {
    data: spectraData,
    xDomain,
    yDomain,
    displayerMode,
    activeTab,
    activeSpectrum
  } = useChartData();
  return react.exports.useMemo(() => isInView(spectraData, activeTab, activeSpectrum, xDomain, yDomain, displayerMode, correlation), [
    activeSpectrum,
    activeTab,
    correlation,
    displayerMode,
    spectraData,
    xDomain,
    yDomain
  ]);
}
const styles$o = css`
  margin-top: 10px;
  padding: 5px;
  text-align: center;

  p {
    font-size: 14px;
  }

  button:focus {
    outline: none;
  }

  button {
    flex: 2;
    padding: 5px;
    border: 1px solid gray;
    border-radius: 5px;
    height: 30px;
    margin: 0 auto;
    margin-top: 15px;
    display: block;
    width: 90px;

    color: white;
    background-color: gray;
  }
`;
function EditLinkConfirmation({
  description,
  onConfirm
}) {
  const handleOnConfirm = react.exports.useCallback((e2) => {
    e2.preventDefault();
    e2.stopPropagation();
    onConfirm();
  }, [onConfirm]);
  return /* @__PURE__ */ jsxs("div", {
    css: styles$o,
    children: [/* @__PURE__ */ jsx("p", {
      children: description
    }), /* @__PURE__ */ jsx("button", {
      type: "button",
      onClick: handleOnConfirm,
      children: "Confirm"
    })]
  });
}
const editPathLengthsStyles$1 = css`
  width: 100%;
  height: 100%;
  margin-top: 10px;
  text-align: center;

  .input-container {
    width: 100%;
    margin-top: 5px;
    text-align: center;

    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  button {
    flex: 2;
    padding: 5px;
    border: 1px solid gray;
    border-radius: 5px;
    height: 30px;
    margin: 0 auto;
    margin-top: 15px;
    display: block;
    width: 60px;

    color: white;
    background-color: gray;
  }

  .warning {
    margin-top: 5px;
    color: red;
  }
`;
function EditPathLength({
  signal,
  experimentType,
  onEdit
}) {
  var _a, _b, _c, _d;
  const [from, setFrom] = react.exports.useState(((_a = signal.j) == null ? void 0 : _a.pathLength) !== void 0 ? signal.j.pathLength.from : ((_b = DefaultPathLengths[experimentType]) == null ? void 0 : _b.from) || 0);
  const [to, setTo] = react.exports.useState(((_c = signal.j) == null ? void 0 : _c.pathLength) !== void 0 ? signal.j.pathLength.to : ((_d = DefaultPathLengths[experimentType]) == null ? void 0 : _d.to) || 0);
  const [isError, setIsError] = react.exports.useState(false);
  const handleOnEdit = react.exports.useCallback(() => {
    const pathLength = {
      from,
      to
    };
    const editedSignal = __spreadProps(__spreadValues({}, signal), {
      j: __spreadProps(__spreadValues({}, signal.j), {
        pathLength
      })
    });
    onEdit(editedSignal);
  }, [to, from, onEdit, signal]);
  react.exports.useEffect(() => {
    setIsError(from <= 0 || from > to);
  }, [to, from]);
  return /* @__PURE__ */ jsxs("div", {
    css: editPathLengthsStyles$1,
    children: [/* @__PURE__ */ jsx("p", {
      children: "Setting of the minimum and maximum path length (J coupling)."
    }), /* @__PURE__ */ jsxs("div", {
      className: "input-container",
      children: [/* @__PURE__ */ jsx(Label, {
        title: "Min:",
        style: {
          label: {
            marginRight: "5px",
            fontSize: "14px",
            fontWeight: "normal"
          }
        },
        children: /* @__PURE__ */ jsx(Input, {
          type: "number",
          value: from,
          onChange: (e2) => {
            setFrom(Number(e2.target.value));
          },
          style: {
            input: {
              color: isError ? "red" : "black"
            }
          }
        })
      }), /* @__PURE__ */ jsx(Label, {
        title: "Max:",
        style: {
          label: {
            marginRight: "5px",
            fontSize: "14px",
            fontWeight: "normal"
          }
        },
        children: /* @__PURE__ */ jsx(Input, {
          type: "number",
          value: to,
          onChange: (e2) => {
            setTo(Number(e2.target.value));
          }
        })
      })]
    }), isError ? /* @__PURE__ */ jsxs("p", {
      className: "warning",
      children: ["Minimum must not be 0 or higher than the maximum value.", " "]
    }) : /* @__PURE__ */ jsx(Button, {
      type: "button",
      onClick: handleOnEdit,
      disabled: isError,
      children: "Set"
    })]
  });
}
const moveLinkStyles = css`
  width: 100%;
  height: 100%;
  margin-top: 10px;
  text-align: center;

  p {
    font-size: 14px;
  }

  .selection-container {
    margin-top: 10px;
    width: 100%;
    text-align: center;
  }

  button {
    flex: 2;
    padding: 5px;
    border: 1px solid gray;
    border-radius: 5px;
    height: 30px;
    margin: 0 auto;
    margin-top: 15px;
    display: block;
    width: 60px;

    color: white;
    background-color: gray;
  }
`;
function MoveLink({
  correlationDim1,
  correlationDim2,
  link,
  correlations,
  onEdit
}) {
  const [selectedCorrelationIdDim1, setSelectedCorrelationIdDim1] = react.exports.useState(correlationDim1.id);
  const [selectedCorrelationIdDim2, setSelectedCorrelationIdDim2] = react.exports.useState((correlationDim2 == null ? void 0 : correlationDim2.id) || void 0);
  function getCorrelationLabel(correlation) {
    const delta = getCorrelationDelta(correlation);
    return `${delta ? delta.toFixed(2) : "?"}`;
  }
  const getSelection = react.exports.useCallback((correlation, dim) => {
    const selectionData = correlations.reduce((arr, _correlation) => {
      if (_correlation.pseudo === false && _correlation.atomType === link.atomType[dim]) {
        arr.push({
          key: _correlation.id,
          value: _correlation.id,
          label: `${_correlation.label.origin}: ${getCorrelationLabel(_correlation)}`
        });
      }
      return arr;
    }, []);
    selectionData.push({
      key: "new",
      value: "new",
      label: `new -> ${(dim === 0 ? getCorrelationDelta(correlationDim1) : getCorrelationDelta(correlationDim2)).toFixed(2)}`
    });
    return /* @__PURE__ */ jsx(Select, {
      onChange: (selection) => {
        if (dim === 0) {
          setSelectedCorrelationIdDim1(selection);
        } else {
          setSelectedCorrelationIdDim2(selection);
        }
      },
      data: selectionData,
      defaultValue: correlation.id,
      style: {
        width: 110,
        height: 25,
        margin: 0,
        border: "1px solid grey"
      }
    });
  }, [correlationDim1, correlationDim2, correlations, link.atomType]);
  return /* @__PURE__ */ jsxs("div", {
    css: moveLinkStyles,
    children: [/* @__PURE__ */ jsx("p", {
      children: "Move of signals on either one or both axes."
    }), /* @__PURE__ */ jsx("p", {
      children: '"New" means to separate into a new row or column.'
    }), /* @__PURE__ */ jsxs("div", {
      className: "selection-container",
      children: [getSelection(correlationDim1, 0), correlationDim2 && getSelection(correlationDim2, 1)]
    }), /* @__PURE__ */ jsx("button", {
      type: "button",
      onClick: () => onEdit(selectedCorrelationIdDim1, selectedCorrelationIdDim2),
      children: "Move"
    })]
  });
}
const modalContainer$2 = css`
  width: 490px;
  height: 220px;
  padding: 5px;

  button:focus {
    outline: none;
  }

  .header {
    height: 24px;
    border-bottom: 1px solid #f0f0f0;
    display: flex;
    align-items: center;

    button {
      height: 36px;
      margin: 2px;
      background-color: transparent;
      border: none;
      svg {
        height: 16px;
      }
    }

    p {
      font-weight: bold;

      margin-bottom: 5px;
      margin-right: 30px;
      padding: 0px 10px;
      width: 100%;

      text-align: center;
    }
  }

  button {
    flex: 2;
    padding: 5px;
    border: 1px solid gray;
    border-radius: 5px;
    height: 30px;
    margin: 0 auto;
    margin-top: 15px;
    display: block;
    width: 20%;

    color: white;
    background-color: gray;
  }

  .tabs-container {
    width: 100%;
    flex: 1;
    overflow: auto;
    border: none;
  }
`;
function EditLinkModal({
  correlationDim1,
  correlationDim2,
  link,
  correlations,
  onClose,
  onEdit
}) {
  const [activeTab, setActiveTab2] = react.exports.useState("move");
  const getLinkLabel = react.exports.useCallback(() => {
    const linkDim = getLinkDim(link);
    if (linkDim === 1) {
      return ` 1D (${link.signal.delta.toFixed(3)})`;
    } else if (linkDim === 2) {
      return `${link.signal.x ? `${link.signal.x.delta.toFixed(2)}` : "?"} (${correlationDim1.label.origin}), ${link.signal.y ? link.signal.y.delta.toFixed(2) : "?"} (${correlationDim2.label.origin})`;
    }
    return "";
  }, [correlationDim1.label.origin, link, correlationDim2]);
  const handleOnEdit = react.exports.useCallback((action, selectedCorrelationIdDim1, selectedCorrelationIdDim2, editedLink) => {
    const {
      editedCorrelations,
      buildCorrelationDataOptions
    } = getEditedCorrelations({
      correlationDim1,
      correlationDim2,
      selectedCorrelationIdDim1,
      selectedCorrelationIdDim2,
      action,
      link: editedLink || link,
      correlations
    });
    onEdit(editedCorrelations, action, editedLink || link, buildCorrelationDataOptions);
    onClose == null ? void 0 : onClose();
  }, [correlationDim1, correlationDim2, correlations, link, onClose, onEdit]);
  const tabsContainer = react.exports.useMemo(() => /* @__PURE__ */ jsx("div", {
    className: "tabs-container",
    children: /* @__PURE__ */ jsxs(Tabs$1, {
      position: PositionsEnum.TOP,
      activeTab,
      onClick: (tab) => setActiveTab2(tab.tabid),
      children: [/* @__PURE__ */ jsx(Tab, {
        tablabel: "Move",
        tabid: "move",
        children: /* @__PURE__ */ jsx(MoveLink, {
          correlationDim1,
          correlationDim2,
          link,
          correlations,
          onEdit: (correlationIdDim1, correlationIdDim2) => handleOnEdit("move", correlationIdDim1, correlationIdDim2)
        })
      }), /* @__PURE__ */ jsx(Tab, {
        tablabel: "Unmove",
        tabid: "unmove",
        children: /* @__PURE__ */ jsx(EditLinkConfirmation, {
          description: "Movement of signal to its original place.",
          onConfirm: () => handleOnEdit("unmove", correlationDim1.id, correlationDim2.id)
        })
      }), /* @__PURE__ */ jsx(Tab, {
        tablabel: "Remove",
        tabid: "remove",
        children: /* @__PURE__ */ jsx(EditLinkConfirmation, {
          description: "Deletion of signal.",
          onConfirm: () => handleOnEdit("remove", void 0, void 0)
        })
      }), /* @__PURE__ */ jsx(Tab, {
        tablabel: "J Coupling",
        tabid: "setPathLength",
        children: /* @__PURE__ */ jsx(EditPathLength, {
          signal: link.signal,
          experimentType: link.experimentType,
          onEdit: (editedSignal) => {
            const editedLink = __spreadProps(__spreadValues({}, link), {
              signal: editedSignal
            });
            handleOnEdit("setPathLength", correlationDim1, correlationDim2, editedLink);
          }
        })
      })]
    })
  }), [activeTab, correlationDim1, correlationDim2, correlations, handleOnEdit, link]);
  return /* @__PURE__ */ jsxs("div", {
    css: modalContainer$2,
    children: [/* @__PURE__ */ jsxs("div", {
      className: "header handle",
      children: [/* @__PURE__ */ jsx(CloseButton$1, {
        onClick: onClose
      }), /* @__PURE__ */ jsx("p", {
        className: "header-info",
        children: `${link.experimentType.toUpperCase()} signal at ${getLinkLabel()}`
      })]
    }), tabsContainer]
  });
}
function AdditionalColumnHeader({
  spectraData,
  correlationsData,
  correlation,
  onEdit
}) {
  var _b;
  const contextRef = react.exports.useRef();
  const modal = useModal();
  const highlightIDsAdditionalColumn = react.exports.useMemo(() => {
    if (correlation.pseudo === true) {
      return [];
    }
    const ids = [];
    correlation.link.forEach((link) => {
      if (link.pseudo === false) {
        ids.push(link.signal.id);
        ids.push(buildID(link.signal.id, "Crosshair_X"));
        const _id = findRangeOrZoneID(spectraData, link.experimentID, link.signal.id, true);
        if (_id) {
          ids.push(_id);
        }
      }
    });
    return ids;
  }, [correlation, spectraData]);
  const highlightAdditionalColumn = useHighlight(highlightIDsAdditionalColumn);
  const mouseEnterHandler = react.exports.useCallback((event) => {
    event.currentTarget.focus();
    highlightAdditionalColumn.show();
  }, [highlightAdditionalColumn]);
  const mouseLeaveHandler = react.exports.useCallback((event) => {
    event.currentTarget.blur();
    highlightAdditionalColumn.hide();
  }, [highlightAdditionalColumn]);
  const isInView2 = IsInView({
    correlation
  });
  const tableHeaderProps = react.exports.useMemo(() => {
    return {
      style: __spreadProps(__spreadValues({}, {
        color: getLabelColor(correlationsData, correlation) || void 0
      }), {
        backgroundColor: highlightAdditionalColumn.isActive ? "#ff6f0057" : isInView2 ? "#f5f5dc" : "inherit"
      }),
      title: correlation.pseudo === false && correlation.link.reduce((arr, link) => {
        if (link.pseudo === false && !arr.includes(link.experimentType.toUpperCase())) {
          arr.push(link.experimentType.toUpperCase());
        }
        return arr;
      }, []).sort().join("/"),
      onMouseEnter: mouseEnterHandler,
      onMouseLeave: mouseLeaveHandler
    };
  }, [correlation, correlationsData, highlightAdditionalColumn.isActive, isInView2, mouseEnterHandler, mouseLeaveHandler]);
  const equivalenceTextStyle = react.exports.useMemo(() => {
    return correlation.edited.equivalence ? {
      backgroundColor: "#F7F2E0"
    } : {
      color: Number.isInteger(correlation.equivalence) ? correlation.equivalence === 1 ? "#bebebe" : "black" : "red"
    };
  }, [correlation]);
  const contextMenu = react.exports.useMemo(() => {
    return correlation.pseudo === false ? correlation.link.filter((link) => getLinkDim(link) === 1 && link.pseudo === false).map((link) => {
      var _a2;
      return {
        label: `edit 1D (${link.signal.delta.toFixed(3)}${((_a2 = link.edited) == null ? void 0 : _a2.moved) === true ? "[MOVED]" : ""})`,
        onClick: () => {
          highlightAdditionalColumn.hide();
          modal.show(/* @__PURE__ */ jsx(EditLinkModal, {
            onClose: () => modal.close(),
            onEdit,
            link,
            correlationDim1: correlation,
            correlationDim2: void 0,
            correlations: correlationsData.values
          }), {
            position: positions.MIDDLE_RIGHT,
            isBackgroundBlur: false
          });
        }
      };
    }).concat([{
      label: `delete all (${correlation.label.origin})`,
      onClick: () => {
        modal.showConfirmDialog({
          message: `All signals of ${correlation.label.origin} (${getCorrelationDelta(correlation).toFixed(2)}) will be deleted. Are you sure?`,
          buttons: [{
            text: "Yes",
            handler: () => {
              onEdit([correlation], "removeAll");
            }
          }, {
            text: "No"
          }]
        });
        highlightAdditionalColumn.hide();
      }
    }]) : [];
  }, [correlation, correlationsData.values, highlightAdditionalColumn, modal, onEdit]);
  const contextMenuHandler = react.exports.useCallback((e2) => {
    e2.preventDefault();
    contextRef.current.handleContextMenu(e2);
  }, [contextRef]);
  const _a = tableHeaderProps, {
    title
  } = _a, thProps = __objRest(_a, [
    "title"
  ]);
  return /* @__PURE__ */ jsx("th", __spreadProps(__spreadValues({}, thProps), {
    title: title === false ? void 0 : title,
    children: /* @__PURE__ */ jsxs("div", {
      style: {
        display: "block"
      },
      onContextMenu: (e2) => {
        if (contextMenu.length > 0) {
          contextMenuHandler(e2);
        }
      },
      children: [/* @__PURE__ */ jsx("p", {
        children: correlation.label.origin
      }), /* @__PURE__ */ jsx("p", {
        children: getCorrelationDelta(correlation) ? (_b = getCorrelationDelta(correlation)) == null ? void 0 : _b.toFixed(2) : ""
      }), /* @__PURE__ */ jsx("p", {
        style: equivalenceTextStyle,
        children: Number.isInteger(correlation.equivalence) ? correlation.equivalence : correlation.equivalence.toFixed(2)
      }), /* @__PURE__ */ jsx(ContextMenu$1, {
        ref: contextRef,
        context: contextMenu
      })]
    })
  }));
}
function AdditionalColumnField({
  rowCorrelation,
  columnCorrelation,
  commonLinks,
  correlations,
  spectraData,
  onEdit
}) {
  const contextRef = react.exports.useRef();
  const modal = useModal();
  const highlightIDsCommonLinks = react.exports.useMemo(() => {
    const ids = [];
    commonLinks.forEach((link) => {
      if (link.pseudo === false) {
        ids.push(link.signal.id);
        ids.push(buildID(link.signal.id, "Crosshair"));
        const _id = findRangeOrZoneID(spectraData, link.experimentID, link.signal.id, true);
        if (_id) {
          ids.push(_id);
        }
      }
    });
    return ids;
  }, [commonLinks, spectraData]);
  const highlightCommonLinks = useHighlight(highlightIDsCommonLinks);
  const mouseEnterHandler = react.exports.useCallback((event) => {
    event.currentTarget.focus();
    highlightCommonLinks.show();
  }, [highlightCommonLinks]);
  const mouseLeaveHandler = react.exports.useCallback((event) => {
    event.currentTarget.blur();
    highlightCommonLinks.hide();
  }, [highlightCommonLinks]);
  const contextMenuHandler = react.exports.useCallback((e2) => {
    e2.preventDefault();
    contextRef.current.handleContextMenu(e2);
  }, [contextRef]);
  const handleEditPseudoHSQC = react.exports.useCallback((action, link) => {
    const pseudoLinkCountHSQC = rowCorrelation.link.filter((_link) => (_link.experimentType === "hsqc" || _link.experimentType === "hmqc") && _link.pseudo === true).length;
    let _correlationDim1;
    let _correlationDim2;
    if (action === "add") {
      const commonPseudoLink = buildLink({
        experimentType: "hsqc",
        experimentID: generateID(),
        atomType: [columnCorrelation.atomType, rowCorrelation.atomType],
        id: generateID(),
        pseudo: true,
        signal: {
          id: generateID(),
          sign: 0
        }
      });
      _correlationDim1 = cloneCorrelationAndEditLink(columnCorrelation, commonPseudoLink, "x", "add");
      _correlationDim2 = cloneCorrelationAndEditLink(rowCorrelation, commonPseudoLink, "y", "add");
      if (!_correlationDim2.edited.protonsCount) {
        _correlationDim2.protonsCount = [pseudoLinkCountHSQC + 1];
      }
    } else {
      _correlationDim1 = cloneCorrelationAndEditLink(columnCorrelation, link, "x", "remove");
      _correlationDim2 = cloneCorrelationAndEditLink(rowCorrelation, link, "y", "remove");
      if (!_correlationDim2.edited.protonsCount) {
        _correlationDim2.protonsCount = pseudoLinkCountHSQC - 1 > 0 ? [pseudoLinkCountHSQC - 1] : [];
      }
    }
    onEdit([_correlationDim1, _correlationDim2], action, link, {
      skipDataUpdate: true
    });
  }, [columnCorrelation, onEdit, rowCorrelation]);
  const contextMenu = react.exports.useMemo(() => {
    const commonLinksMenu = commonLinks.map((commonLink) => {
      var _a;
      const commonLinkContextMenuLabel = `${getAbbreviation(commonLink)} (${commonLink.signal.x ? commonLink.signal.x.delta.toFixed(2) : "?"}, ${commonLink.signal.y ? commonLink.signal.y.delta.toFixed(2) : "?"})${((_a = commonLink.edited) == null ? void 0 : _a.moved) === true ? "[MOVED]" : ""}`;
      return commonLink.pseudo === false ? [{
        label: `edit ${commonLinkContextMenuLabel}`,
        onClick: () => {
          highlightCommonLinks.hide();
          modal.show(/* @__PURE__ */ jsx$1(EditLinkModal, {
            onClose: () => modal.close(),
            onEdit,
            link: commonLink,
            correlationDim1: columnCorrelation,
            correlationDim2: rowCorrelation,
            correlations
          }), {
            position: positions.MIDDLE_RIGHT,
            isBackgroundBlur: false
          });
        }
      }] : [];
    }).flat();
    const commonPseudoLinkHSQC = commonLinks.find((commonLink) => commonLink.pseudo === true && commonLink.experimentType === "hsqc");
    if (rowCorrelation.pseudo === true) {
      if (commonPseudoLinkHSQC) {
        commonLinksMenu.push({
          label: "remove pseudo HSQC",
          onClick: () => handleEditPseudoHSQC("remove", commonPseudoLinkHSQC)
        });
      } else {
        commonLinksMenu.push({
          label: "add pseudo HSQC",
          onClick: () => handleEditPseudoHSQC("add")
        });
      }
    }
    return commonLinksMenu;
  }, [columnCorrelation, commonLinks, correlations, handleEditPseudoHSQC, highlightCommonLinks, modal, onEdit, rowCorrelation]);
  const contentLabel = react.exports.useMemo(() => commonLinks.map((commonLink, i) => {
    var _a;
    return /* @__PURE__ */ jsxs$1("label", {
      children: [/* @__PURE__ */ jsx$1("label", {
        style: {
          color: commonLink.pseudo === true || ((_a = commonLink.edited) == null ? void 0 : _a.moved) === true ? "blue" : "black"
        },
        children: getAbbreviation(commonLink)
      }), i < commonLinks.length - 1 && /* @__PURE__ */ jsx$1("label", {
        children: "/"
      })]
    }, commonLink.id);
  }), [commonLinks]);
  const title = react.exports.useMemo(() => commonLinks.reduce((arr, link) => {
    if (!arr.includes(link.experimentType.toUpperCase())) {
      arr.push(link.experimentType.toUpperCase());
    }
    return arr;
  }, []).join("/"), [commonLinks]);
  const isInViewRow = IsInView({
    correlation: rowCorrelation
  });
  const isInViewColumn = IsInView({
    correlation: columnCorrelation
  });
  return /* @__PURE__ */ jsxs$1("td", {
    onContextMenu: (e2) => {
      if (contextMenu.length > 0) {
        contextMenuHandler(e2);
      }
    },
    style: {
      backgroundColor: highlightCommonLinks.isActive ? "#ff6f0057" : isInViewColumn || isInViewRow ? "#f5f5dc" : "inherit"
    },
    title,
    onMouseEnter: mouseEnterHandler,
    onMouseLeave: mouseLeaveHandler,
    children: [contentLabel, /* @__PURE__ */ jsx$1(ContextMenu$1, {
      ref: contextRef,
      context: contextMenu
    })]
  });
}
function CorrelationTableRow({
  additionalColumnData,
  correlations,
  correlation,
  styleRow,
  styleLabel,
  onSaveEditEquivalences,
  onSaveEditNumericValues,
  onEditCorrelationTableCellHandler,
  spectraData
}) {
  var _b;
  const contextRef = react.exports.useRef();
  const modal = useModal();
  const highlightIDsRow = react.exports.useMemo(() => {
    if (correlation.pseudo === true) {
      return [];
    }
    const ids = [];
    correlation.link.forEach((link) => {
      if (link.pseudo === false) {
        ids.push(link.signal.id);
        ids.push(buildID(link.signal.id, "Crosshair_Y"));
        const _id = findRangeOrZoneID(spectraData, link.experimentID, link.signal.id, true);
        if (_id) {
          ids.push(_id);
        }
      }
    });
    return ids;
  }, [correlation, spectraData]);
  const highlightRow = useHighlight(highlightIDsRow);
  const onSaveEquivalencesHandler = react.exports.useCallback((e2) => {
    onSaveEditEquivalences(correlation, e2.target.value);
  }, [correlation, onSaveEditEquivalences]);
  const onSaveEditNumericValuesHandler = react.exports.useCallback((e2, key) => {
    onSaveEditNumericValues({
      correlation,
      values: convertValuesString(e2.target.value, key),
      key
    });
  }, [correlation, onSaveEditNumericValues]);
  const additionalColumnFields = react.exports.useMemo(() => {
    return additionalColumnData.map((_correlation) => {
      const commonLinks = [];
      correlation.link.forEach((link) => {
        _correlation.link.forEach((_link) => {
          if (link.axis !== _link.axis && link.experimentID === _link.experimentID && link.signal.id === _link.signal.id && !commonLinks.some((_commonLink) => _commonLink.signal.id === link.signal.id)) {
            let experimentLabel = link.experimentType;
            if (link.signal && link.signal.sign !== 0) {
              experimentLabel += link.signal.sign === 1 ? " (+)" : " (-)";
            }
            commonLinks.push(buildLink(__spreadProps(__spreadValues({}, link), {
              experimentLabel,
              axis: void 0,
              id: `${_link.id}_${link.id}`
            })));
          }
        });
      });
      return /* @__PURE__ */ jsx$1(AdditionalColumnField, {
        rowCorrelation: correlation,
        columnCorrelation: _correlation,
        commonLinks,
        correlations,
        spectraData,
        onEdit: onEditCorrelationTableCellHandler
      }, `addColData_${correlation.id}_${_correlation.id}`);
    });
  }, [additionalColumnData, correlation, correlations, onEditCorrelationTableCellHandler, spectraData]);
  const equivalenceCellStyle = react.exports.useMemo(() => {
    return correlation.edited.equivalence ? {
      color: "blue"
    } : {
      color: correlation.equivalence === 1 ? "#bebebe" : "black"
    };
  }, [correlation]);
  const mouseEnterHandler = react.exports.useCallback((event) => {
    event.currentTarget.focus();
    highlightRow.show();
  }, [highlightRow]);
  const mouseLeaveHandler = react.exports.useCallback((event) => {
    event.currentTarget.blur();
    highlightRow.hide();
  }, [highlightRow]);
  const isInView2 = IsInView({
    correlation
  });
  const tableDataProps = react.exports.useMemo(() => {
    return {
      style: __spreadProps(__spreadValues({}, styleRow), {
        backgroundColor: highlightRow.isActive ? "#ff6f0057" : isInView2 ? "#f5f5dc" : "inherit"
      }),
      title: correlation.pseudo === false && correlation.link.reduce((arr, link) => {
        if (link.pseudo === false && !arr.includes(link.experimentType.toUpperCase())) {
          arr.push(link.experimentType.toUpperCase());
        }
        return arr;
      }, []).sort().join("/"),
      onMouseEnter: mouseEnterHandler,
      onMouseLeave: mouseLeaveHandler
    };
  }, [correlation.link, correlation.pseudo, highlightRow.isActive, isInView2, mouseEnterHandler, mouseLeaveHandler, styleRow]);
  const contextMenu = react.exports.useMemo(() => {
    return correlation.pseudo === false ? correlation.link.filter((link) => getLinkDim(link) === 1 && link.pseudo === false).map((link) => {
      var _a2;
      return {
        label: `edit 1D (${link.signal.delta.toFixed(3)})${((_a2 = link.edited) == null ? void 0 : _a2.moved) === true ? "[MOVED]" : ""}`,
        onClick: () => {
          highlightRow.hide();
          modal.show(/* @__PURE__ */ jsx$1(EditLinkModal, {
            onClose: () => modal.close(),
            onEdit: onEditCorrelationTableCellHandler,
            link,
            correlationDim1: correlation,
            correlationDim2: void 0,
            correlations
          }), {
            position: positions.MIDDLE_RIGHT,
            isBackgroundBlur: false
          });
        }
      };
    }).concat([{
      label: `delete ${correlation.label.origin}`,
      onClick: () => {
        modal.showConfirmDialog({
          message: `All signals of ${correlation.label.origin} (${getCorrelationDelta(correlation).toFixed(2)}) will be deleted. Are you sure?`,
          buttons: [{
            text: "Yes",
            handler: () => {
              onEditCorrelationTableCellHandler([correlation], "removeAll");
            }
          }, {
            text: "No"
          }]
        });
        highlightRow.hide();
      }
    }]) : [];
  }, [correlation, highlightRow, modal, onEditCorrelationTableCellHandler, correlations]);
  const contextMenuHandler = react.exports.useCallback((e2) => {
    e2.preventDefault();
    contextRef.current.handleContextMenu(e2);
  }, [contextRef]);
  const _a = tableDataProps, {
    title
  } = _a, otherTableDataProps = __objRest(_a, [
    "title"
  ]);
  const t = !title ? "" : title;
  return /* @__PURE__ */ jsxs$1("tr", {
    style: styleRow,
    children: [/* @__PURE__ */ jsxs$1("td", __spreadProps(__spreadValues({
      title: t
    }, otherTableDataProps), {
      style: __spreadProps(__spreadValues({}, tableDataProps.style), {
        styleLabel
      }),
      onContextMenu: (e2) => {
        if (contextMenu.length > 0) {
          contextMenuHandler(e2);
        }
      },
      children: [getLabel(correlations, correlation), /* @__PURE__ */ jsx$1(ContextMenu$1, {
        ref: contextRef,
        context: contextMenu
      })]
    })), /* @__PURE__ */ jsx$1("td", __spreadProps(__spreadValues({
      title: t
    }, otherTableDataProps), {
      children: getCorrelationDelta(correlation) ? (_b = getCorrelationDelta(correlation)) == null ? void 0 : _b.toFixed(2) : ""
    })), /* @__PURE__ */ jsx$1("td", __spreadProps(__spreadValues({
      title: t
    }, otherTableDataProps), {
      children: correlation.pseudo === false ? correlation.atomType !== "H" ? /* @__PURE__ */ jsx$1(EditableColumn$1, {
        type: "number",
        value: correlation.equivalence,
        style: equivalenceCellStyle,
        onSave: onSaveEquivalencesHandler
      }) : /* @__PURE__ */ jsx$1("text", {
        style: equivalenceCellStyle,
        children: correlation.equivalence
      }) : ""
    })), /* @__PURE__ */ jsx$1("td", __spreadProps(__spreadValues({
      title: t
    }, otherTableDataProps), {
      children: correlation.atomType !== "H" ? /* @__PURE__ */ jsx$1(EditableColumn$1, {
        type: "text",
        value: correlation.protonsCount.join(","),
        style: correlation.edited.protonsCount ? {
          color: "blue"
        } : {},
        onSave: (e2) => onSaveEditNumericValuesHandler(e2, "protonsCount")
      }) : ""
    })), /* @__PURE__ */ jsx$1("td", __spreadProps(__spreadValues({
      title: t
    }, otherTableDataProps), {
      style: __spreadProps(__spreadValues({}, tableDataProps.style), {
        borderRight: "1px solid"
      }),
      children: correlation.atomType !== "H" ? /* @__PURE__ */ jsx$1(EditableColumn$1, {
        type: "text",
        value: correlation.hybridization.map((hybrid) => `sp${hybrid}`).join(","),
        style: correlation.edited.hybridization ? {
          color: "blue"
        } : {},
        onSave: (e2) => onSaveEditNumericValuesHandler(e2, "hybridization")
      }) : ""
    })), additionalColumnFields]
  });
}
const tableStyle$1 = css`
  overflow: auto;
  height: 100%;
  display: block;
  table {
    border-spacing: 0;
    border: 1px solid #dedede;
    width: 100%;
    font-size: 12px;
    height: 100%;
  }
  tr {
    :last-child {
      td {
        border-bottom: 0;
      }
    }
  }
  thead tr {
    background-color: white !important;
  }
  th {
    position: sticky;
    background-color: white;
    top: 0;
  }

  th,
  td {
    white-space: nowrap;
    text-align: center;
    margin: 0;
    padding: 0.4rem;
    border-bottom: 1px solid #dedede;
    border-right: 1px solid #dedede;

    :last-child {
      border-right: 0;
    }
    button {
      background-color: transparent;
      border: none;
    }
  }
`;
function CorrelationTable({
  correlationsData,
  filteredCorrelationsData,
  additionalColumnData,
  editEquivalencesSaveHandler,
  onSaveEditNumericValues,
  onEditCorrelationTableCellHandler,
  showProtonsAsRows,
  spectraData
}) {
  const rows = react.exports.useMemo(() => {
    if (!filteredCorrelationsData) {
      return [];
    }
    return filteredCorrelationsData.values.filter((correlation) => showProtonsAsRows ? correlation.atomType === "H" : correlation.atomType !== "H").map((correlation) => /* @__PURE__ */ jsx(CorrelationTableRow, {
      additionalColumnData,
      correlations: correlationsData.values,
      correlation,
      styleRow: {
        backgroundColor: "mintcream"
      },
      styleLabel: correlation.atomType === "H" ? {
        color: getLabelColor(correlationsData, correlation)
      } : {},
      onSaveEditEquivalences: editEquivalencesSaveHandler,
      onSaveEditNumericValues,
      onEditCorrelationTableCellHandler,
      spectraData
    }, `correlation${correlation.atomType}${correlation.id}`));
  }, [filteredCorrelationsData, showProtonsAsRows, additionalColumnData, correlationsData, editEquivalencesSaveHandler, onSaveEditNumericValues, onEditCorrelationTableCellHandler, spectraData]);
  const additionalColumnHeader = react.exports.useMemo(() => additionalColumnData.map((correlation) => /* @__PURE__ */ jsx(AdditionalColumnHeader, {
    spectraData,
    correlationsData,
    correlation,
    onEdit: onEditCorrelationTableCellHandler
  }, `additionalCorrelationHeader_${correlation.id}`)), [additionalColumnData, correlationsData, onEditCorrelationTableCellHandler, spectraData]);
  return /* @__PURE__ */ jsx("div", {
    css: tableStyle$1,
    children: /* @__PURE__ */ jsxs("table", {
      children: [/* @__PURE__ */ jsx("thead", {
        children: /* @__PURE__ */ jsxs("tr", {
          children: [/* @__PURE__ */ jsx("th", {
            children: "Atom"
          }), /* @__PURE__ */ jsx("th", {
            children: "\u03B4 (ppm)"
          }), /* @__PURE__ */ jsx("th", {
            children: "Equiv"
          }), /* @__PURE__ */ jsx("th", {
            children: "#H"
          }), /* @__PURE__ */ jsx("th", {
            style: {
              borderRight: "1px solid"
            },
            children: "Hybrid"
          }), additionalColumnHeader]
        })
      }), /* @__PURE__ */ jsx("tbody", {
        children: rows
      })]
    })
  });
}
const styles$n = css`
  display: flex;
  width: 100%;
  font-size: 15px;
  font-weight: 300;
  white-space: nowrap;
  span {
    margin-left: 8px;
  }
`;
function Overview({
  correlationsData
}) {
  if (!correlationsData) {
    return null;
  }
  const atoms = getAtomCounts(correlationsData.options.mf);
  const elements = Object.keys(atoms).length > 0 ? Object.keys(atoms).map((atomType, i) => {
    const stateAtomType = correlationsData.state[atomType];
    const error = stateAtomType ? stateAtomType.error : void 0;
    const errorColorIndex = error ? Errors.findIndex((_error) => error[_error] !== void 0) : "black";
    return /* @__PURE__ */ jsx("span", {
      style: {
        color: stateAtomType ? stateAtomType.complete === true && (!error || Object.keys(error).length === 0) ? "green" : errorColorIndex >= 0 ? ErrorColors[errorColorIndex].color : "black" : "black"
      },
      children: `${atomType}: ${stateAtomType ? stateAtomType.current : "-"}/${atoms[atomType]}   `
    }, `molFormulaView_${i}`);
  }) : /* @__PURE__ */ jsx("p", {
    style: {
      fontStyle: "italic",
      color: "orange"
    },
    children: "Molecular formula is not set"
  });
  return /* @__PURE__ */ jsx("div", {
    css: styles$n,
    children: elements
  });
}
var Overview$1 = react.exports.memo(Overview);
const inputStyle = css`
  text-align: center;

  input {
    height: 100%;
    width: 200px;
    border-radius: 5px;
    border: 0.55px solid #c7c7c7;
    margin: 0px 5px 0px 5px;
    text-align: center;
  }

  button {
    flex: 2;
    padding: 5px;
    border: 1px solid gray;
    border-radius: 5px;
    height: 36px;
    margin: 0 auto;
    margin-top: 15px;
    display: block;
    width: 20%;

    color: white;
    background-color: gray;
  }
`;
function MolecularFormulaInput({
  onSave = () => null,
  previousMF
}) {
  const [mf, setMF] = react.exports.useState("");
  const [isValidMF, setIsValidMF] = react.exports.useState(true);
  const [hasChanged, setHasChanged] = react.exports.useState(false);
  const checkMF = react.exports.useCallback((mf2) => {
    if (mf2.trim().length === 0) {
      return false;
    }
    try {
      getAtomsFromMF(mf2);
      return true;
    } catch (error) {
      return false;
    }
  }, []);
  const onChangeHandler = react.exports.useCallback((e2) => {
    setHasChanged(true);
    if (checkMF(e2.target.value)) {
      setIsValidMF(true);
      setMF(e2.target.value);
    } else {
      setIsValidMF(false);
      setMF("");
    }
  }, [checkMF]);
  const onSaveHandler = react.exports.useCallback(() => {
    onSave(hasChanged ? mf.trim() : previousMF);
  }, [hasChanged, mf, onSave, previousMF]);
  return /* @__PURE__ */ jsxs("div", {
    css: inputStyle,
    children: [/* @__PURE__ */ jsx("input", {
      type: "text",
      onChange: onChangeHandler,
      defaultValue: previousMF
    }), /* @__PURE__ */ jsx("button", {
      type: "button",
      onClick: onSaveHandler,
      disabled: !isValidMF,
      children: isValidMF ? "Set" : "Invalid"
    })]
  });
}
const modalContainer$1 = css`
  overflow: auto;
  width: 400px;
  height: 550px;
  padding: 5px;
  button:focus {
    outline: none;
  }
  .header {
    height: 24px;
    border-bottom: 1px solid #f0f0f0;
    display: flex;
    align-items: center;

    button {
      height: 36px;
      margin: 2px;
      background-color: transparent;
      border: none;
      svg {
        height: 16px;
      }
    }
  }

  button {
    flex: 2;
    padding: 5px;
    border: 1px solid gray;
    border-radius: 5px;
    height: 30px;
    margin: 0 auto;
    margin-top: 15px;
    display: block;
    width: 20%;

    color: white;
    background-color: gray;
  }

  .info {
    margin-top: 0;
    margin-bottom: 10px;
    padding: 0px 10px;
    width: 100%;

    text-align: center;
  }

  .optional {
    margin-top: 20px;
    margin-bottom: 5px;
    padding: 0px 10px;

    text-align: center;
    font-size: 18px;
    font-weight: bold;
  }
  .optional2 {
    margin-top: 5px;
    margin-bottom: 25px;
    padding: 0px 10px;
    width: 100%;

    text-align: center;
  }
`;
function SetMolecularFormulaModal({
  onClose,
  onSave,
  molecules,
  previousMF
}) {
  const [currentIndex, setCurrentIndex] = react.exports.useState(0);
  react.exports.useEffect(() => {
    if (molecules && molecules.length > 0) {
      setCurrentIndex(0);
    }
  }, [molecules]);
  const onSaveHandlerMolecularFormulaInput = react.exports.useCallback((mf) => {
    onSave == null ? void 0 : onSave(mf);
    onClose == null ? void 0 : onClose();
  }, [onClose, onSave]);
  const onSaveHandlerMoleculeSelection = react.exports.useCallback(() => {
    onSave == null ? void 0 : onSave(molecules[currentIndex].mf);
    onClose == null ? void 0 : onClose();
  }, [currentIndex, molecules, onClose, onSave]);
  const onChangeHandlerMoleculeSelection = react.exports.useCallback((index2) => {
    setCurrentIndex(index2);
  }, []);
  return /* @__PURE__ */ jsxs("div", {
    css: modalContainer$1,
    children: [/* @__PURE__ */ jsx("div", {
      className: "header handle",
      children: /* @__PURE__ */ jsx(CloseButton$1, {
        onClick: onClose
      })
    }), /* @__PURE__ */ jsx("div", {
      children: /* @__PURE__ */ jsx("p", {
        className: "info",
        children: "Please type in a molecular formula!"
      })
    }), /* @__PURE__ */ jsx(MolecularFormulaInput, {
      onSave: onSaveHandlerMolecularFormulaInput,
      previousMF
    }), /* @__PURE__ */ jsxs("div", {
      children: [/* @__PURE__ */ jsx("p", {
        className: "optional",
        children: "OR"
      }), /* @__PURE__ */ jsx("p", {
        className: "optional2",
        children: "Select a molecule as reference!"
      })]
    }), /* @__PURE__ */ jsx(MoleculeSelection, {
      molecules,
      onChange: onChangeHandlerMoleculeSelection
    }), /* @__PURE__ */ jsx("button", {
      type: "button",
      onClick: onSaveHandlerMoleculeSelection,
      children: "Set"
    })]
  });
}
const modalContainer = css`
  width: 220px;
  height: 270px;
  padding: 5px;
  text-align: center;

  button:focus {
    outline: none;
  }

  .header {
    height: 24px;
    border-bottom: 1px solid #f0f0f0;
    display: flex;
    align-items: center;

    span {
      color: #464646;
      font-size: 15px;
      flex: 1;
      user-select: none;
    }

    button {
      height: 36px;
      margin: 2px;
      background-color: transparent;
      border: none;
      svg {
        height: 16px;
      }
    }
  }

  button {
    flex: 2;
    padding: 5px;
    border: 1px solid gray;
    border-radius: 5px;
    height: 30px;
    margin: 0 auto;
    margin-top: 15px;
    display: block;
    width: 20%;

    color: white;
    background-color: gray;
  }

  table {
    margin-top: 10px;
    width: 100%;

    input::-webkit-outer-spin-button,
    input::-webkit-inner-spin-button {
      -webkit-appearance: none;
    }

    input {
      width: 100px;
      text-align: center;
      border-radius: 5px;
      border: 0.55px solid #c7c7c7;
    }
  }
`;
function SetShiftToleranceModal({
  onClose,
  onSave,
  previousTolerance
}) {
  const [tolerance, setTolerance] = react.exports.useState();
  const [isValid, setIsValid] = react.exports.useState({});
  react.exports.useEffect(() => {
    if (previousTolerance) {
      setTolerance(previousTolerance);
      const _isValid = {};
      Object.keys(previousTolerance).forEach((atomType) => {
        _isValid[atomType] = true;
      });
      setIsValid(_isValid);
    } else {
      setTolerance(void 0);
    }
  }, [previousTolerance]);
  const onSaveHandler = react.exports.useCallback(() => {
    onSave == null ? void 0 : onSave(tolerance);
    onClose == null ? void 0 : onClose();
  }, [onClose, onSave, tolerance]);
  const onChangeHandler = react.exports.useCallback((e2, atomType) => {
    const value = e2.target.value;
    if (value.trim().length > 0) {
      setTolerance(__spreadProps(__spreadValues({}, tolerance), {
        [atomType]: Number(value)
      }));
      setIsValid(__spreadProps(__spreadValues({}, isValid), {
        [atomType]: true
      }));
    } else {
      setIsValid(__spreadProps(__spreadValues({}, isValid), {
        [atomType]: false
      }));
    }
  }, [isValid, tolerance]);
  const rows = react.exports.useMemo(() => {
    return tolerance ? Object.keys(tolerance).map((atomType) => {
      return /* @__PURE__ */ jsxs("tr", {
        children: [/* @__PURE__ */ jsx("td", {
          children: atomType
        }), /* @__PURE__ */ jsx("td", {
          children: /* @__PURE__ */ jsx("input", {
            type: "number",
            onChange: (e2) => onChangeHandler(e2, atomType),
            defaultValue: tolerance[atomType],
            style: !isValid[atomType] ? {
              backgroundColor: "orange"
            } : {}
          })
        })]
      }, `tolerance_${atomType}`);
    }) : void 0;
  }, [isValid, onChangeHandler, tolerance]);
  return /* @__PURE__ */ jsxs("div", {
    css: modalContainer,
    children: [/* @__PURE__ */ jsxs("div", {
      className: "header handle",
      children: [/* @__PURE__ */ jsx("span", {
        children: "Set Shift Tolerances"
      }), /* @__PURE__ */ jsx(CloseButton$1, {
        onClick: onClose
      })]
    }), /* @__PURE__ */ jsxs("table", {
      children: [/* @__PURE__ */ jsx("thead", {
        children: /* @__PURE__ */ jsxs("tr", {
          children: [/* @__PURE__ */ jsx("th", {
            children: "Atom"
          }), /* @__PURE__ */ jsx("th", {
            children: "Value"
          })]
        })
      }), /* @__PURE__ */ jsx("tbody", {
        children: rows
      })]
    }), /* @__PURE__ */ jsx("button", {
      type: "button",
      onClick: onSaveHandler,
      disabled: Object.keys(isValid).some((atomType) => !isValid[atomType]),
      children: "Set"
    })]
  });
}
const panelStyle = css`
  display: flex;
  flex-direction: column;
  text-align: center;
  height: 100%;
  width: 100%;

  .extra-header-content {
    display: flex;
    width: 100%;

    .overview-container {
      width: 100%;
      display: flex;
      align-items: center;
      margin-left: 10px;
    }

    .table-view-selection {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      margin-right: 2px;

      white-space: nowrap;

      label {
        font-size: 13px;
      }
    }
  }
`;
function SummaryPanel() {
  const {
    molecules,
    correlations: correlationsData,
    data: spectraData,
    xDomain,
    yDomain,
    displayerMode,
    activeTab
  } = useChartData();
  const dispatch = useDispatch();
  const modal = useModal();
  const assignmentData = useAssignmentData();
  const [additionalColumnData, setAdditionalColumnData] = react.exports.useState([]);
  const [selectedAdditionalColumnsAtomType, setSelectedAdditionalColumnsAtomType] = react.exports.useState("H");
  const [showProtonsAsRows, setShowProtonsAsRows] = react.exports.useState(false);
  const [filterIsActive, setFilterIsActive] = react.exports.useState(false);
  const filteredCorrelationsData = react.exports.useMemo(() => {
    const isInView2 = (correlation) => {
      if (correlation.pseudo === true) {
        return false;
      }
      const atomTypesInView = activeTab.split(",").map((tab) => getAtomType(tab));
      const factor = 1e4;
      const xDomain0 = xDomain[0] * factor;
      const xDomain1 = xDomain[1] * factor;
      const yDomain0 = yDomain[0] * factor;
      const yDomain1 = yDomain[1] * factor;
      if (displayerMode === DISPLAYER_MODE.DM_1D) {
        const firstLink1D = correlation.link.find((link) => getLinkDim(link) === 1);
        if (!firstLink1D) {
          return false;
        }
        let delta = getLinkDelta(firstLink1D);
        if (delta === void 0) {
          return false;
        }
        delta *= factor;
        const spectrum = findSpectrum(spectraData, firstLink1D.experimentID, true);
        if (spectrum && atomTypesInView[0] === correlation.atomType && delta >= xDomain0 && delta <= xDomain1) {
          return true;
        }
        if (correlation.link.some((link) => {
          const spectrum2 = findSpectrum(spectraData, link.experimentID, true);
          return findSignalMatch1D(spectrum2, link, factor, xDomain0, xDomain1);
        })) {
          return true;
        }
      } else if (displayerMode === DISPLAYER_MODE.DM_2D) {
        if (!atomTypesInView.includes(correlation.atomType)) {
          return false;
        }
        const firstLink2D = correlation.link.find((link) => getLinkDim(link) === 2);
        if (!firstLink2D) {
          return false;
        }
        const spectrum = findSpectrum(spectraData, firstLink2D.experimentID, true);
        if (findSignalMatch2D(spectrum, firstLink2D, factor, xDomain0, xDomain1, yDomain0, yDomain1)) {
          return true;
        } else {
          if (correlation.link.some((link) => {
            const spectrum2 = findSpectrum(spectraData, link.experimentID, true);
            return findSignalMatch2D(spectrum2, link, factor, xDomain0, xDomain1, yDomain0, yDomain1);
          })) {
            return true;
          }
        }
      }
      return false;
    };
    if (correlationsData) {
      const _values = filterIsActive ? correlationsData.values.filter((correlation) => isInView2(correlation)) : correlationsData.values;
      return __spreadProps(__spreadValues({}, correlationsData), {
        values: _values
      });
    }
  }, [activeTab, correlationsData, displayerMode, filterIsActive, spectraData, xDomain, yDomain]);
  const handleOnSetMolecularFormula = react.exports.useCallback((mf) => {
    dispatch({
      type: SET_CORRELATIONS_MF,
      payload: {
        mf
      }
    });
  }, [dispatch]);
  const handleOnSetShiftTolerance = react.exports.useCallback((tolerance) => {
    dispatch({
      type: SET_CORRELATIONS_TOLERANCE,
      payload: {
        tolerance
      }
    });
  }, [dispatch]);
  const showSetMolecularFormulaModal = react.exports.useCallback(() => {
    modal.show(/* @__PURE__ */ jsx(SetMolecularFormulaModal, {
      onClose: () => modal.close(),
      onSave: handleOnSetMolecularFormula,
      molecules,
      previousMF: correlationsData.options.mf
    }));
  }, [correlationsData, handleOnSetMolecularFormula, modal, molecules]);
  const showSetShiftToleranceModal = react.exports.useCallback(() => {
    modal.show(/* @__PURE__ */ jsx(SetShiftToleranceModal, {
      onClose: () => modal.close(),
      onSave: handleOnSetShiftTolerance,
      previousTolerance: correlationsData.options.tolerance
    }));
  }, [correlationsData, handleOnSetShiftTolerance, modal]);
  const additionalColumnTypes = react.exports.useMemo(() => {
    const columnTypes = ["H", "H-H"].concat(correlationsData ? correlationsData.values.map((correlation) => correlation.atomType).filter((atomType, i, array2) => atomType !== "H" && array2.indexOf(atomType) === i) : []);
    return columnTypes.map((columnType) => {
      return {
        key: columnType,
        label: columnType,
        value: columnType
      };
    });
  }, [correlationsData]);
  react.exports.useEffect(() => {
    const _selectedAdditionalColumnsAtomType = selectedAdditionalColumnsAtomType.split("-")[0];
    setAdditionalColumnData(filteredCorrelationsData ? filteredCorrelationsData.values.filter((correlation) => correlation.atomType === _selectedAdditionalColumnsAtomType).reverse() : []);
  }, [filteredCorrelationsData, selectedAdditionalColumnsAtomType]);
  const editEquivalencesSaveHandler = react.exports.useCallback((correlation, value) => {
    dispatch({
      type: SET_CORRELATION,
      payload: {
        id: correlation.id,
        correlation: __spreadProps(__spreadValues({}, correlation), {
          equivalence: value,
          edited: __spreadProps(__spreadValues({}, correlation.edited), {
            equivalence: value !== 1
          })
        })
      }
    });
  }, [dispatch]);
  const editNumericValuesSaveHandler = react.exports.useCallback(({
    correlation,
    values,
    key
  }) => {
    dispatch({
      type: SET_CORRELATION,
      payload: {
        id: correlation.id,
        correlation: __spreadProps(__spreadValues({}, correlation), {
          [key]: values,
          edited: __spreadProps(__spreadValues({}, correlation.edited), {
            [key]: true
          })
        }),
        options: {
          skipDataUpdate: true
        }
      }
    });
  }, [dispatch]);
  const setCorrelationsHandler = react.exports.useCallback((correlations, options2) => {
    dispatch({
      type: SET_CORRELATIONS,
      payload: {
        correlations,
        options: options2
      }
    });
  }, [dispatch]);
  const deleteCorrelationHandler = react.exports.useCallback((correlation) => {
    dispatch({
      type: DELETE_CORRELATION,
      payload: {
        correlation,
        assignmentData
      }
    });
  }, [assignmentData, dispatch]);
  const deleteSignalHandler = react.exports.useCallback((link) => {
    const linkDim = getLinkDim(link);
    if (linkDim === 1) {
      const spectrum = findSpectrum(spectraData, link.experimentID, false);
      const range2 = findRange(spectrum, link.signal.id);
      const signal = findSignal1D(spectrum, link.signal.id);
      dispatch({
        type: DELETE_1D_SIGNAL,
        payload: {
          spectrum,
          range: range2,
          signal,
          assignmentData
        }
      });
    } else if (linkDim === 2) {
      const spectrum = findSpectrum(spectraData, link.experimentID, false);
      const zone = findZone(spectrum, link.signal.id);
      const signal = findSignal2D(spectrum, link.signal.id);
      dispatch({
        type: DELETE_2D_SIGNAL,
        payload: {
          spectrum,
          zone,
          signal,
          assignmentData
        }
      });
    }
  }, [assignmentData, dispatch, spectraData]);
  const changeSignalPathLengthHandler = react.exports.useCallback((link) => {
    var _a;
    const linkDim = getLinkDim(link);
    if (linkDim === 2) {
      const spectrum = findSpectrum(spectraData, link.experimentID, false);
      const zone = findZone(spectrum, link.signal.id);
      const signal = findSignal2D(spectrum, link.signal.id);
      dispatch({
        type: SET_2D_SIGNAL_PATH_LENGTH,
        payload: {
          spectrum,
          zone,
          signal,
          pathLength: (_a = link.signal.j) == null ? void 0 : _a.pathLength
        }
      });
    }
  }, [dispatch, spectraData]);
  const editCorrelationTableCellHandler = react.exports.useCallback((editedCorrelations, action, link, options2) => {
    if (action === "add" || action === "move" || action === "remove" || action === "unmove" || action === "setPathLength") {
      if (link && link.pseudo === false) {
        if (action === "remove") {
          deleteSignalHandler(link);
        } else if (action === "setPathLength") {
          changeSignalPathLengthHandler(link);
        }
      }
      setCorrelationsHandler(editedCorrelations, options2);
    } else if (action === "removeAll") {
      deleteCorrelationHandler(editedCorrelations[0]);
    }
  }, [changeSignalPathLengthHandler, deleteCorrelationHandler, deleteSignalHandler, setCorrelationsHandler]);
  const handleOnFilter = react.exports.useCallback(() => {
    setFilterIsActive(!filterIsActive);
  }, [filterIsActive]);
  return /* @__PURE__ */ jsxs("div", {
    css: panelStyle,
    children: [/* @__PURE__ */ jsxs(DefaultPanelHeader$1, {
      canDelete: false,
      counter: correlationsData ? correlationsData.values.length : 0,
      onFilter: handleOnFilter,
      filterToolTip: filterIsActive ? "Show all correlations" : "Hide correlations out of view",
      filterIsActive,
      counterFiltered: filteredCorrelationsData == null ? void 0 : filteredCorrelationsData.values.length,
      children: [/* @__PURE__ */ jsx(ToolTip$1, {
        title: `Set molecular formula (${correlationsData.options.mf})`,
        popupPlacement: "right",
        children: /* @__PURE__ */ jsx("button", {
          type: "button",
          onClick: showSetMolecularFormulaModal,
          children: /* @__PURE__ */ jsx(FaFlask, {})
        })
      }), /* @__PURE__ */ jsx(ToolTip$1, {
        title: `Set shift tolerance`,
        popupPlacement: "right",
        children: /* @__PURE__ */ jsx("button", {
          type: "button",
          onClick: showSetShiftToleranceModal,
          children: /* @__PURE__ */ jsx(FaSlidersH, {})
        })
      }), /* @__PURE__ */ jsxs("div", {
        className: "extra-header-content",
        children: [/* @__PURE__ */ jsx("div", {
          className: "overview-container",
          children: /* @__PURE__ */ jsx(Overview$1, {
            correlationsData
          })
        }), /* @__PURE__ */ jsx("div", {
          className: "table-view-selection",
          children: /* @__PURE__ */ jsxs("span", {
            children: [/* @__PURE__ */ jsx("label", {
              children: "View:"
            }), /* @__PURE__ */ jsx(Select, {
              onChange: (selection) => {
                setSelectedAdditionalColumnsAtomType(selection);
                if (selection === "H-H") {
                  setShowProtonsAsRows(true);
                } else {
                  setShowProtonsAsRows(false);
                }
              },
              data: additionalColumnTypes,
              defaultValue: selectedAdditionalColumnsAtomType,
              style: {
                fontSize: "12px",
                width: "70px",
                height: "18px",
                border: "1px solid grey"
              }
            })]
          })
        })]
      })]
    }), /* @__PURE__ */ jsx(CorrelationTable, {
      correlationsData,
      filteredCorrelationsData,
      additionalColumnData,
      editEquivalencesSaveHandler,
      onSaveEditNumericValues: editNumericValuesSaveHandler,
      onEditCorrelationTableCellHandler: editCorrelationTableCellHandler,
      showProtonsAsRows,
      spectraData
    })]
  });
}
var SummaryPanel$1 = react.exports.memo(SummaryPanel);
const styles$m = {
  container: {
    padding: 10,
    backgroundColor: "#f1f1f1",
    height: "100%",
    overflowY: "auto"
  },
  groupContainer: {
    padding: "5px",
    borderRadius: "5px",
    margin: "10px 0px",
    backgroundColor: "white"
  },
  row: {
    display: "flex",
    margin: "5px 0px"
  },
  header: {
    borderBottom: "1px solid #e8e8e8",
    paddingBottom: "5px",
    fontWeight: "bold",
    color: "#4a4a4a"
  },
  inputLabel: {
    flex: 2,
    fontSize: "11px",
    fontWeight: "bold",
    color: "#232323"
  },
  input: {
    width: "30%",
    textAlign: "center"
  }
};
const formatFields = [{
  id: 1,
  label: "From :",
  checkController: "showFrom",
  formatController: "fromFormat"
}, {
  id: 2,
  label: "To :",
  checkController: "showTo",
  formatController: "toFormat"
}, {
  id: 3,
  label: "Absolute :",
  checkController: "showAbsolute",
  formatController: "absoluteFormat"
}, {
  id: 4,
  label: "Relative :",
  checkController: "showRelative",
  formatController: "relativeFormat"
}];
function ZonesPreferencesInner({
  nucleus,
  innerRef
}) {
  const alert2 = useAlert();
  const preferences = usePreferences();
  const formRef = react.exports.useRef();
  const updateValues = react.exports.useCallback(() => {
    if (nucleus) {
      const defaultValues = nucleus.reduce((acc, nucleusLabel) => {
        acc[nucleusLabel] = zoneDefaultValues;
        return acc;
      }, {});
      const zonesPreferences = getValue(preferences.current, `formatting.panels.zones`);
      formRef.current.setValues(zonesPreferences ? zonesPreferences : defaultValues);
    }
  }, [nucleus, preferences]);
  react.exports.useEffect(() => {
    updateValues();
  }, [updateValues]);
  const saveHandler = react.exports.useCallback((values) => {
    preferences.dispatch({
      type: "SET_PANELS_PREFERENCES",
      payload: {
        key: "zones",
        value: values
      }
    });
    alert2.success("zones preferences saved successfully");
  }, [alert2, preferences]);
  react.exports.useImperativeHandle(innerRef, () => ({
    saveSetting: () => {
      formRef.current.submitForm();
    }
  }), []);
  return /* @__PURE__ */ jsx$1("div", {
    style: styles$m.container,
    children: /* @__PURE__ */ jsx$1(FormikForm, {
      onSubmit: saveHandler,
      ref: formRef,
      children: nucleus == null ? void 0 : nucleus.map((nucleusLabel) => /* @__PURE__ */ jsxs$1("div", {
        style: styles$m.groupContainer,
        children: [/* @__PURE__ */ jsx$1(IsotopesViewer, {
          style: styles$m.header,
          value: nucleusLabel
        }), formatFields.map((field) => /* @__PURE__ */ jsx$1(FormikColumnFormatField$1, {
          label: field.label,
          checkControllerName: `${nucleusLabel}.${field.checkController}`,
          formatControllerName: `${nucleusLabel}.${field.formatController}`
        }, field.id))]
      }, nucleusLabel))
    })
  });
}
const MemoizedZonesPreferences = react.exports.memo(ZonesPreferencesInner);
function ZonesPreferences(props, ref) {
  const nucleus = useNucleus();
  return /* @__PURE__ */ jsx$1(MemoizedZonesPreferences, {
    innerRef: ref,
    nucleus
  });
}
var ZonesPreferences$1 = react.exports.forwardRef(ZonesPreferences);
const editPathLengthsStyles = css`
  width: 100%;
  height: 100%;
  margin-top: 10px;
  text-align: center;

  .input-container {
    width: 100%;
    margin-top: 5px;
    text-align: center;

    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;

    input::-webkit-outer-spin-button,
    input::-webkit-inner-spin-button {
      -webkit-appearance: none;
    }
  }

  button {
    flex: 2;
    padding: 5px;
    border: 1px solid gray;
    border-radius: 5px;
    height: 30px;
    margin: 0 auto;
    margin-top: 15px;
    display: block;
    width: 60px;

    color: white;
    background-color: gray;
  }

  .warning {
    margin-top: 5px;
    color: red;
  }
`;
function EditPathLengthFormik({
  signalIndex
}) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
  const {
    errors,
    values
  } = useFormikContext();
  return /* @__PURE__ */ jsxs("div", {
    css: editPathLengthsStyles,
    children: [/* @__PURE__ */ jsx("p", {
      children: "Setting of the minimum and maximum path length (J coupling)."
    }), /* @__PURE__ */ jsxs("div", {
      className: "input-container",
      children: [/* @__PURE__ */ jsx(FormikNumberInput, {
        name: `signals[${signalIndex}].j.pathLength.from`,
        defaultValue: ((_b = (_a = values.signals[signalIndex].j) == null ? void 0 : _a.pathLength) == null ? void 0 : _b.from) || ((_c = DefaultPathLengths[values.experimentType]) == null ? void 0 : _c.from) || 1,
        label: "Min: ",
        style: {
          input: {
            color: ((_f = (_e = (_d = errors.signals) == null ? void 0 : _d[signalIndex].j) == null ? void 0 : _e.pathLength) == null ? void 0 : _f.from) ? "red" : "black"
          }
        },
        min: 1,
        max: ((_h = (_g = values.signals[signalIndex].j) == null ? void 0 : _g.pathLength) == null ? void 0 : _h.to) || ((_i = DefaultPathLengths[values.experimentType]) == null ? void 0 : _i.to),
        pattern: "[1-9]+"
      }), /* @__PURE__ */ jsx(FormikNumberInput, {
        name: `signals[${signalIndex}].j.pathLength.to`,
        defaultValue: ((_k = (_j = values.signals[signalIndex].j) == null ? void 0 : _j.pathLength) == null ? void 0 : _k.to) || ((_l = DefaultPathLengths[values.experimentType]) == null ? void 0 : _l.to) || 1,
        label: "Max: ",
        style: {
          input: {
            color: ((_o = (_n = (_m = errors.signals) == null ? void 0 : _m[signalIndex].j) == null ? void 0 : _n.pathLength) == null ? void 0 : _o.to) ? "red" : "black"
          }
        },
        min: ((_q = (_p = values.signals[signalIndex].j) == null ? void 0 : _p.pathLength) == null ? void 0 : _q.from) || ((_r = DefaultPathLengths[values.experimentType]) == null ? void 0 : _r.from) || 1,
        pattern: "[1-9]+"
      })]
    })]
  });
}
function SignalFormTab({
  signalIndex
}) {
  return /* @__PURE__ */ jsx$1(EditPathLengthFormik, {
    signalIndex
  });
}
const textStyles = css`
  text-align: center;
  width: 100%;

  .errorText {
    color: red;
  }

  .infoText {
    padding: 10px;
    margin: 10px 0;
    font-size: 14px;
    text-align: left;
    color: white;
    background-color: #5f5f5f;
    border-radius: 5px;
  }
`;
const tabStylesAddition = css`
  color: red;
`;
const tabStyles = css`
  display: inline-grid;
  list-style: none;
  padding: 0.5rem 1.5rem;
`;
function SignalsForm() {
  const {
    values,
    setFieldValue,
    errors
  } = useFormikContext();
  const tabContainsErrors = react.exports.useCallback((i) => {
    return (errors == null ? void 0 : errors.signals) && (errors == null ? void 0 : errors.signals[i]) ? true : false;
  }, [errors]);
  const signalFormTabs = react.exports.useMemo(() => {
    const signalTabs = values.signals.length > 0 ? values.signals.map((signal, i) => /* @__PURE__ */ jsx(Tab, {
      tabid: `${i}`,
      tabstyles: tabContainsErrors(i) ? tabStylesAddition : tabStyles,
      render: () => /* @__PURE__ */ jsxs("div", {
        style: {
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          fontSize: "11px"
        },
        children: [/* @__PURE__ */ jsxs("span", {
          children: ["\u{1D6C5}", /* @__PURE__ */ jsx("sub", {
            children: signal.x.nucleus
          }), ": ", signal.x.delta.toFixed(2)]
        }), /* @__PURE__ */ jsxs("span", {
          children: ["\u{1D6C5}", /* @__PURE__ */ jsx("sub", {
            children: signal.y.nucleus
          }), ": ", signal.y.delta.toFixed(2)]
        })]
      }),
      children: /* @__PURE__ */ jsx(SignalFormTab, {
        signalIndex: i
      })
    }, `signalForm_zone${i}`)) : [];
    return signalTabs;
  }, [tabContainsErrors, values.signals]);
  const tapClickHandler = react.exports.useCallback(({
    tabid
  }) => {
    setFieldValue("activeTab", tabid);
  }, [setFieldValue]);
  const handleDeleteSignal2 = react.exports.useCallback(({
    tabid
  }) => {
    const _signals = values.signals.filter((_signal, i) => i !== Number(tabid));
    setFieldValue("signals", _signals);
  }, [setFieldValue, values.signals]);
  return /* @__PURE__ */ jsxs("div", {
    children: [/* @__PURE__ */ jsx("div", {
      css: textStyles
    }), /* @__PURE__ */ jsx(Tabs$1, {
      activeTab: values.activeTab,
      onClick: tapClickHandler,
      onDelete: handleDeleteSignal2,
      children: signalFormTabs
    })]
  });
}
const useValidation = () => react.exports.useMemo(() => {
  return create().shape({
    signals: create$4().of(create().shape({
      j: create().shape({
        pathLength: create().shape({
          from: create$1().required().positive().integer(),
          to: create$1().required().positive().integer()
        })
      })
    })).min(1, "There must be at least one signal in a zone!")
  });
}, []);
const styles$l = css`
  width: 500px;
  height: 250px;
  padding: 5px;
  button:focus {
    outline: none;
  }
  .header {
    height: 24px;
    border-bottom: 1px solid #f0f0f0;
    display: flex;
    align-items: center;
    span {
      color: #464646;
      font-size: 15px;
      flex: 1;
      border-left: 1px solid #ececec;
      padding-left: 6px;
    }

    button {
      background-color: transparent;
      border: none;
      padding: 5px;

      svg {
        height: 16px;
      }
    }
  }
  .container {
    display: flex;
    margin: 30px 5px;
  }
`;
function EditZoneModal({
  onSaveEditZoneModal = () => null,
  onCloseEditZoneModal = () => null,
  onZoomEditZoneModal = () => null,
  rowData
}) {
  const formRef = react.exports.useRef(null);
  const validation2 = useValidation();
  const handleOnZoom = react.exports.useCallback(() => {
    onZoomEditZoneModal(rowData);
  }, [onZoomEditZoneModal, rowData]);
  react.exports.useEffect(() => {
    handleOnZoom();
  }, [handleOnZoom]);
  const handleOnClose = react.exports.useCallback(() => {
    onCloseEditZoneModal();
  }, [onCloseEditZoneModal]);
  const handleOnSave = react.exports.useCallback((formValues) => {
    void (async () => {
      const _rowData = __spreadProps(__spreadValues({}, rowData), {
        signals: formValues.signals.map((signal) => {
          var _a, _b;
          if (isDefaultPathLength((_a = signal.j) == null ? void 0 : _a.pathLength, rowData.tableMetaInfo.experiment)) {
            (_b = signal.j) == null ? true : delete _b.pathLength;
            if (signal.j && Object.keys(signal.j).length === 0) {
              delete signal.j;
            }
          }
          return signal;
        })
      });
      await onSaveEditZoneModal(_rowData);
      handleOnClose();
    })();
  }, [handleOnClose, onSaveEditZoneModal, rowData]);
  const data = react.exports.useMemo(() => {
    return {
      activeTab: "0",
      signals: rowData.signals.map((signal) => {
        var _a, _b;
        return __spreadProps(__spreadValues({}, signal), {
          j: __spreadValues({
            pathLength: {
              from: ((_a = DefaultPathLengths[rowData.tableMetaInfo.experiment]) == null ? void 0 : _a.from) || 1,
              to: ((_b = DefaultPathLengths[rowData.tableMetaInfo.experiment]) == null ? void 0 : _b.to) || 1
            }
          }, signal.j)
        });
      })
    };
  }, [rowData.signals, rowData.tableMetaInfo.experiment]);
  return /* @__PURE__ */ jsx("div", {
    css: styles$l,
    children: /* @__PURE__ */ jsxs(FormikForm, {
      ref: formRef,
      initialValues: data,
      validationSchema: validation2,
      onSubmit: handleOnSave,
      children: [/* @__PURE__ */ jsxs("div", {
        className: "header handle",
        children: [/* @__PURE__ */ jsx(Button, {
          onClick: handleOnZoom,
          className: "zoom-button",
          children: /* @__PURE__ */ jsx(FaSearchPlus, {
            title: "Set to default view on range in spectrum"
          })
        }), /* @__PURE__ */ jsx("span", {
          children: `Zone and Signal edition`
        }), /* @__PURE__ */ jsx(SaveButton$1, {
          onClick: () => formRef.current.submitForm(),
          popupTitle: "Save and exit"
        }), /* @__PURE__ */ jsx(CloseButton$1, {
          onClick: handleOnClose
        })]
      }), /* @__PURE__ */ jsx(SignalsForm, {})]
    })
  });
}
const selectBoxStyle = {
  marginLeft: 2,
  marginRight: 2,
  border: "none",
  height: "20px"
};
function ActionsColumn({
  rowData,
  rowSpanTags
}) {
  const dispatch = useDispatch();
  const assignmentData = useAssignmentData();
  const modal = useModal();
  const changeSignalKindHandler = react.exports.useCallback((value) => {
    dispatch({
      type: CHANGE_ZONE_SIGNAL_KIND,
      payload: {
        rowData,
        value
      }
    });
  }, [dispatch, rowData]);
  const deleteZoneHandler = react.exports.useCallback(() => {
    dispatch({
      type: DELETE_2D_ZONE,
      payload: {
        id: rowData.id,
        assignmentData
      }
    });
  }, [assignmentData, dispatch, rowData]);
  const zoomZoneHandler = react.exports.useCallback(() => {
    const xMargin = Math.abs(rowData.x.from - rowData.x.to) * 10;
    dispatch({
      type: SET_X_DOMAIN,
      xDomain: rowData.x.from <= rowData.x.to ? [rowData.x.from - xMargin, rowData.x.to + xMargin] : [rowData.x.to - xMargin, rowData.x.from + xMargin]
    });
    const yMargin = Math.abs(rowData.y.from - rowData.y.to) * 10;
    dispatch({
      type: SET_Y_DOMAIN,
      yDomain: rowData.y.from <= rowData.y.to ? [rowData.y.from - yMargin, rowData.y.to + yMargin] : [rowData.y.to - yMargin, rowData.y.from + yMargin]
    });
  }, [dispatch, rowData.x.from, rowData.x.to, rowData.y.from, rowData.y.to]);
  const saveEditZoneHandler = react.exports.useCallback((editedRowData) => {
    dispatch({
      type: SAVE_EDITED_ZONE,
      payload: {
        editedRowData
      }
    });
  }, [dispatch]);
  const openEditZoneHandler = react.exports.useCallback(() => {
    dispatch({
      type: SET_SELECTED_TOOL,
      payload: {
        selectedTool: options.editRange.id,
        tempRange: rowData
      }
    });
    modal.show(/* @__PURE__ */ jsx$1(EditZoneModal, {
      onCloseEditZoneModal: () => modal.close(),
      onSaveEditZoneModal: saveEditZoneHandler,
      onZoomEditZoneModal: () => zoomZoneHandler(),
      rowData
    }), {
      position: positions.MIDDLE_RIGHT,
      transition: transitions.SCALE,
      isBackgroundBlur: false
    });
  }, [dispatch, modal, rowData, saveEditZoneHandler, zoomZoneHandler]);
  return /* @__PURE__ */ jsxs$1(react.exports.Fragment, {
    children: [/* @__PURE__ */ jsx$1("td", {
      children: /* @__PURE__ */ jsx$1(Select, {
        onChange: (value) => {
          changeSignalKindHandler(value);
        },
        data: SignalKinds,
        defaultValue: rowData.tableMetaInfo.signal.kind,
        style: selectBoxStyle
      })
    }), /* @__PURE__ */ jsxs$1("td", __spreadProps(__spreadValues({}, rowSpanTags), {
      children: [/* @__PURE__ */ jsx$1("button", {
        type: "button",
        className: "delete-button",
        onClick: deleteZoneHandler,
        children: /* @__PURE__ */ jsx$1(FaRegTrashAlt, {})
      }), /* @__PURE__ */ jsx$1("button", {
        type: "button",
        className: "zoom-button",
        onClick: zoomZoneHandler,
        children: /* @__PURE__ */ jsx$1(FaSearchPlus, {
          title: "Zoom to zone in spectrum"
        })
      }), /* @__PURE__ */ jsx$1("button", {
        type: "button",
        className: "edit-button",
        onClick: openEditZoneHandler,
        children: /* @__PURE__ */ jsx$1(FaEdit, {
          color: "blue"
        })
      })]
    }))]
  });
}
function SignalAssignmentsColumn({
  rowData,
  assignment,
  highlight,
  onHover,
  onClick,
  onUnlink,
  axis,
  showUnlinkButton,
  setShowUnlinkButton
}) {
  var _a, _b;
  return /* @__PURE__ */ jsx$1("td", __spreadProps(__spreadValues({}, onHover), {
    onClick: (e2) => onClick(e2, assignment, axis),
    style: highlight.isActive || assignment.isActive && ((_a = assignment.activated) == null ? void 0 : _a.axis) === axis ? {
      color: "red",
      fontWeight: "bold"
    } : void 0,
    children: get_1(rowData, `tableMetaInfo.signal.${axis}.diaIDs`, []).length > 0 ? /* @__PURE__ */ jsxs$1("div", {
      onMouseEnter: () => setShowUnlinkButton(true),
      onMouseLeave: () => setShowUnlinkButton(false),
      children: [rowData.tableMetaInfo.signal[axis].diaIDs.length, " ", /* @__PURE__ */ jsx$1("sup", {
        children: /* @__PURE__ */ jsx$1("button", {
          type: "button",
          style: {
            visibility: showUnlinkButton ? "visible" : "hidden",
            padding: 0,
            margin: 0
          },
          onClick: (e2) => onUnlink(e2, false, axis),
          children: /* @__PURE__ */ jsx$1(FaMinusCircle, {
            color: "red"
          })
        })
      })]
    }) : assignment.isActive && ((_b = assignment.activated) == null ? void 0 : _b.axis) === axis ? "0" : ""
  }));
}
function SignalAssignmentsColumns({
  rowData,
  assignmentSignal,
  onHoverSignalX,
  onHoverSignalY,
  showUnlinkButtonSignalX,
  showUnlinkButtonSignalY,
  setShowUnlinkButtonSignalX,
  setShowUnlinkButtonSignalY,
  onClick,
  onUnlink,
  highlightSignalX,
  highlightSignalY
}) {
  return /* @__PURE__ */ jsxs$1(react.exports.Fragment, {
    children: [/* @__PURE__ */ jsx$1(SignalAssignmentsColumn, {
      rowData,
      assignment: assignmentSignal,
      highlight: highlightSignalX,
      onHover: onHoverSignalX,
      onClick,
      onUnlink,
      axis: "x",
      showUnlinkButton: showUnlinkButtonSignalX,
      setShowUnlinkButton: setShowUnlinkButtonSignalX
    }), /* @__PURE__ */ jsx$1(SignalAssignmentsColumn, {
      rowData,
      assignment: assignmentSignal,
      highlight: highlightSignalY,
      onHover: onHoverSignalY,
      onClick,
      onUnlink,
      axis: "y",
      showUnlinkButton: showUnlinkButtonSignalY,
      setShowUnlinkButton: setShowUnlinkButtonSignalY
    })]
  });
}
function SignalDeltaColumn({
  rowData,
  onHoverSignalX,
  onHoverSignalY
}) {
  const dispatch = useDispatch();
  const signalDeltaX = get_1(rowData, "tableMetaInfo.signal.x.delta", null);
  const signalDeltaY = get_1(rowData, "tableMetaInfo.signal.y.delta", null);
  const id2 = get_1(rowData, "tableMetaInfo.signal.id", void 0);
  const saveXHandler = react.exports.useCallback((event) => {
    const value = event.target.value;
    dispatch({
      type: CHANGE_ZONE_SIGNAL_VALUE,
      payload: {
        zoneID: rowData.id,
        signal: {
          id: id2,
          x: value
        }
      }
    });
  }, [dispatch, id2, rowData.id]);
  const saveYHandler = react.exports.useCallback((event) => {
    const value = event.target.value;
    dispatch({
      type: CHANGE_ZONE_SIGNAL_VALUE,
      payload: {
        zoneID: rowData.id,
        signal: {
          id: id2,
          y: value
        }
      }
    });
  }, [dispatch, id2, rowData.id]);
  return /* @__PURE__ */ jsxs$1(react.exports.Fragment, {
    children: [/* @__PURE__ */ jsx$1("td", __spreadProps(__spreadValues({}, onHoverSignalX), {
      children: signalDeltaX !== null ? /* @__PURE__ */ jsx$1(EditableColumn$1, {
        value: signalDeltaX.toFixed(2),
        onSave: saveXHandler,
        type: "number",
        style: {
          padding: "0.1rem 0.4rem"
        }
      }) : ""
    })), /* @__PURE__ */ jsx$1("td", __spreadProps(__spreadValues({}, onHoverSignalY), {
      children: signalDeltaY !== null ? /* @__PURE__ */ jsx$1(EditableColumn$1, {
        value: signalDeltaY.toFixed(2),
        onSave: saveYHandler,
        type: "number",
        style: {
          padding: "0.1rem 0.4rem"
        }
      }) : ""
    }))]
  });
}
function ZoneAssignmentColumn({
  rowData,
  assignment,
  highlight,
  onHover,
  onClick,
  onUnlink,
  axis,
  showUnlinkButton,
  setShowUnlinkButton,
  rowSpanTags
}) {
  var _a, _b, _c, _d;
  return /* @__PURE__ */ jsx$1("td", __spreadProps(__spreadValues(__spreadValues({}, rowSpanTags), onHover), {
    onClick: (e2) => onClick(e2, assignment, axis),
    children: get_1(rowData, `${axis}.nbAtoms`, 0) > 0 ? get_1(rowData, `${axis}.diaIDs`, 0).length > 0 ? /* @__PURE__ */ jsxs$1("div", {
      onMouseEnter: () => setShowUnlinkButton(true),
      onMouseLeave: () => setShowUnlinkButton(false),
      children: [rowData[axis].nbAtoms, " ", `(`, /* @__PURE__ */ jsx$1("span", {
        style: assignment.isActive && ((_a = assignment.activated) == null ? void 0 : _a.axis) === axis || assignment.isOver && ((_b = assignment.highlighted) == null ? void 0 : _b.axis) === axis || highlight.isActive ? {
          color: "red",
          fontWeight: "bold"
        } : {
          color: "black",
          fontWeight: "normal"
        },
        children: get_1(rowData, `${axis}.diaIDs`, []).length
      }), `)`, " ", /* @__PURE__ */ jsx$1("sup", {
        children: /* @__PURE__ */ jsx$1("button", {
          type: "button",
          style: {
            visibility: showUnlinkButton ? "visible" : "hidden",
            padding: 0,
            margin: 0
          },
          onClick: (e2) => onUnlink(e2, true, axis),
          children: /* @__PURE__ */ jsx$1(FaMinusCircle, {
            color: "red"
          })
        })
      })]
    }) : assignment.isActive && ((_c = assignment.activated) == null ? void 0 : _c.axis) === axis ? /* @__PURE__ */ jsxs$1("div", {
      children: [`${get_1(rowData, `${axis}.nbAtoms`, "")} (`, /* @__PURE__ */ jsx$1("span", {
        style: {
          color: "red",
          fontWeight: "bold"
        },
        children: "0"
      }), ")"]
    }) : rowData[axis].nbAtoms : assignment.isActive && ((_d = assignment.activated) == null ? void 0 : _d.axis) === axis ? /* @__PURE__ */ jsxs$1("div", {
      children: ["0 (", /* @__PURE__ */ jsx$1("span", {
        style: {
          color: "red",
          fontWeight: "bold"
        },
        children: "0"
      }), ")"]
    }) : ""
  }));
}
function ZoneAssignmentsColumns({
  rowData,
  assignmentZone,
  onHoverZoneX,
  onHoverZoneY,
  showUnlinkButtonZoneX,
  showUnlinkButtonZoneY,
  setShowUnlinkButtonZoneX,
  setShowUnlinkButtonZoneY,
  rowSpanTags,
  onClick,
  onUnlink,
  highlightZoneX,
  highlightZoneY
}) {
  return /* @__PURE__ */ jsxs$1(react.exports.Fragment, {
    children: [/* @__PURE__ */ jsx$1(ZoneAssignmentColumn, {
      rowData,
      assignment: assignmentZone,
      highlight: highlightZoneX,
      onHover: onHoverZoneX,
      onClick,
      onUnlink,
      axis: "x",
      showUnlinkButton: showUnlinkButtonZoneX,
      setShowUnlinkButton: setShowUnlinkButtonZoneX,
      rowSpanTags
    }), /* @__PURE__ */ jsx$1(ZoneAssignmentColumn, {
      rowData,
      assignment: assignmentZone,
      highlight: highlightZoneY,
      onHover: onHoverZoneY,
      onClick,
      onUnlink,
      axis: "y",
      showUnlinkButton: showUnlinkButtonZoneY,
      setShowUnlinkButton: setShowUnlinkButtonZoneY,
      rowSpanTags
    })]
  });
}
const HighlightedRowStyle = {
  backgroundColor: "#ff6f0057"
};
const ConstantlyHighlightedRowStyle = {
  backgroundColor: "#f5f5dc"
};
function ZonesTableRow({
  rowData,
  onUnlink,
  onContextMenu,
  rowIndex
}) {
  var _a, _b, _c, _d;
  const assignmentZone = useAssignment(rowData.id);
  const highlightZone = useHighlight([assignmentZone.id]);
  const highlightZoneX = useHighlight([buildID(assignmentZone.id, "X")].concat(((_a = assignmentZone.assigned) == null ? void 0 : _a.x) || []));
  const highlightZoneY = useHighlight([buildID(assignmentZone.id, "Y")].concat(((_b = assignmentZone.assigned) == null ? void 0 : _b.y) || []));
  const assignmentSignal = useAssignment(rowData.tableMetaInfo.id);
  const highlightSignalX = useHighlight([buildID(assignmentSignal.id, "X")].concat(((_c = assignmentSignal.assigned) == null ? void 0 : _c.x) || [], buildID(assignmentSignal.id, "Crosshair")));
  const highlightSignalY = useHighlight([buildID(assignmentSignal.id, "Y")].concat(((_d = assignmentSignal.assigned) == null ? void 0 : _d.y) || [], buildID(assignmentSignal.id, "Crosshair")));
  const [showUnlinkButtonZoneX, setShowUnlinkButtonZoneX] = react.exports.useState(false);
  const [showUnlinkButtonZoneY, setShowUnlinkButtonZoneY] = react.exports.useState(false);
  const [showUnlinkButtonSignalX, setShowUnlinkButtonSignalX] = react.exports.useState(false);
  const [showUnlinkButtonSignalY, setShowUnlinkButtonSignalY] = react.exports.useState(false);
  const rowSpanTags = react.exports.useMemo(() => {
    return {
      rowSpan: rowData.tableMetaInfo.rowSpan,
      style: get_1(rowData, "tableMetaInfo.hide", false) === true ? {
        display: "none"
      } : null
    };
  }, [rowData]);
  const unlinkHandler = react.exports.useCallback((event, isOnZoneLevel, axis) => {
    if (event) {
      event.stopPropagation();
    }
    onUnlink(rowData, isOnZoneLevel, rowData.tableMetaInfo.signalIndex, axis);
    if (axis === "x") {
      if (isOnZoneLevel !== void 0) {
        if (isOnZoneLevel) {
          setShowUnlinkButtonZoneX(false);
          assignmentZone.removeAll("x");
        } else {
          setShowUnlinkButtonSignalX(false);
          assignmentSignal.removeAll("x");
        }
      } else {
        setShowUnlinkButtonZoneX(false);
        setShowUnlinkButtonSignalX(false);
      }
    } else if (axis === "y") {
      if (isOnZoneLevel !== void 0) {
        if (isOnZoneLevel) {
          setShowUnlinkButtonZoneY(false);
          assignmentZone.removeAll("y");
        } else {
          setShowUnlinkButtonSignalY(false);
          assignmentSignal.removeAll("y");
        }
      } else {
        setShowUnlinkButtonZoneY(false);
        setShowUnlinkButtonSignalY(false);
      }
    } else {
      setShowUnlinkButtonZoneX(false);
      assignmentZone.removeAll("x");
      setShowUnlinkButtonSignalX(false);
      assignmentSignal.removeAll("x");
      setShowUnlinkButtonZoneY(false);
      assignmentZone.removeAll("y");
      setShowUnlinkButtonSignalY(false);
      assignmentSignal.removeAll("y");
    }
  }, [assignmentSignal, assignmentZone, onUnlink, rowData]);
  const clickHandler = react.exports.useCallback((event, assignment, axis) => {
    event.stopPropagation();
    assignment.setActive(axis);
  }, []);
  const onHoverZoneX = react.exports.useMemo(() => {
    return {
      onMouseEnter: () => {
        assignmentZone.show("x");
        highlightZoneX.show();
      },
      onMouseLeave: () => {
        assignmentZone.hide();
        highlightZoneX.hide();
      }
    };
  }, [assignmentZone, highlightZoneX]);
  const onHoverZoneY = react.exports.useMemo(() => {
    return {
      onMouseEnter: () => {
        assignmentZone.show("y");
        highlightZoneY.show();
      },
      onMouseLeave: () => {
        assignmentZone.hide();
        highlightZoneY.hide();
      }
    };
  }, [assignmentZone, highlightZoneY]);
  const onHoverSignalX = react.exports.useMemo(() => {
    return {
      onMouseEnter: () => {
        assignmentSignal.show("x");
        highlightSignalX.show();
      },
      onMouseLeave: () => {
        assignmentSignal.hide();
        highlightSignalX.hide();
      }
    };
  }, [assignmentSignal, highlightSignalX]);
  const onHoverSignalY = react.exports.useMemo(() => {
    return {
      onMouseEnter: () => {
        assignmentSignal.show("y");
        highlightSignalY.show();
      },
      onMouseLeave: () => {
        assignmentSignal.hide();
        highlightSignalY.hide();
      }
    };
  }, [assignmentSignal, highlightSignalY]);
  return /* @__PURE__ */ jsxs("tr", __spreadProps(__spreadValues({
    onContextMenu: (e2) => onContextMenu(e2, rowData),
    style: highlightZone.isActive || assignmentZone.isActive ? HighlightedRowStyle : get_1(rowData, "tableMetaInfo.isConstantlyHighlighted", false) === true ? ConstantlyHighlightedRowStyle : null
  }, highlightZone.onHover), {
    children: [/* @__PURE__ */ jsx("td", __spreadProps(__spreadValues({}, rowSpanTags), {
      children: rowIndex + 1
    })), /* @__PURE__ */ jsx(SignalDeltaColumn, {
      rowData,
      onHoverSignalX,
      onHoverSignalY
    }), /* @__PURE__ */ jsx(SignalAssignmentsColumns, {
      rowData,
      assignmentSignal,
      onHoverSignalX,
      onHoverSignalY,
      showUnlinkButtonSignalX,
      showUnlinkButtonSignalY,
      setShowUnlinkButtonSignalX: (show) => setShowUnlinkButtonSignalX(show),
      setShowUnlinkButtonSignalY: (show) => setShowUnlinkButtonSignalY(show),
      onClick: clickHandler,
      onUnlink: unlinkHandler,
      highlightSignalX,
      highlightSignalY
    }), /* @__PURE__ */ jsx(ZoneAssignmentsColumns, {
      rowData,
      assignmentZone,
      onHoverZoneX,
      onHoverZoneY,
      showUnlinkButtonZoneX,
      showUnlinkButtonZoneY,
      setShowUnlinkButtonZoneX: (show) => setShowUnlinkButtonZoneX(show),
      setShowUnlinkButtonZoneY: (show) => setShowUnlinkButtonZoneY(show),
      rowSpanTags,
      onClick: clickHandler,
      onUnlink: unlinkHandler,
      highlightZoneX,
      highlightZoneY
    }), /* @__PURE__ */ jsx(ActionsColumn, {
      rowData,
      rowSpanTags
    })]
  }));
}
const tableStyle = css`
  border-spacing: 0;
  border: 1px solid #dedede;
  width: 100%;
  font-size: 12px;
  .react-contextmenu-wrapper {
    display: contents;
  }
  tr {
    :last-child {
      td {
        border-bottom: 0;
      }
    }
  }
  thead tr:nth-of-type(1) th {
    top: 0;
  }
  thead tr:nth-of-type(2) th {
    top: 21px;
  }
  th {
    position: sticky;
    background-color: white;
    z-index: 2;
  }
  th,
  td {
    white-space: nowrap;
    text-align: center;
    margin: 0;
    padding: 0.1rem 0.4rem;
    border-bottom: 1px solid #dedede;
    border-right: 1px solid #dedede;

    :last-child {
      border-right: 0;
    }
    button {
      background-color: transparent;
      border: none;
      padding: 0 5px;
    }
  }
`;
function ZonesTable({
  tableData,
  onUnlink,
  context,
  nuclei,
  experiment
}) {
  const contextRef = react.exports.useRef(null);
  const contextMenuHandler = react.exports.useCallback((e2, rowData) => {
    if (!checkModifierKeyActivated(e2)) {
      e2.preventDefault();
      contextRef.current.handleContextMenu(e2, rowData);
    }
  }, [contextRef]);
  const data = react.exports.useMemo(() => {
    const _data = [];
    tableData.forEach((zone, i) => {
      if (zone.signals.length === 1) {
        _data.push(__spreadProps(__spreadValues({}, zone), {
          tableMetaInfo: __spreadProps(__spreadValues({}, zone.tableMetaInfo), {
            signal: zone.signals[0],
            rowIndex: i,
            signalIndex: 0,
            id: zone.signals[0].id,
            experiment,
            nuclei
          })
        }));
      } else if (zone.signals.length > 1) {
        zone.signals.forEach((signal, j) => {
          let hide = false;
          let rowSpan = null;
          if (j < zone.signals.length - 1) {
            if (j === 0) {
              rowSpan = zone.signals.length;
            } else {
              hide = true;
            }
          } else {
            hide = true;
          }
          _data.push(__spreadProps(__spreadValues({}, zone), {
            tableMetaInfo: __spreadProps(__spreadValues({}, zone.tableMetaInfo), {
              signal,
              rowSpan,
              hide,
              rowIndex: i,
              signalIndex: j,
              id: signal.id,
              experiment
            })
          }));
        });
      }
    });
    return _data;
  }, [experiment, nuclei, tableData]);
  const {
    items: sortedData,
    isSortedDesc,
    onSort
  } = useTableSortBy(data);
  const rows = react.exports.useMemo(() => sortedData.map((rowData, index2) => /* @__PURE__ */ jsx(ZonesTableRow, {
    rowIndex: index2,
    rowData,
    onUnlink,
    onContextMenu: (e2, rowData2) => contextMenuHandler(e2, rowData2)
  }, `${rowData.tableMetaInfo.id}`)), [contextMenuHandler, sortedData, onUnlink]);
  return /* @__PURE__ */ jsxs("div", {
    children: [/* @__PURE__ */ jsxs("table", {
      css: tableStyle,
      children: [/* @__PURE__ */ jsxs("thead", {
        children: [/* @__PURE__ */ jsxs("tr", {
          children: [/* @__PURE__ */ jsx("th", {
            rowSpan: 2,
            children: "#"
          }), /* @__PURE__ */ jsx("th", {
            colSpan: 2,
            children: "\u03B4 (ppm)"
          }), /* @__PURE__ */ jsx("th", {
            colSpan: 2,
            children: /* @__PURE__ */ jsx(FaLink, {})
          }), /* @__PURE__ */ jsx("th", {
            colSpan: 2,
            children: "\u03A3"
          }), /* @__PURE__ */ jsx("th", {
            rowSpan: 2,
            children: "Kind"
          }), /* @__PURE__ */ jsx("th", {
            rowSpan: 2,
            children: ""
          })]
        }), /* @__PURE__ */ jsxs("tr", {
          children: [/* @__PURE__ */ jsx("th", __spreadProps(__spreadValues({
            id: "tableMetaInfo.signal.x.delta"
          }, onSort), {
            children: /* @__PURE__ */ jsxs(SurroundedText, {
              text: "F2",
              children: [nuclei[0], " ", isSortedDesc("tableMetaInfo.signal.x.delta").content]
            })
          })), /* @__PURE__ */ jsx("th", __spreadProps(__spreadValues({
            id: "tableMetaInfo.signal.y.delta"
          }, onSort), {
            children: /* @__PURE__ */ jsxs(SurroundedText, {
              text: "F1",
              children: [nuclei[1], " ", isSortedDesc("tableMetaInfo.signal.y.delta").content]
            })
          })), /* @__PURE__ */ jsx("th", {
            children: /* @__PURE__ */ jsx(SurroundedText, {
              text: "F2",
              children: nuclei[0]
            })
          }), /* @__PURE__ */ jsx("th", {
            children: /* @__PURE__ */ jsx(SurroundedText, {
              text: "F1",
              children: nuclei[1]
            })
          }), /* @__PURE__ */ jsx("th", {
            children: /* @__PURE__ */ jsx(SurroundedText, {
              text: "F2",
              children: nuclei[0]
            })
          }), /* @__PURE__ */ jsx("th", {
            children: /* @__PURE__ */ jsx(SurroundedText, {
              text: "F1",
              children: nuclei[1]
            })
          })]
        })]
      }), /* @__PURE__ */ jsx("tbody", {
        children: rows
      })]
    }), /* @__PURE__ */ jsx(ContextMenu$1, {
      ref: contextRef,
      context
    })]
  });
}
function SurroundedText(props) {
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [/* @__PURE__ */ jsx("div", {
      style: {
        position: "absolute",
        fontSize: 8,
        color: "#3539E6"
      },
      children: props.text
    }), /* @__PURE__ */ jsx("div", {
      style: {
        marginLeft: 5
      },
      children: props.children
    })]
  });
}
const style$3 = css`
  .remove-assignments-btn {
    border-radius: 5px;
    margin-top: 3px;
    margin-left: 2px;
    border: none;
    height: 16px;
    width: 18px;
    font-size: 12px;
    padding: 0;
    background-color: transparent;
  }
  .toggle {
    width: 22px;
    height: 22px;
    margin-left: 2px;
    display: flex;
    justify-content: center;
    align-items: center;
  }
`;
function ZonesPanelInner({
  zones,
  activeTab,
  xDomain,
  yDomain,
  experiment
}) {
  const [filterIsActive, setFilterIsActive] = react.exports.useState(false);
  const assignmentData = useAssignmentData();
  const dispatch = useDispatch();
  const modal = useModal();
  const [isFlipped, setFlipStatus] = react.exports.useState(false);
  const settingRef = react.exports.useRef();
  const tableData = react.exports.useMemo(() => {
    const isInView2 = (xFrom, xTo, yFrom, yTo) => {
      const factor = 1e4;
      xFrom = xFrom * factor;
      xTo = xTo * factor;
      yFrom = yFrom * factor;
      yTo = yTo * factor;
      return (xTo >= xDomain[0] * factor && xFrom <= xDomain[1] * factor || xFrom <= xDomain[0] * factor && xTo >= xDomain[1] * factor) && (yTo >= yDomain[0] * factor && yFrom <= yDomain[1] * factor || yFrom <= yDomain[0] * factor && yTo >= yDomain[1] * factor);
    };
    const getFilteredZones = (zones2) => {
      return zones2.filter((zone) => {
        return isInView2(zone.x.from, zone.x.to, zone.y.from, zone.y.to);
      });
    };
    if (zones.values) {
      const _zones = filterIsActive ? getFilteredZones(zones.values) : zones.values;
      return _zones.map((zone) => {
        return __spreadProps(__spreadValues({}, zone), {
          tableMetaInfo: {
            isConstantlyHighlighted: isInView2(zone.x.from, zone.x.to, zone.y.from, zone.y.to)
          }
        });
      });
    }
  }, [zones, filterIsActive, xDomain, yDomain]);
  const handleOnFilter = react.exports.useCallback(() => {
    setFilterIsActive(!filterIsActive);
  }, [filterIsActive]);
  const unlinkZoneHandler = react.exports.useCallback((zoneData = null, isOnZoneLevel = void 0, signalIndex = -1, axis = void 0) => {
    dispatch({
      type: UNLINK_ZONE,
      payload: {
        zoneData,
        assignmentData,
        isOnZoneLevel,
        signalIndex,
        axis
      }
    });
  }, [assignmentData, dispatch]);
  const removeAssignments2 = react.exports.useCallback(() => {
    unlinkZoneHandler();
  }, [unlinkZoneHandler]);
  const handleOnRemoveAssignments = react.exports.useCallback(() => {
    modal.showConfirmDialog({
      message: "All assignments will be removed. Are you sure?",
      buttons: [{
        text: "Yes",
        handler: removeAssignments2
      }, {
        text: "No"
      }]
    });
  }, [removeAssignments2, modal]);
  const handleDeleteAll = react.exports.useCallback(() => {
    modal.showConfirmDialog({
      message: "All zones will be deleted. Are You sure?",
      buttons: [{
        text: "Yes",
        handler: () => {
          dispatch({
            type: DELETE_2D_ZONE,
            payload: {
              assignmentData
            }
          });
        }
      }, {
        text: "No"
      }]
    });
  }, [assignmentData, dispatch, modal]);
  const settingsPanelHandler = react.exports.useCallback(() => {
    setFlipStatus(!isFlipped);
  }, [isFlipped]);
  const saveSettingHandler = react.exports.useCallback(() => {
    settingRef.current.saveSetting();
    setFlipStatus(false);
  }, []);
  const visibilityHandler = react.exports.useCallback((key) => {
    Emitter.emit("onZonesVisibilityChange", {
      key
    });
  }, []);
  return /* @__PURE__ */ jsx(Fragment, {
    children: /* @__PURE__ */ jsxs("div", {
      css: [tablePanelStyle, style$3, isFlipped && css`
              th {
                position: relative;
              }
            `],
      children: [!isFlipped && /* @__PURE__ */ jsxs(DefaultPanelHeader$1, {
        counter: zones.values ? zones.values.length : 0,
        onDelete: handleDeleteAll,
        deleteToolTip: "Delete All Zones",
        onFilter: handleOnFilter,
        filterToolTip: filterIsActive ? "Show all zones" : "Hide zones out of view",
        filterIsActive,
        counterFiltered: tableData == null ? void 0 : tableData.length,
        showSettingButton: true,
        onSettingClick: settingsPanelHandler,
        children: [/* @__PURE__ */ jsx(ToolTip$1, {
          title: `Remove all Assignments`,
          popupPlacement: "right",
          children: /* @__PURE__ */ jsx("button", {
            className: "remove-assignments-btn",
            type: "button",
            onClick: handleOnRemoveAssignments,
            disabled: !zones.values || zones.values.length === 0,
            children: /* @__PURE__ */ jsx(FaUnlink, {})
          })
        }), /* @__PURE__ */ jsx(ToggleButton$2, {
          popupTitle: "show/hide zones",
          popupPlacement: "right",
          defaultValue: true,
          onClick: () => visibilityHandler("zones"),
          children: /* @__PURE__ */ jsx("span", {
            style: {
              fontSize: "12px",
              pointerEvents: "none"
            },
            children: "z"
          })
        }), /* @__PURE__ */ jsx(ToggleButton$2, {
          popupTitle: "show/hide signals",
          popupPlacement: "right",
          defaultValue: true,
          onClick: () => visibilityHandler("signals"),
          children: /* @__PURE__ */ jsx("span", {
            style: {
              fontSize: "12px",
              pointerEvents: "none"
            },
            children: "s"
          })
        }), /* @__PURE__ */ jsx(ToggleButton$2, {
          popupTitle: "show/hide peaks",
          popupPlacement: "right",
          defaultValue: true,
          onClick: () => visibilityHandler("peaks"),
          children: /* @__PURE__ */ jsx("span", {
            style: {
              fontSize: "12px",
              pointerEvents: "none"
            },
            children: "p"
          })
        })]
      }), isFlipped && /* @__PURE__ */ jsx(PreferencesHeader$1, {
        onSave: saveSettingHandler,
        onClose: settingsPanelHandler
      }), /* @__PURE__ */ jsx("div", {
        className: "inner-container",
        children: !isFlipped ? /* @__PURE__ */ jsx("div", {
          className: "table-container",
          children: tableData && tableData.length > 0 ? /* @__PURE__ */ jsx(ZonesTable, {
            tableData,
            onUnlink: unlinkZoneHandler,
            nuclei: activeTab && activeTab.split(",").length === 2 ? activeTab.split(",") : ["?", "?"],
            experiment
          }) : /* @__PURE__ */ jsx(NoTableData, {})
        }) : /* @__PURE__ */ jsx(ZonesPreferences$1, {
          ref: settingRef
        })
      })]
    })
  });
}
const MemoizedZonesPanel = react.exports.memo(ZonesPanelInner);
const emptyData$4 = {
  zones: {},
  info: {}
};
function ZonesPanel() {
  const {
    displayerKey,
    xDomain,
    yDomain,
    activeTab
  } = useChartData();
  const {
    zones,
    info
  } = useSpectrum(emptyData$4);
  return /* @__PURE__ */ jsx(MemoizedZonesPanel, {
    xDomain,
    yDomain,
    activeTab,
    displayerKey,
    zones,
    experiment: info.experiment
  });
}
const databases = [
  {
    label: "Solvent database",
    value: prepareDataBase([...protonImpurities, ...carbonImpurities])
  }
];
function initiateDatabase(databases2, nucleus) {
  const data = databases2.filter((datum) => datum.nucleus === nucleus);
  const getSolvents = () => prepareGetSolvents(data);
  const search = (keywords = []) => filter(data, { keywords });
  return { data, getSolvents, search };
}
function prepareGetSolvents(data) {
  const result = [];
  const map = /* @__PURE__ */ new Map();
  for (const item of data) {
    if (!map.has(item.solvent)) {
      map.set(item.solvent, true);
      result.push(item.solvent);
    }
  }
  return result;
}
function prepareDataBase(array2) {
  return array2.map((item) => {
    item.ranges = item.ranges.map((range2) => __spreadValues({
      id: generateID()
    }, range2));
    return item;
  }, []);
}
function prepareData(data) {
  const result = [];
  let index2 = 0;
  for (const item of data) {
    let ids = [];
    const _a = item, { ranges = [] } = _a, restItemKeys = __objRest(_a, ["ranges"]);
    for (const range2 of ranges) {
      ids.push(range2.id || generateID());
      const _b = range2, { signals = [] } = _b, restRangKeys = __objRest(_b, ["signals"]);
      for (const signal of signals) {
        const _c = signal, { js = [] } = _c, restSignalKeys = __objRest(_c, ["js"]);
        const jsResult = mapJs(js);
        const data2 = __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, restItemKeys), restRangKeys), restSignalKeys), jsResult), {
          index: index2,
          id: ids,
          ranges
        });
        result.push(data2);
      }
    }
    index2++;
  }
  return result;
}
function mapJs(js) {
  if (js && js.length > 0) {
    const { coupling, multiplicity } = js.reduce((acc, { coupling: coupling2, multiplicity: multiplicity2 }) => {
      acc.coupling.push(coupling2.toFixed(1));
      acc.multiplicity += multiplicity2;
      return acc;
    }, { coupling: [], multiplicity: "" });
    return { multiplicity, coupling: coupling.join(",") };
  } else {
    return { multiplicity: "s", coupling: "" };
  }
}
const styles$k = {
  container: {
    padding: 10,
    backgroundColor: "#f1f1f1",
    height: "100%",
    overflowY: "auto"
  },
  groupContainer: {
    padding: "5px",
    borderRadius: "5px",
    margin: "10px 0px",
    backgroundColor: "white"
  },
  header: {
    borderBottom: "1px solid #e8e8e8",
    paddingBottom: "5px",
    fontWeight: "bold",
    color: "#4a4a4a"
  },
  inputContainer: {
    flex: 4,
    borderRadius: "5px"
  },
  inputLabel: {
    flex: 2,
    fontSize: "11px",
    fontWeight: "bold",
    color: "#232323"
  },
  input: {
    width: "100px"
  }
};
function DatabasePreferences(props, ref) {
  const preferences = usePreferences();
  const alert2 = useAlert();
  const formRef = react.exports.useRef();
  const updateValues = react.exports.useCallback(() => {
    const databasePreferences = getValue(preferences.current, `formatting.panels.database`);
    formRef.current.setValues(databasePreferences ? databasePreferences : databaseDefaultValues);
  }, [preferences]);
  react.exports.useEffect(() => {
    updateValues();
  }, [updateValues]);
  const saveHandler = react.exports.useCallback((values) => {
    preferences.dispatch({
      type: "SET_PANELS_PREFERENCES",
      payload: {
        key: "database",
        value: values
      }
    });
    alert2.success("database preferences saved successfully");
  }, [alert2, preferences]);
  react.exports.useImperativeHandle(ref, () => ({
    saveSetting: () => {
      formRef.current.submitForm();
    }
  }));
  return /* @__PURE__ */ jsx$1("div", {
    style: styles$k.container,
    children: /* @__PURE__ */ jsx$1(FormikForm, {
      onSubmit: saveHandler,
      ref: formRef,
      children: /* @__PURE__ */ jsxs$1("div", {
        style: styles$k.groupContainer,
        children: [/* @__PURE__ */ jsx$1(FormikColumnFormatField$1, {
          label: "structure",
          checkControllerName: "showSmiles",
          hideFormat: true
        }), /* @__PURE__ */ jsx$1(FormikColumnFormatField$1, {
          label: "Solvent",
          checkControllerName: "showSolvent",
          hideFormat: true
        }), /* @__PURE__ */ jsx$1(FormikColumnFormatField$1, {
          label: "Names",
          checkControllerName: "showNames",
          hideFormat: true
        }), /* @__PURE__ */ jsx$1(FormikColumnFormatField$1, {
          label: "Range",
          checkControllerName: "showRange",
          hideFormat: true
        }), /* @__PURE__ */ jsx$1(FormikColumnFormatField$1, {
          label: "\u03B4 (ppm)",
          checkControllerName: "showDelta",
          hideFormat: true
        }), /* @__PURE__ */ jsx$1(FormikColumnFormatField$1, {
          label: "Assignment",
          checkControllerName: "showAssignment",
          hideFormat: true
        }), /* @__PURE__ */ jsx$1(FormikColumnFormatField$1, {
          label: "J (Hz)",
          checkControllerName: "showCoupling",
          hideFormat: true
        }), /* @__PURE__ */ jsx$1(FormikColumnFormatField$1, {
          label: "Multiplicity",
          checkControllerName: "showMultiplicity",
          hideFormat: true
        })]
      })
    })
  });
}
var DatabasePreferences$1 = react.exports.forwardRef(DatabasePreferences);
const overFlowStyle = {
  overflow: "hidden",
  whiteSpace: "nowrap",
  textOverflow: "ellipsis"
};
const COLUMNS = [{
  showWhen: "showNames",
  index: 1,
  Header: "names",
  accessor: (row) => row.names ? row.names.join(",") : "",
  enableRowSpan: true,
  style: __spreadValues({
    width: "100px",
    minWidth: "100px",
    maxWidth: "100px"
  }, overFlowStyle)
}, {
  showWhen: "showRange",
  index: 2,
  Header: "From - To",
  accessor: (row) => `${row.from.toFixed(2)} - ${row.to.toFixed(2)}`,
  enableRowSpan: true
}, {
  showWhen: "showDelta",
  index: 3,
  Header: "\u03B4 (ppm)",
  accessor: "delta"
}, {
  showWhen: "showAssignment",
  index: 4,
  Header: "Assignment",
  accessor: "assignment"
}, {
  showWhen: "showMultiplicity",
  index: 5,
  Header: "Multi.",
  accessor: "multiplicity"
}, {
  showWhen: "showCoupling",
  index: 6,
  Header: "J (Hz)",
  accessor: "coupling",
  style: __spreadValues({
    width: "60px",
    minWidth: "60px"
  }, overFlowStyle)
}, {
  showWhen: "showSolvent",
  index: 7,
  Header: "Solvent",
  accessor: "solvent",
  style: __spreadValues({
    width: "80px",
    minWidth: "80px"
  }, overFlowStyle)
}, {
  showWhen: "showSmiles",
  index: 8,
  Header: "structure",
  accessor: "index",
  style: {
    height: 0
  },
  enableRowSpan: true,
  Cell: ({
    row
  }) => {
    var _a, _b;
    const {
      idCode,
      coordinates
    } = ((_a = row.original) == null ? void 0 : _a.ocl) || {};
    const smiles = (_b = row.original) == null ? void 0 : _b.smiles;
    return /* @__PURE__ */ jsx(ResponsiveChart, {
      children: ({
        width,
        height
      }) => {
        if (idCode && coordinates) {
          return /* @__PURE__ */ jsx(IdcodeSvgRenderer, {
            height,
            width,
            idcode: idCode,
            coordinates
          });
        } else if (smiles) {
          return /* @__PURE__ */ jsx(SmilesSvgRenderer, {
            height,
            width,
            smiles
          });
        } else {
          return null;
        }
      }
    });
  }
}];
function DatabaseTable({
  data,
  onAdd
}) {
  const preferences = usePreferences();
  const initialColumns = react.exports.useMemo(() => [{
    index: 10,
    Header: "",
    width: "1%",
    maxWidth: "24px",
    minWidth: "24px",
    id: "add-button",
    accessor: "index",
    enableRowSpan: true,
    Cell: ({
      row
    }) => /* @__PURE__ */ jsx("button", {
      type: "button",
      className: "add-button",
      onClick: () => onAdd(row),
      children: /* @__PURE__ */ jsx(FaPlus, {})
    })
  }], [onAdd]);
  const tableColumns = react.exports.useMemo(() => {
    const databasePreferences = getValue(preferences.current, "formatting.panels.database", databaseDefaultValues);
    let columns = [...initialColumns];
    for (const col of COLUMNS) {
      const _a = col, {
        showWhen
      } = _a, colParams = __objRest(_a, [
        "showWhen"
      ]);
      if (databasePreferences[showWhen]) {
        addCustomColumn(columns, colParams);
      }
    }
    return columns.sort((object1, object2) => object1.index - object2.index);
  }, [initialColumns, preferences]);
  return /* @__PURE__ */ jsx(ReactTable$1, {
    data,
    columns: tableColumns,
    highlightedSource: HighlightedSource.DATABASE,
    groupKey: "index",
    approxItemHeight: 30,
    enableVirtualScroll: true
  });
}
var DatabaseTable$1 = react.exports.memo(DatabaseTable);
function useDatabases() {
  const { current } = usePreferences();
  return react.exports.useMemo(() => {
    const data = current.databases || [];
    return databases.concat(data.filter((datum) => datum.enabled));
  }, [current.databases]);
}
const style$2 = css`
  .header {
    height: 30px;
    padding: 2px 0px 2px 5px;
  }
  .input-container {
    width: 100%;
  }
  .search-input {
    width: 100% !important;
    border-radius: 5px;
    border: 0.55px solid gray;
    padding: 0 5px;
    outline: none;
  }
`;
const emptyKeywords = {
  solvent: "",
  searchKeywords: ""
};
function DatabasePanelInner({
  nucleus,
  selectedTool
}) {
  const dispatch = useDispatch();
  const alert2 = useAlert();
  const {
    handleChangeOption
  } = useToolsFunctions();
  const format2 = useFormatNumberByNucleus(nucleus);
  const databases2 = useDatabases();
  const [isFlipped, setFlipStatus] = react.exports.useState(false);
  const settingRef = react.exports.useRef();
  const [keywords, setKeywords] = react.exports.useState(emptyKeywords);
  const databaseInstance = react.exports.useRef(null);
  const [result, setResult] = react.exports.useState({
    data: [],
    databases: [],
    solvents: []
  });
  const settingsPanelHandler = react.exports.useCallback(() => {
    setFlipStatus(!isFlipped);
  }, [isFlipped]);
  const saveSettingHandler = react.exports.useCallback(() => {
    settingRef.current.saveSetting();
    setFlipStatus(false);
  }, []);
  const handleSearch = react.exports.useCallback((input) => {
    if (typeof input === "string" || input === -1) {
      const solvent = String(input);
      setKeywords((prevState) => __spreadProps(__spreadValues({}, prevState), {
        solvent
      }));
    } else {
      setKeywords((prevState) => __spreadProps(__spreadValues({}, prevState), {
        searchKeywords: input.target.value
      }));
    }
  }, []);
  react.exports.useEffect(() => {
    const {
      solvent,
      searchKeywords
    } = keywords;
    setTimeout(() => {
      if (databaseInstance.current) {
        if (!solvent && !searchKeywords) {
          const data = databaseInstance.current.data;
          const solvents = mapSolventsToSelect(databaseInstance.current.getSolvents());
          setResult((prevResult) => __spreadProps(__spreadValues({}, prevResult), {
            data,
            solvents
          }));
        } else {
          const values = [...searchKeywords.split(" ")];
          if (solvent !== "-1") {
            values.unshift(`solvent:${solvent}`);
          }
          const data = databaseInstance.current.search(values.join(" "));
          setResult((prevResult) => __spreadProps(__spreadValues({}, prevResult), {
            data
          }));
        }
      }
    });
  }, [keywords]);
  react.exports.useEffect(() => {
    function handle(event) {
      if (selectedTool === options.databaseRangesSelection.id) {
        setKeywords((prevState) => {
          const oldKeywords = prevState.searchKeywords ? prevState.searchKeywords.split(" ") : [];
          const [from, to] = event.range;
          const searchKeywords = [...oldKeywords, `delta:${format2(from)}..${format2(to)}`].join(" ");
          return __spreadProps(__spreadValues({}, prevState), {
            searchKeywords
          });
        });
      }
    }
    Emitter.on("brushEnd", handle);
    return () => {
      Emitter.off("brushEnd", handle);
    };
  }, [format2, selectedTool]);
  const handleChangeDatabase = react.exports.useCallback((databaseIndex) => {
    void (async () => {
      let _database = [];
      const {
        url,
        label,
        value
      } = databases2[databaseIndex];
      if (url) {
        const hideLoading = await alert2.showLoading(`load ${label} database`);
        try {
          _database = await fetch(url).then((response) => response.json());
        } catch (e2) {
          alert2.error(`Failed to load ${url}`);
        } finally {
          hideLoading();
        }
      } else {
        _database = value;
      }
      databaseInstance.current = initiateDatabase(_database, nucleus);
      setKeywords(__spreadValues({}, emptyKeywords));
    })();
  }, [alert2, databases2, nucleus]);
  const tableData = react.exports.useMemo(() => {
    return prepareData(result.data);
  }, [result.data]);
  const resurrectHandler = react.exports.useCallback((row) => {
    const {
      index: index2
    } = row.original;
    const {
      ranges,
      solvent,
      names = []
    } = result.data[index2];
    dispatch({
      type: RESURRECTING_SPECTRUM_FROM_RANGES,
      payload: {
        ranges,
        info: {
          solvent,
          nucleus,
          name: names[0]
        }
      }
    });
  }, [dispatch, nucleus, result.data]);
  const clearHandler = react.exports.useCallback(() => {
    setKeywords((prevState) => __spreadProps(__spreadValues({}, prevState), {
      searchKeywords: ""
    }));
  }, []);
  const enableFilterHandler = react.exports.useCallback((flag) => {
    const tool = !flag ? options.zoom.id : options.databaseRangesSelection.id;
    handleChangeOption(tool);
  }, [handleChangeOption]);
  return /* @__PURE__ */ jsxs("div", {
    css: [tablePanelStyle, style$2, isFlipped && css`
            .table-container {
              table,
              th {
                position: relative !important;
              }
            }
          `],
    children: [!isFlipped && /* @__PURE__ */ jsxs(DefaultPanelHeader$1, {
      showSettingButton: true,
      onSettingClick: settingsPanelHandler,
      canDelete: false,
      className: "header",
      children: [/* @__PURE__ */ jsx(ToggleButton$2, {
        defaultValue: selectedTool === options.databaseRangesSelection.id,
        popupTitle: "Filter by select ranges",
        popupPlacement: "right",
        onClick: enableFilterHandler,
        children: /* @__PURE__ */ jsx(FaICursor, {
          style: {
            pointerEvents: "none",
            fontSize: "12px",
            transform: "rotate(90deg)"
          }
        })
      }, `${selectedTool}`), /* @__PURE__ */ jsx(Select, {
        style: {
          flex: 2
        },
        data: mapDatabasesToSelect(databases2),
        onChange: handleChangeDatabase,
        placeholder: "Select database"
      }), /* @__PURE__ */ jsx(Select, {
        style: {
          flex: 1
        },
        data: result.solvents,
        placeholder: "Solvent",
        onChange: handleSearch
      }), /* @__PURE__ */ jsx(Input, {
        value: keywords.searchKeywords,
        renderIcon: () => /* @__PURE__ */ jsx(IoSearchOutline, {}),
        style: {
          inputWrapper: {
            flex: 3
          }
        },
        className: "search-input",
        type: "text",
        debounceTime: 250,
        placeholder: "Search for parameter...",
        onChange: handleSearch,
        onClear: clearHandler,
        canClear: true
      })]
    }), isFlipped && /* @__PURE__ */ jsx(PreferencesHeader$1, {
      onSave: saveSettingHandler,
      onClose: settingsPanelHandler
    }), /* @__PURE__ */ jsx("div", {
      className: "inner-container",
      children: !isFlipped ? tableData && tableData.length > 0 ? /* @__PURE__ */ jsx(DatabaseTable$1, {
        data: tableData,
        onAdd: resurrectHandler
      }) : /* @__PURE__ */ jsx(NoTableData, {
        text: databases2 && databases2.length > 0 ? "Please select a database" : "Please add databases URL in the general preferences"
      }) : /* @__PURE__ */ jsx(DatabasePreferences$1, {
        ref: settingRef
      })
    })]
  });
}
const MemoizedDatabasePanel = react.exports.memo(DatabasePanelInner);
function PeaksPanel() {
  const {
    activeTab,
    toolOptions: {
      selectedTool
    }
  } = useChartData();
  if (!activeTab)
    return /* @__PURE__ */ jsx("div", {});
  return /* @__PURE__ */ jsx(MemoizedDatabasePanel, {
    nucleus: activeTab,
    selectedTool
  });
}
function mapSolventsToSelect(solvents) {
  const result = solvents.map((key) => {
    return {
      key,
      label: key,
      value: key
    };
  }, []);
  result.unshift({
    key: "-1",
    label: "All",
    value: "-1"
  });
  return result;
}
function mapDatabasesToSelect(databases2) {
  return databases2.map(({
    label
  }, index2) => ({
    key: index2,
    value: index2,
    label
  }));
}
const styles$j = {
  width: "100%",
  height: "100%",
  padding: "0px",
  display: "flex",
  flexDirection: "column"
};
function Table({
  children,
  className,
  style: style2,
  testID
}) {
  return /* @__PURE__ */ jsx$1("div", {
    className,
    style: __spreadValues(__spreadValues({}, styles$j), style2),
    "data-test-id": testID,
    children
  });
}
var Table$1 = react.exports.memo(Table);
const styles$i = {
  width: "100%",
  overflowY: "auto",
  display: "flex",
  flexDirection: "column",
  padding: "5px 0px",
  color: "gray"
};
function TableBody({
  children,
  className,
  style: style2
}) {
  const mappedChildren = react.exports.useMemo(() => {
    return react.exports.Children.map(children, (child) => react.exports.cloneElement(child, {
      style: __spreadValues({
        borderBottom: "0.55px solid #d8d8d8"
      }, child.props.style)
    }));
  }, [children]);
  return /* @__PURE__ */ jsx$1("div", {
    className,
    style: __spreadValues(__spreadValues({}, styles$i), style2),
    children: mappedChildren
  });
}
var TableBody$1 = react.exports.memo(TableBody);
const styles$h = {
  width: "100%",
  display: "flex",
  alignItems: "flex-start"
};
function getVAlign(align) {
  if (align.toLowerCase() === "top") {
    return "flex-start";
  } else if (align.toLowerCase() === "bottom") {
    return "flex-end";
  }
  return "center";
}
function TableHeader$1({
  children,
  className,
  style: style2,
  align = "center",
  vAlign = "center",
  size = 1,
  onClick = () => null
}) {
  return /* @__PURE__ */ jsx$1("div", {
    className,
    style: __spreadValues(__spreadProps(__spreadValues({}, styles$h), {
      alignItems: getVAlign(vAlign),
      textAlign: align,
      flex: size
    }), style2),
    onClick,
    children
  });
}
var TableCell = react.exports.memo(TableHeader$1);
const styles$g = {
  width: "100%",
  display: "flex",
  padding: "0px 5px",
  color: "#424242",
  backgroundColor: "#d8d8d8",
  borderBottom: "0.55px solid #d8d8d8",
  fontSize: 11,
  fontWeight: "bold"
};
function TableHead({
  children,
  className,
  style: style2
}) {
  return /* @__PURE__ */ jsx$1("div", {
    className,
    style: __spreadValues(__spreadValues({}, styles$g), style2),
    children
  });
}
var TableHead$1 = react.exports.memo(TableHead);
const styles$f = {
  width: "100%",
  display: "flex",
  padding: "5px 0px"
};
function TableHeader({
  children,
  className,
  style: style2,
  onClick = () => null
}) {
  return /* @__PURE__ */ jsx$1("div", {
    className,
    style: __spreadValues(__spreadValues({}, styles$f), style2),
    onClick,
    children
  });
}
var TableRow = react.exports.memo(TableHeader);
function FiltersTableInner({
  filters,
  spectraCounter,
  selectedTool,
  activeFilterID
}) {
  const dispatch = useDispatch();
  const modal = useModal();
  const alert2 = useAlert();
  const selectedFilterRef = react.exports.useRef({
    index: null
  });
  const handelFilterCheck = react.exports.useCallback((id2, checked) => {
    void (async () => {
      const hideLoading = await alert2.showLoading(`${checked ? "Enable" : "Disable"} filter in progress`);
      setTimeout(() => {
        dispatch({
          type: ENABLE_FILTER,
          id: id2,
          checked
        });
        hideLoading();
      }, 0);
    })();
  }, [alert2, dispatch]);
  const handelDeleteFilter = react.exports.useCallback(({
    id: id2,
    name: name2
  }) => {
    const buttons = [{
      text: "Yes",
      handler: async () => {
        const hideLoading = await alert2.showLoading("Delete filter process in progress");
        dispatch({
          type: DELETE_FILTER,
          payload: {
            id: id2
          }
        });
        hideLoading();
      }
    }, {
      text: "No"
    }];
    if (spectraCounter > 1) {
      buttons.unshift({
        text: "Yes, for all spectra",
        handler: async () => {
          const hideLoading = await alert2.showLoading("Delete all spectra filter process in progress");
          dispatch({
            type: DELETE_SPECTRA_FILTER,
            payload: {
              filterType: name2
            }
          });
          hideLoading();
        }
      });
    }
    modal.showConfirmDialog({
      message: "Are you sure you want to delete the spectrum?",
      buttons
    });
  }, [alert2, dispatch, modal, spectraCounter]);
  const filterSnapShotHandler = react.exports.useCallback((newID) => {
    void (async () => {
      const hideLoading = await alert2.showLoading("Filter snapshot process in progress");
      setTimeout(() => {
        dispatch({
          type: SET_FILTER_SNAPSHOT,
          id: newID
        });
        hideLoading();
      }, 0);
    })();
  }, [alert2, dispatch]);
  const getStyle = react.exports.useCallback((filter2, index2) => {
    const {
      id: id2,
      name: name2
    } = filter2;
    if (activeFilterID && activeFilterID === id2) {
      selectedFilterRef.current.index = index2;
    } else if (!activeFilterID) {
      selectedFilterRef.current.index = null;
    }
    const classes = ["filter-row"];
    if (activeFilterID === id2) {
      classes.push("filter-active");
    } else if (selectedTool === name2) {
      classes.push("filter-current");
    } else if (selectedFilterRef.current.index != null && index2 > selectedFilterRef.current.index) {
      classes.push("filter-deactive");
    }
    return classes.join(" ");
  }, [activeFilterID, selectedTool]);
  const filtersTableRow = react.exports.useMemo(() => {
    return filters == null ? void 0 : filters.map((d, index2) => {
      return /* @__PURE__ */ jsxs$1(TableRow, {
        className: getStyle(d, index2),
        children: [/* @__PURE__ */ jsx$1(TableCell, {
          align: "center",
          size: 2,
          onClick: () => filterSnapShotHandler(d.id),
          children: d.label
        }), /* @__PURE__ */ jsx$1(TableCell, {
          align: "left",
          size: 3,
          children: /* @__PURE__ */ jsx$1("div", {
            onClick: (e2) => e2.stopPropagation(),
            children: /* @__PURE__ */ jsx$1(ObjectInspector$1, {
              data: d.error ? d.error : d.value
            })
          })
        }), /* @__PURE__ */ jsxs$1(TableCell, {
          align: "center",
          vAlign: "center",
          size: 1,
          children: [/* @__PURE__ */ jsx$1(CheckBox, {
            checked: d.flag,
            onChange: (event) => handelFilterCheck(d.id, event.target.checked)
          }), d.isDeleteAllow && /* @__PURE__ */ jsx$1("button", {
            className: "btn",
            type: "button",
            onClick: () => handelDeleteFilter(d),
            children: /* @__PURE__ */ jsx$1(FaRegTrashAlt, {})
          })]
        })]
      }, d.id);
    });
  }, [filterSnapShotHandler, filters, getStyle, handelDeleteFilter, handelFilterCheck]);
  return /* @__PURE__ */ jsx$1(Fragment$1, {
    children: filtersTableRow
  });
}
const emptyData$3 = {
  filters: []
};
const MemoizedFiltersTable = react.exports.memo(FiltersTableInner);
function FilterTable() {
  const {
    toolOptions: {
      selectedTool,
      data: {
        activeFilterID
      }
    }
  } = useChartData();
  const {
    filters
  } = useSpectrum(emptyData$3);
  const spectraCounter = useSpectraByActiveNucleus().length;
  return /* @__PURE__ */ jsx$1(MemoizedFiltersTable, {
    selectedTool,
    filters,
    spectraCounter,
    activeFilterID
  });
}
const styles$e = css`
  .btn {
    background-color: transparent;
    border: none;
    height: 25;
    width: 25;
    padding: 5px;
  }
  .filter-row {
    padding: 5px !important;
  }
  .filter-active {
    background-color: #f7f7f7;
    div,
    span,
    .btn {
      color: black !important;
    }

    li {
      background-color: transparent !important;
    }
  }
  .filter-current {
    background-color: #707070;
    div,
    span,
    .btn {
      color: white !important;
    }

    li {
      background-color: transparent !important;
    }
  }

  .filter-deactive {
    opacity: 0.3;
  }
`;
function FilterPanelInner({
  filters
}) {
  const filtersTable = react.exports.useMemo(() => {
    return filters ? /* @__PURE__ */ jsxs(Table$1, {
      testID: "filters-table",
      children: [/* @__PURE__ */ jsx(TableHead$1, {
        children: /* @__PURE__ */ jsxs(TableRow, {
          children: [/* @__PURE__ */ jsx(TableCell, {
            align: "center",
            size: 1,
            children: "Label"
          }), /* @__PURE__ */ jsx(TableCell, {
            align: "center",
            size: 2,
            children: "Properties"
          })]
        })
      }), /* @__PURE__ */ jsx(TableBody$1, {
        css: styles$e,
        children: /* @__PURE__ */ jsx(FilterTable, {})
      })]
    }) : /* @__PURE__ */ jsx(NoTableData, {});
  }, [filters]);
  return filtersTable;
}
const emptyData$2 = {
  filters: []
};
const MemoizedFilterPanel = react.exports.memo(FilterPanelInner);
function FilterPanel() {
  const {
    filters
  } = useSpectrum(emptyData$2);
  return /* @__PURE__ */ jsx(MemoizedFilterPanel, {
    filters
  });
}
const styles$d = css`
  padding: 10px;
  border-top: solid #f2f2f2 1px;

  .row {
    flex: row;
    display: flex;
    padding-bottom: 10px;
  }

  .inner-content {
    flex: 1;
  }

  .custom-label {
    width: 160px;
  }

  .footer-container {
    display: flex;
    flex-direction: row-reverse;
    align-items: flex-end;
  }

  .input {
    font-size: 14px;
    border-radius: 5px;
    border: 1px solid #cccccc;
    padding: 5px;
    width: 100px;
    margin-right: 10px;
    height: initial !important;
  }
`;
const predictionFormValidation = create().shape({
  frequency: create$1().integer().required().label("Frequency"),
  "1d": create({
    "1H": create({
      from: create$1().integer().required().label("1H ' From ' "),
      to: create$1().integer().required().label("1H ' To ' ")
    }),
    "13C": create().shape({
      from: create$1().integer().required().label("13C ' From ' "),
      to: create$1().integer().required().label("13C ' To ' ")
    }),
    lineWidth: create$1().integer().min(1).required().label("Line Width")
  })
});
function PredictionOptions({
  onPredict = () => null
}) {
  const refForm = react.exports.useRef();
  const handleSave = react.exports.useCallback(() => {
    refForm.current.submitForm();
  }, []);
  const submitHandler = react.exports.useCallback((values) => {
    void (async () => {
      onPredict(values);
    })();
  }, [onPredict]);
  return /* @__PURE__ */ jsxs("div", {
    css: styles$d,
    children: [/* @__PURE__ */ jsx("div", {
      children: /* @__PURE__ */ jsxs(FormikForm, {
        ref: refForm,
        initialValues: defaultPredictionOptions,
        validationSchema: predictionFormValidation,
        onSubmit: submitHandler,
        children: [/* @__PURE__ */ jsx(FormikErrorsSummary, {}), /* @__PURE__ */ jsxs("div", {
          className: "row margin-10",
          children: [/* @__PURE__ */ jsx("span", {
            className: "custom-label",
            children: "Frequency : "
          }), /* @__PURE__ */ jsx(FormikSelect, {
            data: FREQUENCIES,
            style: {
              width: 290,
              height: 30,
              margin: 0
            },
            name: "frequency"
          })]
        }), /* @__PURE__ */ jsxs("div", {
          className: "row",
          children: [/* @__PURE__ */ jsx(IsotopesViewer, {
            value: "1H",
            className: "custom-label"
          }), /* @__PURE__ */ jsx(Label, {
            title: "From",
            children: /* @__PURE__ */ jsx(FormikInput, {
              name: "1d.1H.from",
              type: "number"
            })
          }), /* @__PURE__ */ jsx(Label, {
            title: "To",
            style: {
              label: {
                padding: "0 10px"
              }
            },
            children: /* @__PURE__ */ jsx(FormikInput, {
              name: "1d.1H.to",
              type: "number"
            })
          })]
        }), /* @__PURE__ */ jsxs("div", {
          className: "row",
          children: [/* @__PURE__ */ jsx(IsotopesViewer, {
            value: "13C",
            className: "custom-label"
          }), /* @__PURE__ */ jsx(Label, {
            title: "From",
            children: /* @__PURE__ */ jsx(FormikInput, {
              name: "1d.13C.from",
              type: "number"
            })
          }), /* @__PURE__ */ jsx(Label, {
            title: "To",
            style: {
              label: {
                padding: "0 10px"
              }
            },
            children: /* @__PURE__ */ jsx(FormikInput, {
              name: "1d.13C.to",
              type: "number"
            })
          })]
        }), /* @__PURE__ */ jsxs("div", {
          className: "row margin-10 padding-h-10",
          children: [/* @__PURE__ */ jsx("span", {
            className: "custom-label",
            children: "Line Width : "
          }), /* @__PURE__ */ jsx(FormikInput, {
            name: "1d.lineWidth",
            type: "number",
            style: {
              input: {
                margin: 0
              }
            }
          }), /* @__PURE__ */ jsx("span", {
            style: {
              paddingLeft: "0.4rem"
            },
            children: " Hz "
          })]
        })]
      })
    }), /* @__PURE__ */ jsx("div", {
      children: /* @__PURE__ */ jsx(Button.Done, {
        onClick: handleSave,
        children: "Predict spectrum"
      })
    })]
  });
}
function PredictionPane() {
  const [molecule, setMolecule] = react.exports.useState();
  const changeHandler = react.exports.useCallback((molecule2) => {
    setMolecule(molecule2);
  }, []);
  const dispatch = useDispatch();
  const alert2 = useAlert();
  const predictHandler = react.exports.useCallback((values) => {
    void (async () => {
      if (molecule) {
        dispatch({
          type: SET_LOADING_FLAG,
          isLoading: true
        });
        const hideLoading = await alert2.showLoading(`Predict 1H, 13C, COSY, HSQC, and HMBC in progress`);
        dispatch({
          type: PREDICT_SPECTRA,
          payload: {
            mol: molecule,
            options: values
          }
        });
        hideLoading();
      } else {
        alert2.error("No Molecule selected");
      }
    })();
  }, [alert2, dispatch, molecule]);
  return /* @__PURE__ */ jsx$1(MoleculePanel, {
    onMoleculeChange: changeHandler,
    actionsOptions: {
      hidePredict: true,
      hideDelete: true,
      hideExport: true
    },
    children: /* @__PURE__ */ jsx$1(PredictionOptions, {
      onPredict: predictHandler
    })
  });
}
const accordionItems = [{
  title: "Spectra",
  component: /* @__PURE__ */ jsx$1(SpectrumListPanel$1, {}),
  hidePreferenceKey: "spectraPanel",
  mode: null
}, {
  title: "Information",
  component: /* @__PURE__ */ jsx$1(InformationPanel, {}),
  style: {
    overflow: "hidden"
  },
  hidePreferenceKey: "informationPanel",
  mode: null
}, {
  title: "Peaks",
  component: /* @__PURE__ */ jsx$1(PeaksPanel$1, {}),
  hidePreferenceKey: "peaksPanel",
  mode: null
}, {
  title: "Filters",
  component: /* @__PURE__ */ jsx$1(FilterPanel, {}),
  hidePreferenceKey: "filtersPanel",
  mode: null
}, {
  title: "Integrals",
  component: /* @__PURE__ */ jsx$1(IntegralPanel, {}),
  hidePreferenceKey: "integralsPanel",
  mode: null
}, {
  title: "Ranges",
  component: /* @__PURE__ */ jsx$1(RangesTablePanel, {}),
  hidePreferenceKey: "rangesPanel",
  mode: DISPLAYER_MODE.DM_1D
}, {
  title: "Multiple Spectra Analysis",
  component: /* @__PURE__ */ jsx$1(MultipleSpectraAnalysisPanel, {}),
  hidePreferenceKey: "multipleSpectraAnalysisPanel",
  mode: null
}, {
  title: "Matrix Generation",
  component: /* @__PURE__ */ jsx$1(MatrixGenerationPanel, {}),
  hidePreferenceKey: "",
  mode: null,
  isExperimental: true
}, {
  title: "Zones",
  component: /* @__PURE__ */ jsx$1(ZonesPanel, {}),
  hidePreferenceKey: "zonesPanel",
  mode: DISPLAYER_MODE.DM_2D
}, {
  title: "Summary",
  component: /* @__PURE__ */ jsx$1(SummaryPanel$1, {}),
  hidePreferenceKey: "summaryPanel",
  mode: null
}, {
  title: "Structures",
  component: /* @__PURE__ */ jsx$1(MoleculePanel, {}),
  hidePreferenceKey: "structuresPanel",
  mode: null
}, {
  title: "Databases",
  component: /* @__PURE__ */ jsx$1(PeaksPanel, {}),
  hidePreferenceKey: "databasePanel",
  mode: null
}, {
  title: "Automatic Assignment",
  component: /* @__PURE__ */ jsx$1(AutomaticAssignment, {}),
  hidePreferenceKey: "",
  mode: null,
  isExperimental: true
}, {
  title: "Prediction",
  component: /* @__PURE__ */ jsx$1(PredictionPane, {}),
  hidePreferenceKey: "predictionPanel",
  mode: null
}];
const TOOLS_PANELS_ACCORDION = {
  null: "Spectra",
  peakPicking: "Peaks",
  integral: "Integrals",
  rangesPicking: "Ranges",
  zone2D: "Zones",
  multipleSpectraAnalysis: "Multiple Spectra Analysis"
};
function usePanelPreferences() {
  const preferences = usePreferences();
  return react.exports.useCallback((item) => {
    return get_1(preferences.current, `display.panels.${item.hidePreferenceKey}`);
  }, [preferences]);
}
function PanelsInner({
  displayerMode: displayedMode
}) {
  const getPanelPreferences = usePanelPreferences();
  const isExperimental = useCheckExperimentalFeature();
  const check = react.exports.useCallback((item) => {
    const panelOptions = getPanelPreferences(item);
    return (panelOptions == null ? void 0 : panelOptions.hidden) !== true && (panelOptions == null ? void 0 : panelOptions.display) === true && item.isExperimental === void 0 && (item.mode == null || item.mode === displayedMode) || item.isExperimental && isExperimental;
  }, [displayedMode, getPanelPreferences, isExperimental]);
  const isOpened = react.exports.useCallback((item) => {
    const panelOptions = getPanelPreferences(item);
    return (panelOptions == null ? void 0 : panelOptions.hidden) !== true && (panelOptions == null ? void 0 : panelOptions.open);
  }, [getPanelPreferences]);
  return /* @__PURE__ */ jsx$1("div", {
    style: {
      width: "100%",
      height: "100%",
      flex: "1 1 0%"
    },
    children: /* @__PURE__ */ jsx$1(Accordion, {
      children: accordionItems.map((item) => {
        return check(item) && /* @__PURE__ */ jsx$1(Accordion.Item, {
          title: item.title,
          defaultOpened: isOpened(item),
          children: item.component
        }, item.title);
      })
    })
  });
}
const MemoizedPanels = react.exports.memo(PanelsInner);
function Panels() {
  const {
    displayerMode,
    toolOptions: {
      selectedTool
    }
  } = useChartData();
  return /* @__PURE__ */ jsx$1(MemoizedPanels, {
    displayerMode,
    selectedTool
  });
}
function useToolsFunctions() {
  const dispatch = useDispatch();
  const alert2 = useAlert();
  const { open: openPanel } = useToggleAccordion();
  const [isRealSpectrumShown, setIsRealSpectrumShown] = react.exports.useState(false);
  const debounceClickEventsRef = react.exports.useRef({ clicks: [] });
  const handleChangeOption = react.exports.useCallback((selectedTool) => {
    if ([
      options.peakPicking.id,
      options.integral.id,
      options.zone2D.id,
      options.exclusionZones.id
    ].includes(selectedTool)) {
      alert2.show("Press Shift + Left Mouse button to select zone");
    }
    if (Object.keys(TOOLS_PANELS_ACCORDION).includes(selectedTool)) {
      openPanel(TOOLS_PANELS_ACCORDION[selectedTool]);
    }
    dispatch({
      type: SET_SELECTED_TOOL,
      payload: { selectedTool }
    });
  }, [alert2, dispatch, openPanel]);
  const handleFullZoomOut = react.exports.useCallback(() => {
    if (debounceClickEventsRef.current.clicks.length === 0) {
      dispatch({
        type: FULL_ZOOM_OUT,
        zoomType: ZoomType.HORIZONTAL
      });
    }
    const callback = debounce_1(() => {
      debounceClickEventsRef.current.clicks = [];
    }, 500);
    debounceClickEventsRef.current.clicks.push(callback);
    callback();
    if (debounceClickEventsRef.current.clicks.length > 1) {
      map_1(debounceClickEventsRef.current.clicks, (debounce) => debounce.cancel());
      debounceClickEventsRef.current.clicks = [];
      dispatch({
        type: FULL_ZOOM_OUT
      });
    }
  }, [dispatch, debounceClickEventsRef]);
  const changeDisplayViewModeHandler = react.exports.useCallback(() => {
    dispatch({
      type: CHANGE_SPECTRUM_DISPLAY_VIEW_MODE
    });
  }, [dispatch]);
  const changeSpectrumViewHandler = react.exports.useCallback(() => {
    dispatch({
      type: TOGGLE_REAL_IMAGINARY_VISIBILITY,
      isRealSpectrumVisible: !isRealSpectrumShown
    });
    setIsRealSpectrumShown(!isRealSpectrumShown);
  }, [dispatch, isRealSpectrumShown]);
  const alignSpectrumsVerticallyHandler = react.exports.useCallback(() => {
    dispatch({
      type: SET_SPECTRUMS_VERTICAL_ALIGN
    });
  }, [dispatch]);
  return {
    handleChangeOption,
    handleFullZoomOut,
    changeDisplayViewModeHandler,
    changeSpectrumViewHandler,
    alignSpectrumsVerticallyHandler,
    isRealSpectrumShown
  };
}
function KeysListenerTracker() {
  const {
    keysPreferences,
    displayerMode,
    overDisplayer,
    data,
    activeSpectrum
  } = useChartData();
  const dispatch = useDispatch();
  const alert2 = useAlert();
  const openLoader = useLoader();
  const {
    handleChangeOption,
    handleFullZoomOut,
    alignSpectrumsVerticallyHandler,
    changeDisplayViewModeHandler
  } = useToolsFunctions();
  const {
    saveToClipboardHandler,
    saveAsJSONHandler,
    saveAsHandler
  } = useExport();
  const {
    highlight,
    remove
  } = useHighlightData();
  const assignmentData = useAssignmentData();
  const allow1DTool = react.exports.useMemo(() => {
    return displayerMode === DISPLAYER_MODE.DM_1D && data && data.length > 0;
  }, [data, displayerMode]);
  const deleteHandler = react.exports.useCallback(async (sourceData) => {
    const {
      type,
      extra: {
        id: id2
      }
    } = sourceData;
    switch (type) {
      case HighlightedSource.INTEGRAL: {
        dispatch({
          type: DELETE_INTEGRAL,
          integralID: id2
        });
        remove();
        break;
      }
      case HighlightedSource.PEAK: {
        dispatch({
          type: DELETE_PEAK_NOTATION,
          data: {
            id: id2
          }
        });
        remove();
        break;
      }
      case HighlightedSource.RANGE: {
        dispatch({
          type: DELETE_RANGE,
          payload: {
            data: {
              id: id2,
              assignmentData
            }
          }
        });
        remove();
        break;
      }
      case HighlightedSource.ZONE: {
        dispatch({
          type: DELETE_2D_ZONE,
          payload: {
            id: id2,
            assignmentData
          }
        });
        remove();
        break;
      }
      case HighlightedSource.EXCLUSION_ZONE: {
        const hideLoading = await alert2.showLoading(`Exclusion filter in progress`);
        dispatch({
          type: DELETE_EXCLUSION_ZONE,
          payload: {
            id: id2,
            spectrumID: sourceData.extra.spectrumID
          }
        });
        hideLoading();
        remove();
        break;
      }
    }
  }, [assignmentData, dispatch, remove, alert2]);
  const keysPreferencesListenerHandler = react.exports.useCallback((e2, num) => {
    if (data && data.length > 0 && num >= 1 && num <= 9) {
      if (e2.shiftKey) {
        dispatch({
          type: SET_KEY_PREFERENCES,
          keyCode: num
        });
        alert2.show(`Configuration Reset, press '${num}' again to reload it.`);
      } else {
        if (!checkModifierKeyActivated(e2)) {
          if (keysPreferences == null ? void 0 : keysPreferences[num]) {
            dispatch({
              type: APPLY_KEY_PREFERENCES,
              keyCode: num
            });
          } else {
            dispatch({
              type: SET_KEY_PREFERENCES,
              keyCode: num
            });
            alert2.show(`Configuration saved, press '${num}' again to reload it.`);
          }
        }
      }
    }
  }, [alert2, data, dispatch, keysPreferences]);
  const toolsListenerHandler = react.exports.useCallback((e2) => {
    function check1DModeWithActiveSpectrum(label, checkSwitch = true) {
      if (displayerMode === DISPLAYER_MODE.DM_1D && !activeSpectrum) {
        throw new Error(`Select a spectrum to proceed with ${label}`);
      } else if (checkSwitch && displayerMode === DISPLAYER_MODE.DM_2D) {
        throw new Error(`Switch to 1D Mode and select a spectrum to proceed with ${label}`);
      }
    }
    function check2DModeWithActiveSpectrum(label, checkSwitch = true) {
      if (displayerMode === DISPLAYER_MODE.DM_2D && !activeSpectrum) {
        throw new Error(`Select a spectrum to proceed with ${label}`);
      } else if (checkSwitch && displayerMode === DISPLAYER_MODE.DM_1D) {
        throw new Error(`Switch to 2D Mode and select a spectrum to proceed with ${label}`);
      }
    }
    try {
      if (!e2.shiftKey && !e2.metaKey) {
        switch (e2.key) {
          case "f":
            handleFullZoomOut();
            break;
          case "z":
          case "Escape":
            handleChangeOption(options.zoom.id);
            break;
          case "r": {
            if (displayerMode === DISPLAYER_MODE.DM_2D) {
              check2DModeWithActiveSpectrum(options.zone2D.label, false);
              handleChangeOption(options.zone2D.id);
            } else {
              check1DModeWithActiveSpectrum(options.rangesPicking.label, false);
              handleChangeOption(options.rangesPicking.id);
            }
            break;
          }
          case "a": {
            check1DModeWithActiveSpectrum(options.phaseCorrection.label);
            handleChangeOption(options.phaseCorrection.id);
            break;
          }
          case "b": {
            check1DModeWithActiveSpectrum(options.baseLineCorrection.label);
            handleChangeOption(options.baseLineCorrection.id);
            break;
          }
          case "p": {
            check1DModeWithActiveSpectrum(options.peakPicking.label);
            handleChangeOption(options.peakPicking.id);
            break;
          }
          case "i": {
            check1DModeWithActiveSpectrum(options.integral.label);
            handleChangeOption(options.integral.id);
            break;
          }
          case "e": {
            check1DModeWithActiveSpectrum(options.exclusionZones.label);
            handleChangeOption(options.exclusionZones.id);
            break;
          }
          default:
        }
      }
      if (!e2.shiftKey && !e2.metaKey && !e2.ctrlKey) {
        switch (e2.key) {
          case "c": {
            if (allow1DTool) {
              alignSpectrumsVerticallyHandler();
            }
            break;
          }
          case "s": {
            if (allow1DTool) {
              changeDisplayViewModeHandler();
            }
            break;
          }
          default:
        }
      }
      if (!e2.shiftKey && (e2.metaKey || e2.ctrlKey)) {
        switch (e2.key) {
          case "c":
            void saveToClipboardHandler();
            e2.preventDefault();
            break;
          case "s":
            void saveAsJSONHandler();
            e2.preventDefault();
            break;
          case "o":
            openLoader();
            e2.preventDefault();
            break;
          default:
        }
      }
      if (e2.shiftKey && (e2.metaKey || e2.ctrlKey)) {
        switch (e2.key) {
          case "s":
          case "S":
            void saveAsHandler();
            e2.preventDefault();
            break;
          default:
        }
      }
    } catch (e22) {
      alert2.error(e22.message);
    }
  }, [activeSpectrum, alert2, alignSpectrumsVerticallyHandler, allow1DTool, changeDisplayViewModeHandler, displayerMode, handleChangeOption, handleFullZoomOut, openLoader, saveAsHandler, saveAsJSONHandler, saveToClipboardHandler]);
  function checkNotInputField(e2) {
    const tags2 = ["input", "textarea"];
    const tagName = e2.composedPath()[0].tagName.toLowerCase();
    if (!tags2.includes(tagName))
      return true;
    return false;
  }
  const handleOnKeyDown = react.exports.useCallback((e2) => {
    if (checkNotInputField(e2) && overDisplayer) {
      const num = Number(e2.code.substr(e2.code.length - 1)) || 0;
      if (num > 0) {
        keysPreferencesListenerHandler(e2, num);
      } else {
        if (["Delete", "Backspace"].includes(e2.key) && highlight.sourceData) {
          e2.preventDefault();
          void deleteHandler(highlight.sourceData);
        } else {
          toolsListenerHandler(e2);
        }
      }
    }
  }, [deleteHandler, highlight, keysPreferencesListenerHandler, overDisplayer, toolsListenerHandler]);
  react.exports.useEffect(() => {
    document.addEventListener("keydown", handleOnKeyDown);
    return () => document.removeEventListener("keydown", handleOnKeyDown);
  }, [handleOnKeyDown]);
  return null;
}
function SplitPaneWrapper({
  children
}) {
  var _a, _b, _c, _d;
  const {
    current
  } = usePreferences();
  return /* @__PURE__ */ jsx$1(SplitPane, {
    initialSeparation: "590px",
    orientation: "horizontal",
    sideSeparation: "end",
    initialClosed: ((_b = (_a = current == null ? void 0 : current.display) == null ? void 0 : _a.general) == null ? void 0 : _b.hidePanelOnLoad) || false,
    children
  }, ((_d = (_c = current == null ? void 0 : current.display) == null ? void 0 : _c.general) == null ? void 0 : _d.hidePanelOnLoad) ? "true" : "false");
}
function initAssignment(action) {
  const newState = __spreadValues({}, assignmentState);
  const spectra = action.payload.spectra || [];
  for (const spectrum of spectra) {
    if (isSpectrum1D(spectrum)) {
      setRangesAssignments(newState, spectrum.ranges);
    } else {
      setZonesAssignments(newState, spectrum.zones);
    }
  }
  return newState;
}
function setRangesAssignments(state, ranges) {
  const diaIDRecords = ranges.values.reduce((acc, { id: id2, diaIDs, signals }) => {
    acc.push({ id: id2, diaIDs: diaIDs || [] });
    for (const signal of signals) {
      acc.push({ id: signal.id, diaIDs: signal.diaIDs || [] });
    }
    return acc;
  }, []);
  for (const { id: id2, diaIDs } of diaIDRecords) {
    for (const diaID of diaIDs) {
      setAssignment(state, id2, "x", diaID);
    }
  }
}
function setZonesAssignments(state, zones) {
  const diaIDRecords = zones.values.reduce((acc, { id: id2, x, y, signals }) => {
    acc.push({ id: id2, diaIDs: { x: x.diaIDs || [], y: y.diaIDs || [] } });
    for (const signal of signals) {
      acc.push({
        id: signal.id,
        diaIDs: { x: signal.x.diaIDs || [], y: signal.y.diaIDs || [] }
      });
    }
    return acc;
  }, []);
  for (const { id: id2, diaIDs } of diaIDRecords) {
    ["x", "y"].forEach((axis) => {
      for (const diaID of diaIDs[axis]) {
        setAssignment(state, id2, axis, diaID);
      }
    });
  }
}
function setAssignment(state, id2, axis, diaID) {
  var _a, _b;
  if (Array.isArray((_b = (_a = state.assignments) == null ? void 0 : _a[id2]) == null ? void 0 : _b[axis]) && !state.assignments[id2][axis].includes(diaID)) {
    state.assignments[id2][axis].push(diaID);
  } else {
    state.assignments = __spreadProps(__spreadValues({}, state.assignments), {
      [id2]: __spreadProps(__spreadValues({}, state.assignments[id2]), { [axis]: [diaID] })
    });
  }
}
function removeAssignment(state, options2) {
  var _a, _b;
  const { id: id2, atomID = "", axis } = options2;
  const atomIDs = ((_b = (_a = state.assignments) == null ? void 0 : _a[id2]) == null ? void 0 : _b[axis]) || null;
  if (atomIDs) {
    if (atomID) {
      atomIDs.filter((id22) => id22 !== atomID);
      state.assignments[id2][axis] = atomIDs;
    } else {
      state.assignments[id2][axis] = [];
    }
  }
}
function removeAssignments(state, action) {
  const newState = __spreadValues({}, state);
  const { ids, atomID = "", axis } = action;
  for (const id2 of ids) {
    removeAssignment(newState, { id: id2, atomID, axis });
  }
  return newState;
}
function setActiveAssignment(state, action) {
  var _a;
  let { id: id2, axis } = action.payload;
  const isActive = ((_a = state.activated) == null ? void 0 : _a.id) === id2;
  return __spreadProps(__spreadValues({}, state), {
    activated: !isActive ? { id: id2, axis: axis || null } : null
  });
}
function addAssignment(state, action) {
  var _a;
  const { id: id2, atomID, axis, dimension } = action;
  const assignment = ((_a = state.assignments) == null ? void 0 : _a[id2]) || null;
  const axisAssignments = (assignment == null ? void 0 : assignment[axis]) || null;
  if (axisAssignments) {
    if (!axisAssignments.includes(id2)) {
      axisAssignments.push(atomID);
    }
  } else {
    const otherAxis = axis === "x" ? "y" : "x";
    state.assignments = __spreadProps(__spreadValues({}, state.assignments), {
      [id2]: __spreadValues(__spreadProps(__spreadValues({}, state.assignments[id2]), {
        [axis]: [atomID]
      }), dimension === "2D" && {
        [otherAxis]: (assignment == null ? void 0 : assignment[otherAxis]) ? assignment[otherAxis] : []
      })
    });
  }
}
function ToggleAssignments(state, action) {
  var _a, _b, _c;
  const newState = __spreadValues({}, state);
  const { id: id2, atomIDs: atomsKeys, dimension } = action.payload;
  const axis = (_a = state.activated) == null ? void 0 : _a.axis;
  if (axis) {
    const atomIDs = ((_c = (_b = state.assignments) == null ? void 0 : _b[id2]) == null ? void 0 : _c[axis]) || [];
    for (const atomID of atomsKeys) {
      if (!atomIDs.includes(id2)) {
        addAssignment(newState, { axis, id: id2, atomID, dimension });
      } else {
        removeAssignment(newState, { atomID, axis, id: id2 });
      }
    }
  }
  return newState;
}
function assignmentReducer(state, action) {
  switch (action.type) {
    case "INITIATE_ASSIGNMENTS": {
      return initAssignment(action);
    }
    case "REMOVE": {
      const { axis, ids, atomID } = action.payload;
      return removeAssignments(state, { axis, ids, atomID });
    }
    case "TOGGLE": {
      return ToggleAssignments(state, action);
    }
    case "SET_ACTIVE": {
      return setActiveAssignment(state, action);
    }
    case "SHOW": {
      const { id: id2, axis } = action.payload;
      return __spreadProps(__spreadValues({}, state), {
        highlighted: {
          id: id2,
          axis: axis || null
        }
      });
    }
    case "HIDE": {
      return __spreadProps(__spreadValues({}, state), {
        highlighted: null
      });
    }
    default:
      return state;
  }
}
function AssignmentProvider(props) {
  const {
    spectraData: spectra
  } = props;
  const [data, dispatch] = react.exports.useReducer(assignmentReducer, assignmentState);
  const state = react.exports.useMemo(() => ({
    data,
    dispatch
  }), [data]);
  react.exports.useEffect(() => {
    if (spectra) {
      dispatch({
        type: "INITIATE_ASSIGNMENTS",
        payload: {
          spectra
        }
      });
    }
  }, [spectra]);
  return /* @__PURE__ */ jsx$1(assignmentContext.Provider, {
    value: state,
    children: props.children
  });
}
const docsBaseUrl = "https://docs.nmrium.org";
var versionInfo = { version: "git-6e293a81de73bcd3f681ac3f59e404b48f7934bc" };
function Logo({
  width = 100,
  height = 100
}) {
  return /* @__PURE__ */ jsxs$1("svg", {
    style: {
      width,
      height
    },
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 752.34 221.73",
    children: [/* @__PURE__ */ jsx$1("path", {
      fill: "#ea580c",
      fillRule: "evenodd",
      d: "M.64,31.7A31.67,31.67,0,0,1,54.72,9.29l0,0A31.66,31.66,0,0,1,64,31.7V190a13.39,13.39,0,0,0,26.77,0V54a31.7,31.7,0,0,1,31.7-31.7V40.58A13.38,13.38,0,0,0,109.13,54V190a31.71,31.71,0,0,1-63.41,0V31.7a13.29,13.29,0,0,0-3.88-9.46l0,0A13.41,13.41,0,0,0,19,31.7V164.82H.64Z"
    }), /* @__PURE__ */ jsx$1("path", {
      fill: "#2b143e",
      fillRule: "evenodd",
      d: "M154.21,54v68.17a13.34,13.34,0,0,0,3.89,9.47h0A13.39,13.39,0,0,0,181,122.14V99.32h-.06a31.63,31.63,0,0,1,9.29-22.38l0,0a31.65,31.65,0,0,1,44.8,0l0,0a31.58,31.58,0,0,1,9.3,22.39V118H226V99.32a13.3,13.3,0,0,0-3.89-9.46h0a13.44,13.44,0,0,0-18.93,0l0,0a13.3,13.3,0,0,0-3.83,8.19v24.09a31.7,31.7,0,0,1-54.11,22.42v0a31.66,31.66,0,0,1-9.3-22.4V54Z"
    }), /* @__PURE__ */ jsx$1("path", {
      fill: "#2b143e",
      fillRule: "evenodd",
      d: "M729.19,96.34c-8.65,0-14.26,3.17-17.67,8-3.41-5.12-8.78-8-16-8-8.16,0-13.52,3.17-16.32,7.31v-5.6H661V159h18.28V124.62c0-7.19,3.41-11.46,9.5-11.46,5.85,0,8.78,3.9,8.78,10V159h18.27V124.62c0-7.19,3.42-11.46,9.51-11.46,5.85,0,8.77,3.9,8.77,10V159h18.28V121.57C752.34,106.33,743.2,96.34,729.19,96.34Z"
    }), /* @__PURE__ */ jsx$1("path", {
      fill: "#2b143e",
      fillRule: "evenodd",
      d: "M629.26,98.05v33.26c0,8.66-4.63,12.56-11.33,12.56-5.85,0-10.6-3.54-10.6-11.09V98.05H589.05v37.41c0,16.45,10.48,25.22,22.79,25.22,8,0,14.13-2.92,17.42-7.43V159h18.28V98.05Z"
    }), /* @__PURE__ */ jsx$1("rect", {
      fill: "#2b143e",
      x: "558.22",
      y: "98.05",
      width: "18.28",
      height: "60.93"
    }), /* @__PURE__ */ jsx$1("path", {
      fill: "#2b143e",
      fillRule: "evenodd",
      d: "M567.36,92.68a11,11,0,1,0-11-11A11.08,11.08,0,0,0,567.36,92.68Z"
    }), /* @__PURE__ */ jsx$1("path", {
      fill: "#ea580c",
      fillRule: "evenodd",
      d: "M478.77,159H498V116.57L525.66,159H549.2l-22.3-34.75c5.45-2.13,8.12-4.14,11.48-8.86a31.07,31.07,0,0,0,6.07-18.26V94.62c0-10.61-3.45-15.93-9.28-21.78S520.75,63.09,510,63.09H478.71l.06,95.89Zm33.1-50.27h-6.46v-.06H498V82.19h10.87c4.67,0,9.44,1.38,11.94,3.81a12.84,12.84,0,0,1,3.81,9.2C524.58,102.52,518.92,108.71,511.87,108.71Z"
    }), /* @__PURE__ */ jsx$1("polygon", {
      fill: "#ea580c",
      fillRule: "evenodd",
      points: "372.91 60.8 372.91 158.98 392.16 158.98 392.16 119.23 419.91 157.41 447.61 119.23 447.61 158.98 466.87 158.98 466.87 60.8 419.91 125.22 372.91 60.8"
    }), /* @__PURE__ */ jsx$1("polygon", {
      fill: "#ea580c",
      fillRule: "evenodd",
      points: "283.89 61.04 283.89 159.1 303.14 159.1 303.14 105.85 361.01 160.93 361.01 62.83 341.67 62.83 341.67 116.08 283.89 61.04"
    })]
  });
}
const styles$c = css`
  display: flex;
  flex-direction: column;
  user-select:
  button:focus {
    outline: none;
  }
  .header {
    height: 34px;
    border-bottom: 1px solid #f0f0f0;
    display: flex;
    padding: 5px;

    span {
      color: #464646;
      font-size: 15px;
      flex: 1;
      user-select: none;

    }

    button {
      background-color: transparent;
      border: none;
      svg {
        height: 16px;
      }
    }
  }
  .container {
    width: 100%;
    height: 100%;
    padding: 20px;
  }

  .center-container {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  ul {
    list-style-type: disc;
    margin-left:20px;
    }
  span,li{
    user-select: text;
  }
  span.title {
    font-weight: bold;
    color: #ea580c;
  }
  span.content {
    color: #2b143e;
    font-size: 14px;
    text-align: left;
  }

  img {
    width: 100px;
  }

  a {
    color: #969696;
  }

  a:hover,
  a:focus {
    color: #00bcd4;
  }

  .separator {
    border-bottom: 1px solid gray;
    width: 15px;
    height: 1px;
    margin: 10px 0px;
  }
`;
function AboutUsModal({
  onClose = () => null
}) {
  return /* @__PURE__ */ jsxs("div", {
    css: styles$c,
    children: [/* @__PURE__ */ jsxs("div", {
      className: "header handle",
      children: [/* @__PURE__ */ jsx("span", {
        children: "About NMRium"
      }), /* @__PURE__ */ jsx(CloseButton$1, {
        onClick: onClose
      })]
    }), /* @__PURE__ */ jsxs("div", {
      className: "container",
      children: [/* @__PURE__ */ jsxs("div", {
        className: "center-container",
        children: [/* @__PURE__ */ jsx(Logo, {
          width: 160,
          height: 50
        }), "Version ", /* @__PURE__ */ jsx(VersionInfo, {}), /* @__PURE__ */ jsx("span", {
          className: "separator"
        }), /* @__PURE__ */ jsx("a", {
          href: "https://git.nmrium.org",
          target: "_blank",
          rel: "noreferrer",
          children: "GitHub ( https://git.nmrium.org )"
        })]
      }), /* @__PURE__ */ jsx("div", {
        className: "center-container",
        children: /* @__PURE__ */ jsx("span", {
          className: "separator"
        })
      }), /* @__PURE__ */ jsx("span", {
        className: "content",
        children: "This project is developed by Zakodium S\xE0rl (Switzerland), the University of Cologne (Germany), Johannes Gutenberg University Mainz (Germany) and Universidad del Valle (Colombia)."
      }), /* @__PURE__ */ jsxs("div", {
        className: "center-container",
        children: [/* @__PURE__ */ jsx("span", {
          className: "separator"
        }), /* @__PURE__ */ jsx("span", {
          className: "title",
          children: "Funding is provided by"
        }), /* @__PURE__ */ jsx("span", {
          className: "separator"
        })]
      }), /* @__PURE__ */ jsx("div", {
        className: "content",
        children: /* @__PURE__ */ jsxs("ul", {
          children: [/* @__PURE__ */ jsx("li", {
            children: "IDNMR grant, which part of the Scientific Library Services and Information Systems (LIS) initiative of the DFG."
          }), /* @__PURE__ */ jsx("li", {
            children: "Zakodium S\xE0rl (Switzerland)."
          }), /* @__PURE__ */ jsx("li", {
            children: "Universidad del Valle (Cali, Colombia)."
          })]
        })
      })]
    })]
  });
}
function VersionInfo() {
  const {
    version
  } = versionInfo;
  if (version === "HEAD") {
    return /* @__PURE__ */ jsx(Fragment, {
      children: "HEAD"
    });
  } else if (version.startsWith("git-")) {
    return /* @__PURE__ */ jsxs("a", {
      href: `https://github.com/cheminfo/nmrium/tree/${version.slice(4)}`,
      target: "_blank",
      rel: "noreferrer",
      children: ["git-", version.slice(4, 14)]
    });
  } else {
    return /* @__PURE__ */ jsx("a", {
      href: `https://github.com/cheminfo/nmrium/tree/${version}`,
      target: "_blank",
      rel: "noreferrer",
      children: version
    });
  }
}
function ControllersTabContent() {
  return /* @__PURE__ */ jsxs$1(Fragment$1, {
    children: [/* @__PURE__ */ jsx$1("p", {
      className: "section-header",
      children: "Spectra"
    }), /* @__PURE__ */ jsx$1(Label, {
      title: "Transparency of Dimmed Spectra [ 0 - 1 ]",
      children: /* @__PURE__ */ jsx$1(FormikInput, {
        name: "controllers.dimmedSpectraTransparency",
        checkValue: (value) => value >= 0 && value <= 1,
        type: "number"
      })
    })]
  });
}
const style$1 = {
  addButton: css`
    background-color: transparent;
    border: 0;
    outline: none;
    margin-left: 5px;
    svg {
      font-size: 14px;
      fill: green;
    }
  `,
  table: {
    width: "100%"
  },
  th: {
    fontSize: "12px"
  },
  input: {
    input: {
      width: "100%"
    }
  },
  labelCol: {
    width: "30%"
  },
  serialCol: {
    width: "5%"
  }
};
function DatabasesTabContent({
  currentWorkspace
}) {
  const {
    values,
    setFieldValue
  } = useFormikContext();
  const databases2 = react.exports.useMemo(() => get_1(values, "databases", []), [values]);
  const deleteHandler = react.exports.useCallback((index2) => {
    const _database = databases2.slice();
    _database.splice(index2, 1);
    setFieldValue("databases", _database);
  }, [databases2, setFieldValue]);
  const addNewDatabaseHandler = react.exports.useCallback(() => {
    const newDatabase = {
      label: "",
      url: "",
      enabled: true
    };
    setFieldValue("databases", [...databases2, newDatabase]);
  }, [databases2, setFieldValue]);
  const resetDatabaseHandler = react.exports.useCallback(() => {
    var _a;
    const database = ((_a = workspaces == null ? void 0 : workspaces[currentWorkspace]) == null ? void 0 : _a.databases) || workspaces.default.databases;
    setFieldValue("databases", database);
  }, [currentWorkspace, setFieldValue]);
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [/* @__PURE__ */ jsxs("div", {
      className: "section-header",
      style: {
        display: "flex"
      },
      children: [/* @__PURE__ */ jsx("p", {
        style: {
          flex: 1
        },
        children: "Databases"
      }), /* @__PURE__ */ jsxs("div", {
        style: {
          display: "flex",
          justifyContent: "space-between"
        },
        children: [/* @__PURE__ */ jsx(Button.Danger, {
          fill: "clear",
          size: "xSmall",
          onClick: resetDatabaseHandler,
          style: {
            margin: "0 5px"
          },
          children: "Reset Databases"
        }), /* @__PURE__ */ jsx(Button.Done, {
          fill: "outline",
          size: "xSmall",
          onClick: addNewDatabaseHandler,
          children: "Add Database"
        })]
      })]
    }), /* @__PURE__ */ jsx("div", {
      children: /* @__PURE__ */ jsxs("table", {
        style: style$1.table,
        children: [/* @__PURE__ */ jsx("thead", {
          children: /* @__PURE__ */ jsxs("tr", {
            children: [/* @__PURE__ */ jsx("th", {
              style: style$1.th,
              children: "#"
            }), /* @__PURE__ */ jsx("th", {
              style: style$1.th,
              children: "Label "
            }), /* @__PURE__ */ jsx("th", {
              style: style$1.th,
              children: "URL"
            }), /* @__PURE__ */ jsx("th", {
              style: style$1.th,
              children: "Enabled"
            }), /* @__PURE__ */ jsx("th", {})]
          })
        }), /* @__PURE__ */ jsx("tbody", {
          children: databases2 == null ? void 0 : databases2.map((item, index2) => {
            const num = index2 + 1;
            return /* @__PURE__ */ jsxs("tr", {
              style: {
                height: "33px"
              },
              children: [/* @__PURE__ */ jsxs("td", {
                style: style$1.serialCol,
                children: [/* @__PURE__ */ jsx("span", {
                  children: num
                }), " "]
              }), /* @__PURE__ */ jsx("td", {
                style: style$1.labelCol,
                children: /* @__PURE__ */ jsx(FormikInput, {
                  style: style$1.input,
                  name: `databases.${index2}.label`,
                  checkErrorAfterInputTouched: false
                })
              }), /* @__PURE__ */ jsx("td", {
                children: /* @__PURE__ */ jsx(FormikInput, {
                  style: style$1.input,
                  name: `databases.${index2}.url`,
                  checkErrorAfterInputTouched: false
                })
              }), /* @__PURE__ */ jsx("td", {
                children: /* @__PURE__ */ jsx(FormikCheckBox, {
                  style: {
                    container: {
                      display: "block",
                      margin: "0 auto",
                      width: "fit-content"
                    }
                  },
                  className: "checkbox-element",
                  name: `databases.${index2}.enabled`
                })
              }), /* @__PURE__ */ jsx("td", {
                children: /* @__PURE__ */ jsxs("div", {
                  style: {
                    display: "flex",
                    height: "100%"
                  },
                  children: [/* @__PURE__ */ jsx(Button.Danger, {
                    style: {
                      fontSize: "14px"
                    },
                    fill: "clear",
                    onClick: () => deleteHandler(index2),
                    children: /* @__PURE__ */ jsx(FaTimes, {})
                  }), databases2.length === index2 + 1 && /* @__PURE__ */ jsx(Button.Done, {
                    fill: "clear",
                    style: {
                      fontSize: "14px"
                    },
                    onClick: addNewDatabaseHandler,
                    children: /* @__PURE__ */ jsx(FaPlus, {})
                  })]
                })
              })]
            }, `${index2}`);
          })
        })]
      })
    })]
  });
}
const LIST = [{
  label: "Spectra selection panel",
  name: "panels.spectraPanel"
}, {
  label: "Spectra information Panel",
  name: "panels.informationPanel"
}, {
  label: "Peaks and peak picking",
  name: "panels.peaksPanel"
}, {
  label: "Integration and integrals",
  name: "panels.integralsPanel"
}, {
  label: "1D ranges peak picking",
  name: "panels.rangesPanel"
}, {
  label: "Chemical structure panel",
  name: "panels.structuresPanel"
}, {
  label: "Filters Panel",
  name: "panels.filtersPanel"
}, {
  label: "2D zones peak picking",
  name: "panels.zonesPanel"
}, {
  label: "Assignment summary Panel",
  name: "panels.summaryPanel"
}, {
  label: "Multiple Spectra Analysis Panel",
  name: "panels.multipleSpectraAnalysisPanel"
}, {
  label: "Databases Panel",
  name: "panels.databasePanel"
}, {
  label: "Prediction Panel",
  name: "panels.predictionPanel"
}, {
  label: "Experimental Features",
  name: "general.experimentalFeatures",
  hideOpenOption: true
}];
function CheckBoxCell(props) {
  return /* @__PURE__ */ jsx$1(FormikCheckBox, {
    style: {
      container: {
        display: "block",
        margin: "0 auto",
        width: "fit-content"
      }
    },
    className: "checkbox-element",
    name: props.name
  }, props.name);
}
function DisplayTabContent({
  preferences
}) {
  const COLUMNS2 = react.exports.useMemo(() => [{
    index: 1,
    Header: "#",
    Cell: ({
      row
    }) => row.index + 1
  }, {
    index: 1,
    Header: "Feature",
    accessor: "label",
    style: {
      width: "60%"
    }
  }, {
    index: 2,
    Header: "Active",
    Cell: ({
      row
    }) => /* @__PURE__ */ jsx$1(CheckBoxCell, {
      name: `display.${row.original.name}.display`
    })
  }, {
    index: 3,
    Header: "Open on load",
    Cell: ({
      row
    }) => !row.original.hideOpenOption ? /* @__PURE__ */ jsx$1(CheckBoxCell, {
      name: `display.${row.original.name}.open`
    }) : /* @__PURE__ */ jsx$1("div", {})
  }], []);
  const data = react.exports.useMemo(() => {
    return LIST.filter((item) => get_1(preferences, `${item.name}.hidden`) !== true);
  }, [preferences]);
  return /* @__PURE__ */ jsx$1("div", {
    style: {
      width: "100%",
      overflow: "hidden"
    },
    children: /* @__PURE__ */ jsx$1(ReactTable$1, {
      columns: COLUMNS2,
      data
    })
  });
}
const styles$b = css`
  .counter-col {
    width: 30px;
  }
  .nucleus-label-col {
    display: flex;
    justify-content: center;
    width: 80px;
  }

  .input {
    width: 100% !important;
    margin: 0px !important;
  }

  .nucleus-format-input-col {
    text-align: center;
    width: 100px;
  }

  th {
    font-size: 11px;
    font-weight: 600;
  }
  .operation-container {
    display: flex;
  }
  .add {
    background-color: transparent;
    border: 0;
    outline: none;
    svg {
      font-szie: 14px;
      fill: green;
    }
  }
`;
function FormattingTabContent() {
  const {
    values,
    setFieldValue
  } = useFormikContext();
  const nuclei = react.exports.useMemo(() => get_1(values, "formatting.nuclei", {}), [values]);
  const deleteHandler = react.exports.useCallback((key) => {
    let _nuclei = {};
    for (const nucleus in nuclei) {
      if (nucleus !== key) {
        _nuclei[nucleus] = nuclei[nucleus];
      }
    }
    setFieldValue("formatting.nuclei", _nuclei);
  }, [nuclei, setFieldValue]);
  const addNewNucleusFormatHandler = react.exports.useCallback(() => {
    const newFormat = {
      name: "",
      ppm: "0.00",
      hz: "0.00"
    };
    const key = generateID();
    const newNuclei = __spreadProps(__spreadValues({}, nuclei), {
      [key]: newFormat
    });
    setFieldValue("formatting.nuclei", newNuclei);
  }, [nuclei, setFieldValue]);
  const nucleiList = Object.keys(nuclei);
  return /* @__PURE__ */ jsxs(react.exports.Fragment, {
    children: [/* @__PURE__ */ jsx("p", {
      className: "section-header",
      children: "Nuclei Formatting"
    }), /* @__PURE__ */ jsx("div", {
      css: styles$b,
      children: /* @__PURE__ */ jsxs("table", {
        children: [/* @__PURE__ */ jsx("thead", {
          children: /* @__PURE__ */ jsxs("tr", {
            children: [/* @__PURE__ */ jsx("th", {
              className: "counter-col",
              children: "#"
            }), /* @__PURE__ */ jsx("th", {
              className: "nucleus-label-col",
              children: "Nucleus "
            }), /* @__PURE__ */ jsx("th", {
              className: "nucleus-format-input-col",
              children: "\u03B4 (ppm)"
            }), /* @__PURE__ */ jsx("th", {
              className: "nucleus-format-input-col",
              children: "Coupling (Hz)"
            }), /* @__PURE__ */ jsx("th", {
              className: "nucleus-format-input-col"
            })]
          })
        }), /* @__PURE__ */ jsx("tbody", {
          children: nucleiList == null ? void 0 : nucleiList.map((key, index2) => {
            const num = index2 + 1;
            return /* @__PURE__ */ jsxs("tr", {
              children: [/* @__PURE__ */ jsxs("td", {
                className: "counter-col",
                children: [/* @__PURE__ */ jsxs("span", {
                  children: [num, " - "]
                }), " "]
              }), /* @__PURE__ */ jsx("td", {
                className: "nucleus-label-col",
                children: /* @__PURE__ */ jsx(FormikInput, {
                  name: `formatting.nuclei.${key}.name`,
                  className: "input",
                  checkErrorAfterInputTouched: false
                })
              }), /* @__PURE__ */ jsx("td", {
                className: "nucleus-format-input-col",
                children: /* @__PURE__ */ jsx(FormikInput, {
                  name: `formatting.nuclei.${key}.ppm`,
                  className: "input"
                })
              }), /* @__PURE__ */ jsx("td", {
                className: "nucleus-format-input-col",
                children: /* @__PURE__ */ jsx(FormikInput, {
                  name: `formatting.nuclei.${key}.hz`,
                  className: "input"
                })
              }), /* @__PURE__ */ jsxs("td", {
                className: "operation-container",
                children: [/* @__PURE__ */ jsx(Button.Danger, {
                  style: {
                    fontSize: "14px"
                  },
                  fill: "clear",
                  onClick: () => deleteHandler(key),
                  children: /* @__PURE__ */ jsx(FaTimes, {})
                }), nucleiList.length === index2 + 1 && /* @__PURE__ */ jsx(Button.Done, {
                  fill: "clear",
                  style: {
                    fontSize: "14px"
                  },
                  onClick: addNewNucleusFormatHandler,
                  children: /* @__PURE__ */ jsx(FaPlus, {})
                })]
              })]
            }, `${key}`);
          })
        })]
      })
    })]
  });
}
const styles$a = css`
  .container {
    display: flex;
    span {
      padding: 5px !important;
    }
    span {
      flex: 1;
      text-align: left !important;
    }
  }

  .new-container {
    background-color: #f6f6f6;
    display: flex;
    padding: 0.3em;

    input {
      padding: 0.5em;
      color: black;
      outline: none;
      background-color: transparent !important;
    }
  }

  .delete-button:hover {
    color: white;
  }

  .save-button:hover {
    color: green;
  }
  .delete-button,
  .save-button {
    padding: 5px;
  }
`;
const WorkspaceItem = ({
  item,
  onSave,
  onDelete
}) => {
  const [name2, setName] = react.exports.useState("");
  const addWorkspaceHandler = react.exports.useCallback((e2) => {
    e2.stopPropagation();
    setName("");
    onSave(name2);
  }, [name2, onSave]);
  const deleteWorkspaceHandler = react.exports.useCallback((e2) => {
    e2.stopPropagation();
    onDelete(item.key);
  }, [item.key, onDelete]);
  const onTextChange = react.exports.useCallback((e2) => {
    setName(e2.target.value);
  }, []);
  return /* @__PURE__ */ jsx("div", {
    css: styles$a,
    children: item.key === "new" ? /* @__PURE__ */ jsxs("div", {
      className: "new-container",
      children: [/* @__PURE__ */ jsx("input", {
        value: name2,
        placeholder: "Custom workspace",
        onClick: (e2) => e2.stopPropagation(),
        onChange: onTextChange
      }), /* @__PURE__ */ jsx("button", {
        type: "button",
        className: "save-button",
        onClick: addWorkspaceHandler,
        disabled: !name2,
        children: "save"
      })]
    }) : /* @__PURE__ */ jsxs("div", {
      className: "container",
      children: [/* @__PURE__ */ jsx("span", {
        children: item.label
      }), !workspaces[item.key] && /* @__PURE__ */ jsx("button", {
        type: "button",
        className: "delete-button",
        onClick: deleteWorkspaceHandler,
        children: "Delete"
      })]
    })
  });
};
const formattingElementValidation = (obj) => Object.keys(obj.formatting.nuclei).reduce((validate, key) => {
  validate[key] = create().shape({
    name: create$2().trim().required("Nucleus is a required field"),
    ppm: create$2().trim().required("PPM format is a required field"),
    hz: create$2().trim().required("Hz format  is a required field")
  });
  return validate;
}, {});
const formattingValidation = (obj) => create().shape({
  nuclei: create().shape(formattingElementValidation(obj)).test("Unique", "Nuclei need te be unique", function check(nuclei) {
    var _a;
    let nucleusFrequencies = {};
    for (const key of Object.keys(nuclei)) {
      const _key = ((_a = nuclei[key].name) == null ? void 0 : _a.toLowerCase()) || "";
      if (_key) {
        if (nucleusFrequencies[_key]) {
          ++nucleusFrequencies[_key].value;
          nucleusFrequencies[_key].fields.push(key);
        } else {
          nucleusFrequencies[_key] = { value: 1, fields: [key] };
        }
      }
    }
    const errors = Object.keys(nucleusFrequencies).reduce((errorList, key) => {
      const { value, fields } = nucleusFrequencies[key];
      if (value > 1) {
        for (let field of fields) {
          errorList.push(new ValidationError(`${key} nucleus must te be unique`, nuclei[key].name, `${this.path}.${field}.name`));
        }
      }
      return errorList;
    }, []);
    return new ValidationError(errors);
  })
});
const databasesValidation = create$4().of(create().shape({
  label: create$2().trim().required("Label is a required field"),
  url: create$2().trim().url().required("URL is a required field")
}));
const validation = create$6((obj) => create().shape({
  formatting: formattingValidation(obj),
  databases: databasesValidation
}));
const styles$9 = css`
  .main-content {
    width: 100%;
    flex: 1;
    overflow: auto;
    border: none;
  }

  .tab-content {
    width: 100%;
  }

  .section-header {
    font-size: 13px;
    color: #2ca8ff;
    margin-bottom: 10px;
    border-bottom: 0.55px solid #f9f9f9;
    padding: 6px 2px;
  }

  .label {
    font-size: 12px;
    font-weight: bold;
    margin-right: 10px;
  }

  .input {
    font-size: 14px;
    border-radius: 5px;
    border: 1px solid #cccccc;
    padding: 5px;
    width: 100px;
    margin-right: 10px;
    height: initial !important;
  }

  .close-bt {
    border: none;
    color: red;
    background-color: transparent;
    outline: none;
    position: absolute;
    right: 10px;
    top: 2px;
    width: 30px;
    height: 30px;
  }

  .checkbox-label {
    min-width: 300px;
    display: inline-block;
  }

  .help-checkbox-element {
    .checkbox-label {
      width: 260px;
    }
  }

  .workspace-container {
    display: flex;
    background-color: #f4f4f4;
    align-items: center;
    cursor: default;
    padding: 0.5em;
    .dropdown {
      padding: 0.4em 1em;
    }
    & .label {
      font-size: 0.8em;
    }
  }
`;
function GeneralSettings({
  onClose
}) {
  const [activeTab, setActiveTab2] = react.exports.useState("controllers");
  const _a = usePreferences(), {
    dispatch
  } = _a, preferences = __objRest(_a, [
    "dispatch"
  ]);
  const alert2 = useAlert();
  const refForm = react.exports.useRef();
  const workspaces2 = useWorkspacesList();
  const workspacesList = react.exports.useMemo(() => {
    return workspaces2.concat([{
      key: "new",
      label: "Custom workspace"
    }]);
  }, [workspaces2]);
  const handleSave = react.exports.useCallback(() => {
    refForm.current.submitForm();
  }, []);
  const handleReset = react.exports.useCallback(() => {
    dispatch({
      type: "RESET_PREFERENCES"
    });
    alert2.success("Settings saved successfully");
    onClose == null ? void 0 : onClose();
  }, [alert2, dispatch, onClose]);
  const submitHandler = react.exports.useCallback((values) => {
    dispatch({
      type: "SET_PREFERENCES",
      payload: values
    });
    alert2.success("Settings saved successfully");
    onClose == null ? void 0 : onClose();
  }, [alert2, dispatch, onClose]);
  const tabChangeHandler = react.exports.useCallback((tab) => {
    setActiveTab2(tab.tabid);
  }, []);
  const addWorkSpaceHandler = react.exports.useCallback((name2) => {
    dispatch({
      type: "ADD_WORKSPACE",
      payload: {
        workspace: name2,
        data: refForm.current.values
      }
    });
  }, [dispatch]);
  const deleteWorkSpaceHandler = react.exports.useCallback((key) => {
    dispatch({
      type: "REMOVE_WORKSPACE",
      payload: {
        workspace: key
      }
    });
  }, [dispatch]);
  const ChangeWorkspaceHandler = react.exports.useCallback((option) => {
    dispatch({
      type: "SET_WORKSPACE",
      payload: {
        workspace: option.key
      }
    });
  }, [dispatch]);
  const renderItem = react.exports.useCallback((item) => {
    return /* @__PURE__ */ jsx(WorkspaceItem, {
      item,
      onSave: addWorkSpaceHandler,
      onDelete: deleteWorkSpaceHandler
    });
  }, [addWorkSpaceHandler, deleteWorkSpaceHandler]);
  return /* @__PURE__ */ jsxs("div", {
    css: [ModalStyles, styles$9],
    children: [/* @__PURE__ */ jsxs("div", {
      className: "header handle",
      children: [/* @__PURE__ */ jsx("span", {
        children: "General Settings"
      }), /* @__PURE__ */ jsx(CloseButton$1, {
        onClick: onClose,
        className: "close-bt"
      })]
    }), /* @__PURE__ */ jsxs("div", {
      className: "workspace-container",
      children: [/* @__PURE__ */ jsx("span", {
        className: "label",
        children: "Workspace : "
      }), /* @__PURE__ */ jsx(DropDownButton, {
        data: workspacesList,
        renderItem,
        selectedKey: preferences == null ? void 0 : preferences.workspace.current,
        onSelect: ChangeWorkspaceHandler
      })]
    }), /* @__PURE__ */ jsx("div", {
      className: "main-content",
      children: /* @__PURE__ */ jsx(FormikForm, {
        ref: refForm,
        initialValues: preferences.current,
        validationSchema: validation,
        onSubmit: submitHandler,
        children: /* @__PURE__ */ jsxs(Tabs$1, {
          position: PositionsEnum.LEFT,
          activeTab,
          onClick: tabChangeHandler,
          children: [/* @__PURE__ */ jsx(Tab, {
            tablabel: "Controllers",
            tabid: "controllers",
            children: /* @__PURE__ */ jsx("div", {
              className: "inner-content",
              children: /* @__PURE__ */ jsx(ControllersTabContent, {})
            })
          }), /* @__PURE__ */ jsx(Tab, {
            tablabel: "Formatting",
            tabid: "formatting",
            children: /* @__PURE__ */ jsx("div", {
              className: "inner-content",
              children: /* @__PURE__ */ jsx(FormattingTabContent, {})
            })
          }), /* @__PURE__ */ jsx(Tab, {
            tablabel: "Display",
            tabid: "display",
            children: /* @__PURE__ */ jsx("div", {
              className: "inner-content",
              children: /* @__PURE__ */ jsx(DisplayTabContent, {
                preferences: preferences.current.display
              })
            })
          }), /* @__PURE__ */ jsx(Tab, {
            tablabel: "Databases",
            tabid: "databases",
            children: /* @__PURE__ */ jsx("div", {
              className: "inner-content",
              children: /* @__PURE__ */ jsx(DatabasesTabContent, {
                currentWorkspace: preferences.workspace.current
              })
            })
          })]
        })
      }, JSON.stringify(preferences.current))
    }), /* @__PURE__ */ jsx("div", {
      className: "footer-container",
      children: /* @__PURE__ */ jsx(ActionButtons, {
        style: {
          flexDirection: "row-reverse",
          margin: 0
        },
        onDone: handleSave,
        doneLabel: "Save",
        onCancel: handleReset,
        cancelLabel: "Reset"
      })
    })]
  });
}
const styles$8 = {
  container: {
    height: "100%",
    display: "flex",
    fontSize: "12px",
    alignItems: "center"
  },
  input: {
    width: "50px"
  },
  inputContainer: {
    flex: "2"
  },
  label: {
    flex: "5"
  }
};
function AutoPeakPickingOptionPanel() {
  const dispatch = useDispatch();
  const minMaxRatioRef = react.exports.useRef();
  const maxNumberOfPeaksRef = react.exports.useRef();
  const noiseFactor = react.exports.useRef();
  const lookNegativeRef = react.exports.useRef();
  const handleApplyFilter = react.exports.useCallback(() => {
    dispatch({
      type: AUTO_PEAK_PICKING,
      options: {
        maxNumberOfPeaks: maxNumberOfPeaksRef.current.value,
        minMaxRatio: minMaxRatioRef.current.value,
        noiseFactor: noiseFactor.current.value,
        lookNegative: lookNegativeRef.current.checked
      }
    });
  }, [dispatch]);
  return /* @__PURE__ */ jsxs$1("div", {
    style: styles$8.container,
    children: [/* @__PURE__ */ jsx$1(NumberInput, {
      ref: maxNumberOfPeaksRef,
      label: "Max Number Of Peaks:",
      name: "maxNumberOfPeaks",
      style: {
        input: styles$8.input,
        inputContainer: styles$8.inputContainer,
        label: styles$8.label
      },
      defaultValue: 50
    }), /* @__PURE__ */ jsx$1(NumberInput, {
      ref: noiseFactor,
      label: "Noise factor",
      name: "noiseFactor",
      style: {
        input: styles$8.input,
        inputContainer: styles$8.inputContainer,
        label: styles$8.label
      },
      defaultValue: 3
    }), /* @__PURE__ */ jsx$1(NumberInput, {
      ref: minMaxRatioRef,
      label: "Min Max Ratio:",
      name: "minMaxRatio",
      style: {
        input: styles$8.input,
        inputContainer: styles$8.inputContainer,
        label: styles$8.label
      },
      defaultValue: 0.1,
      step: "0.01"
    }), /* @__PURE__ */ jsxs$1("div", {
      style: {
        justifyItems: "baseline",
        marginRight: "3px"
      },
      children: [/* @__PURE__ */ jsx$1("label", {
        style: {
          marginRight: "2px",
          lineHeight: 2,
          userSelect: "none"
        },
        htmlFor: "lookNegative",
        children: "Detect Negative:"
      }), /* @__PURE__ */ jsx$1(CheckBox, {
        name: "lookNegative",
        ref: lookNegativeRef
      })]
    }), /* @__PURE__ */ jsx$1(Button.Done, {
      onClick: handleApplyFilter,
      style: {
        margin: "0 10px"
      },
      children: "Apply"
    })]
  });
}
const styles$7 = {
  container: {
    padding: "5px",
    height: "100%",
    display: "flex",
    alignItems: "center"
  },
  label: {
    lineHeight: 2,
    userSelect: "none"
  }
};
function BaseLineCorrectionPanel() {
  const dispatch = useDispatch();
  const formRef = react.exports.useRef();
  const algorithmRef = react.exports.useRef();
  const [algorithm, setAlgorithm] = react.exports.useState("polynomial");
  const handleApplyFilter = react.exports.useCallback((values) => {
    let options2 = {};
    switch (algorithm) {
      case "airpls":
        options2 = __spreadValues({
          algorithm: algorithmRef.current.value
        }, values);
        break;
      case "polynomial":
        options2 = __spreadValues({
          algorithm: algorithmRef.current.value
        }, values);
        break;
    }
    dispatch({
      type: APPLY_BASE_LINE_CORRECTION_FILTER,
      options: options2
    });
  }, [algorithm, dispatch]);
  const handleCancelFilter = react.exports.useCallback(() => {
    dispatch({
      type: RESET_SELECTED_TOOL
    });
  }, [dispatch]);
  const getAlgorithmsList = react.exports.useCallback(() => {
    return Object.keys(baselineAlgorithms).map((val) => {
      return {
        key: val,
        label: baselineAlgorithms[val],
        value: val
      };
    });
  }, []);
  const changeAlgorithmHandler = react.exports.useCallback((val) => {
    setAlgorithm(val);
  }, []);
  const formData = react.exports.useMemo(() => {
    switch (algorithm) {
      case "airpls": {
        const validation2 = create().shape({
          maxIterations: create$1().integer().min(1).required(),
          tolerance: create$1().moreThan(0).required()
        });
        return {
          validation: validation2,
          initialValue: {
            maxIterations: 100,
            tolerance: 1e-3
          }
        };
      }
      case "autoPolynomial":
      case "polynomial": {
        const validation2 = create().shape({
          degree: create$1().integer().min(1).max(6).required()
        });
        return {
          validation: validation2,
          initialValue: {
            degree: 3
          }
        };
      }
      default:
        return {
          validation: {},
          initialValue: {}
        };
    }
  }, [algorithm]);
  return /* @__PURE__ */ jsxs$1("div", {
    style: styles$7.container,
    children: [/* @__PURE__ */ jsx$1("span", {
      style: styles$7.label,
      children: "Algorithm: "
    }), /* @__PURE__ */ jsx$1(Select, {
      ref: algorithmRef,
      data: getAlgorithmsList(),
      style: {
        marginLeft: 10,
        marginRight: 10
      },
      onChange: changeAlgorithmHandler,
      defaultValue: "polynomial"
    }), /* @__PURE__ */ jsxs$1(FormikForm, {
      ref: formRef,
      onSubmit: handleApplyFilter,
      initialValues: formData.initialValue,
      validationSchema: formData.validation,
      children: [algorithm && algorithm === "airpls" && /* @__PURE__ */ jsxs$1("div", {
        style: {
          display: "flex"
        },
        children: [/* @__PURE__ */ jsx$1(Label, {
          title: "maxIterations:",
          children: /* @__PURE__ */ jsx$1(FormikInput, {
            type: "number",
            name: "maxIterations"
          })
        }), /* @__PURE__ */ jsx$1(Label, {
          title: "tolerance:",
          style: {
            label: {
              padding: "0 5px"
            }
          },
          children: /* @__PURE__ */ jsx$1(FormikInput, {
            type: "number",
            name: "tolerance"
          })
        })]
      }), algorithm && ["autoPolynomial", "polynomial"].includes(algorithm) && /* @__PURE__ */ jsx$1(Label, {
        title: "degree [ 1 - 6 ]:",
        children: /* @__PURE__ */ jsx$1(FormikInput, {
          type: "number",
          name: "degree",
          min: 1,
          max: 6,
          style: {
            inputWrapper: {
              height: "100%"
            }
          }
        })
      })]
    }, JSON.stringify(formData.initialValue)), /* @__PURE__ */ jsx$1(ActionButtons, {
      onDone: () => formRef.current.submitForm(),
      onCancel: handleCancelFilter
    })]
  });
}
const styles$6 = {
  container: {
    width: "100%",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    border: "0.55px solid #c7c7c7",
    borderRadius: "5px",
    userSelect: "none",
    backgroundColor: "#18ce0f14",
    fontSize: "10px",
    color: "#00801d",
    margin: "0px 5px",
    cursor: "ew-resize"
  },
  label: {
    whiteSpace: "nowrap",
    textOverflow: "ellipsis",
    overflow: "hidden",
    maxWidth: "100%",
    paddingLeft: "5px",
    paddingRight: "5px"
  }
};
function InputRange(props, ref) {
  const {
    name: name2,
    value = 0,
    onChange,
    label,
    style: style2,
    className
  } = props;
  const previousPosition = react.exports.useRef(0);
  const valueRef = react.exports.useRef(value);
  react.exports.useImperativeHandle(ref, () => ({
    setValue: (value2) => {
      valueRef.current = value2;
    }
  }));
  const mouseDownCallback = react.exports.useCallback((event) => {
    function mouseMoveCallback(event2) {
      let diff = event2.clientX - previousPosition.current;
      previousPosition.current = event2.clientX;
      if (event2.buttons === 1) {
        const step = diff / (event2.shiftKey ? 10 : 1);
        valueRef.current = valueRef.current + step;
        onChange({
          value: valueRef.current,
          name: name2
        });
      }
    }
    function mouseUpCallback() {
      window.removeEventListener("mousemove", mouseMoveCallback);
      window.removeEventListener("mouseup", mouseUpCallback);
    }
    previousPosition.current = event.clientX;
    window.addEventListener("mousemove", mouseMoveCallback);
    window.addEventListener("mouseup", mouseUpCallback);
  }, [name2, onChange]);
  return /* @__PURE__ */ jsx$1("div", {
    style: __spreadValues(__spreadValues({}, styles$6.container), style2),
    className,
    onMouseDown: mouseDownCallback,
    children: /* @__PURE__ */ jsx$1("span", {
      style: styles$6.label,
      children: label
    })
  });
}
var InputRange$1 = react.exports.forwardRef(InputRange);
const styles$5 = {
  container: {
    padding: "5px",
    height: "100%",
    display: "flex"
  },
  input: {
    width: "100px"
  },
  select: {
    marginLeft: "5px",
    marginRight: "10px",
    border: "none",
    height: "20px"
  }
};
const phaseCorrectionTypes = {
  manual: "manual",
  automatic: "automatic",
  absolute: "absolute"
};
const algorithms = [{
  key: phaseCorrectionTypes.manual,
  label: "Manual",
  value: phaseCorrectionTypes.manual
}, {
  key: phaseCorrectionTypes.automatic,
  label: "Automatic",
  value: phaseCorrectionTypes.automatic
}, {
  key: phaseCorrectionTypes.absolute,
  label: "Absolute",
  value: phaseCorrectionTypes.absolute
}];
function ManualPhaseCorrectionPanelInner({
  data,
  pivot,
  filter: filter2
}) {
  const dispatch = useDispatch();
  const [value, setValue] = react.exports.useState({
    ph0: 0,
    ph1: 0
  });
  const valueRef = react.exports.useRef({
    ph0: 0,
    ph1: 0
  });
  const ph0Ref = react.exports.useRef();
  const ph1Ref = react.exports.useRef();
  const [phaseCorrectionType, setPhaseCorrectionType] = react.exports.useState(phaseCorrectionTypes.manual);
  react.exports.useEffect(() => {
    if (filter2) {
      valueRef.current = filter2.value;
      setValue(filter2.value);
      ph0Ref.current.setValue(filter2.value.ph0);
      ph1Ref.current.setValue(filter2.value.ph1);
    } else {
      ph0Ref.current.setValue(valueRef.current.ph0);
      ph1Ref.current.setValue(valueRef.current.ph1);
    }
  }, [filter2]);
  const handleApplyFilter = react.exports.useCallback(() => {
    switch (phaseCorrectionType) {
      case phaseCorrectionTypes.automatic: {
        dispatch({
          type: APPLY_AUTO_PHASE_CORRECTION_FILTER
        });
        break;
      }
      case phaseCorrectionTypes.manual: {
        dispatch({
          type: APPLY_MANUAL_PHASE_CORRECTION_FILTER,
          value
        });
        break;
      }
      case phaseCorrectionTypes.absolute: {
        dispatch({
          type: APPLY_ABSOLUTE_FILTER
        });
        break;
      }
    }
  }, [dispatch, phaseCorrectionType, value]);
  const calcPhaseCorrectionHandler = react.exports.useCallback((newValues, filedName) => {
    if (filedName === "ph1" && data.re) {
      const diff0 = newValues.ph0 - valueRef.current.ph0;
      const diff1 = newValues.ph1 - valueRef.current.ph1;
      newValues.ph0 += diff0 - diff1 * (pivot == null ? void 0 : pivot.index) / data.re.length;
    }
    dispatch({
      type: CALCULATE_MANUAL_PHASE_CORRECTION_FILTER,
      value: newValues
    });
  }, [data.re, dispatch, pivot == null ? void 0 : pivot.index]);
  const handleInput = react.exports.useCallback((e2) => {
    const {
      name: name2,
      value: value2
    } = e2.target;
    if (e2.target) {
      const newValue = __spreadProps(__spreadValues({}, valueRef.current), {
        [name2]: value2
      });
      if (String(value2).trim() !== "-") {
        calcPhaseCorrectionHandler(newValue, name2);
      }
      valueRef.current = newValue;
      setValue(valueRef.current);
    }
  }, [calcPhaseCorrectionHandler]);
  const handleRangeChange = react.exports.useCallback((e2) => {
    const newValue = __spreadProps(__spreadValues({}, valueRef.current), {
      [e2.name]: e2.value
    });
    calcPhaseCorrectionHandler(newValue, e2.name);
    valueRef.current = newValue;
    setValue(valueRef.current);
  }, [calcPhaseCorrectionHandler]);
  const handleCancelFilter = react.exports.useCallback(() => {
    dispatch({
      type: RESET_SELECTED_TOOL
    });
  }, [dispatch]);
  const onChangeHandler = react.exports.useCallback((val) => {
    setPhaseCorrectionType(val);
  }, []);
  return /* @__PURE__ */ jsxs$1("div", {
    style: styles$5.container,
    children: [/* @__PURE__ */ jsx$1(Select, {
      onChange: onChangeHandler,
      data: algorithms,
      defaultValue: phaseCorrectionTypes.manual,
      style: styles$5.select
    }), phaseCorrectionType === phaseCorrectionTypes.manual && /* @__PURE__ */ jsxs$1(Fragment$1, {
      children: [/* @__PURE__ */ jsx$1(Label, {
        title: "PH0 :",
        style: {
          wrapper: {
            marginRight: "5px"
          }
        },
        children: /* @__PURE__ */ jsx$1(Input, {
          name: "ph0",
          style: {
            input: styles$5.input
          },
          onChange: handleInput,
          value: value.ph0,
          type: "number",
          debounceTime: 250
        })
      }), /* @__PURE__ */ jsx$1(Label, {
        title: "PH1 :",
        children: /* @__PURE__ */ jsx$1(Input, {
          name: "ph1",
          style: {
            input: styles$5.input
          },
          onChange: handleInput,
          value: value.ph1,
          type: "number",
          debounceTime: 250
        })
      }), /* @__PURE__ */ jsx$1(InputRange$1, {
        ref: ph0Ref,
        name: "ph0",
        label: "Change Ph0 By mouse click and drag",
        style: {
          width: "20%"
        },
        onChange: handleRangeChange
      }), /* @__PURE__ */ jsx$1(InputRange$1, {
        ref: ph1Ref,
        name: "ph1",
        label: "Change Ph1 By mouse click and drag",
        style: {
          width: "20%"
        },
        onChange: handleRangeChange
      })]
    }), /* @__PURE__ */ jsx$1(ActionButtons, {
      onDone: handleApplyFilter,
      onCancel: handleCancelFilter
    })]
  });
}
const MemoizedManualPhaseCorrectionPanel = react.exports.memo(ManualPhaseCorrectionPanelInner);
const emptyData$1 = {
  datum: {},
  filter: null
};
function ManualPhaseCorrectionPanel() {
  const {
    toolOptions: {
      data: {
        pivot
      }
    }
  } = useChartData();
  const {
    data,
    filters
  } = useSpectrum(emptyData$1);
  const filter2 = react.exports.useMemo(() => {
    return filters.find((filter22) => filter22.name === id$5) || null;
  }, [filters]);
  return /* @__PURE__ */ jsx$1(MemoizedManualPhaseCorrectionPanel, {
    data,
    filter: filter2,
    pivot
  });
}
const styles$4 = {
  container: {
    padding: "5px",
    height: "100%",
    display: "flex",
    fontSize: "12px",
    alignItems: "baseline"
  },
  input: {
    height: "100%",
    width: "50px",
    borderRadius: "5px",
    border: "0.55px solid #c7c7c7",
    margin: "0px 5px 0px 5px",
    textAlign: "center"
  },
  inputContainer: {
    flex: 2
  },
  label: {
    flex: 5
  },
  hint: {
    lineHeight: 2,
    userSelect: "none",
    fontSize: "11px"
  }
};
function RangesPickingOptionPanel() {
  const dispatch = useDispatch();
  const lookNegativeRef = react.exports.useRef();
  const minMaxRatioRef = react.exports.useRef();
  const handleApplyFilter = react.exports.useCallback(() => {
    dispatch({
      type: AUTO_RANGES_DETECTION,
      options: {
        peakPicking: {
          minMaxRatio: Number(minMaxRatioRef.current.value) || 0.05,
          lookNegative: lookNegativeRef.current.checked
        }
      }
    });
  }, [dispatch]);
  return /* @__PURE__ */ jsxs$1("div", {
    style: styles$4.container,
    children: [/* @__PURE__ */ jsxs$1("div", {
      style: {
        justifyItems: "baseline",
        margin: "0 10px"
      },
      children: [/* @__PURE__ */ jsx$1("label", {
        style: {
          marginRight: "2px",
          lineHeight: 2,
          userSelect: "none"
        },
        htmlFor: "lookNegative",
        children: "Detect negative:"
      }), /* @__PURE__ */ jsx$1(CheckBox, {
        name: "lookNegative",
        ref: lookNegativeRef
      })]
    }), /* @__PURE__ */ jsx$1(NumberInput, {
      ref: minMaxRatioRef,
      label: "Min Max Ratio:",
      name: "minMaxRatio",
      style: {
        input: styles$4.input,
        inputContainer: styles$4.inputContainer,
        label: styles$4.label
      },
      defaultValue: 0.05,
      step: "0.01"
    }), /* @__PURE__ */ jsx$1(Button.Done, {
      onClick: handleApplyFilter,
      style: {
        margin: "0 10px"
      },
      children: "Auto ranges picking"
    }), /* @__PURE__ */ jsx$1("span", {
      style: styles$4.hint,
      children: "Manual selection using SHIFT + select zone or click on Auto peak picking"
    })]
  });
}
const styles$3 = {
  container: {
    padding: "5px",
    height: "100%",
    display: "flex"
  },
  input: {
    height: "100%",
    width: "80px",
    borderRadius: "5px",
    border: "0.55px solid #c7c7c7",
    margin: "0px 5px 0px 5px",
    textAlign: "center"
  },
  label: {
    lineHeight: 2,
    userSelect: "none"
  }
};
const Sizes = generateNumbersPowerOfX(8, 21);
function ZeroFillingOptionsPanel() {
  const dispatch = useDispatch();
  const {
    data,
    activeSpectrum
  } = useChartData();
  const sizeTextInputRef = react.exports.useRef();
  const [lineBroadeningValue, setLineBroadeningValue] = react.exports.useState(1);
  const handleApplyFilter = react.exports.useCallback(() => {
    dispatch({
      type: APPLY_ZERO_FILLING_FILTER,
      value: {
        zeroFillingSize: Number(sizeTextInputRef.current.value),
        lineBroadeningValue
      }
    });
  }, [dispatch, lineBroadeningValue]);
  const getDefaultValue = react.exports.useCallback(() => {
    if (data && (activeSpectrum == null ? void 0 : activeSpectrum.id)) {
      return 2 ** Math.round(Math.log2(data[activeSpectrum.index].data.x.length));
    }
    return "";
  }, [activeSpectrum, data]);
  const handleInput = react.exports.useCallback((e2) => {
    if (e2.target) {
      const _value = e2.target.validity.valid ? Number(e2.target.value) : lineBroadeningValue;
      setLineBroadeningValue(_value);
    }
  }, [lineBroadeningValue]);
  const handleCancelFilter = react.exports.useCallback(() => {
    dispatch({
      type: RESET_SELECTED_TOOL
    });
  }, [dispatch]);
  return /* @__PURE__ */ jsxs$1("div", {
    style: styles$3.container,
    children: [/* @__PURE__ */ jsx$1("span", {
      style: styles$3.label,
      children: "Size: "
    }), /* @__PURE__ */ jsx$1(Select, {
      ref: sizeTextInputRef,
      data: Sizes,
      style: {
        marginLeft: 10,
        marginRight: 10
      },
      defaultValue: getDefaultValue()
    }), /* @__PURE__ */ jsx$1("span", {
      style: styles$3.label,
      children: "Line Broadening: "
    }), /* @__PURE__ */ jsx$1("input", {
      name: "line-broadening",
      style: styles$3.input,
      type: "number",
      defaultValue: lineBroadeningValue,
      onInput: handleInput,
      pattern: "^\\d*(\\.\\d{0,2})?$",
      step: "any"
    }), /* @__PURE__ */ jsx$1(ActionButtons, {
      onDone: handleApplyFilter,
      onCancel: handleCancelFilter
    })]
  });
}
const styles$2 = {
  container: {
    padding: "5px",
    height: "100%",
    display: "flex",
    fontSize: "12px"
  },
  input: {
    width: "50px"
  },
  inputContainer: {
    flex: "2"
  },
  label: {
    flex: "5"
  }
};
function Zones2DOptionPanel() {
  const dispatch = useDispatch();
  const thresholdFactor = react.exports.useRef();
  const handleApplyFilter = react.exports.useCallback(() => {
    dispatch({
      type: AUTO_ZONES_DETECTION,
      options: {
        thresholdFactor: thresholdFactor.current.value
      }
    });
  }, [dispatch]);
  const handleInput = react.exports.useCallback((e2) => {
    if (e2.target) {
      dispatch({
        type: CHANGE_ZONES_NOISE_FACTOR,
        payload: e2.target.value
      });
    }
  }, [dispatch]);
  return /* @__PURE__ */ jsxs$1("div", {
    style: styles$2.container,
    children: [/* @__PURE__ */ jsx$1(NumberInput, {
      ref: thresholdFactor,
      label: "NoiseFactor",
      name: "noiseFactor",
      style: {
        input: styles$2.input,
        inputContainer: styles$2.inputContainer,
        label: styles$2.label
      },
      defaultValue: 1,
      onChange: handleInput
    }), /* @__PURE__ */ jsx$1(Button.Done, {
      onClick: handleApplyFilter,
      style: {
        margin: "0 10px"
      },
      children: "Auto Zones Picking"
    })]
  });
}
function HeaderInner(props) {
  const {
    isFullscreen,
    onMaximize = () => null,
    selectedOptionPanel
  } = props;
  const modal = useModal();
  const {
    current: {
      display: {
        general
      }
    },
    workspace,
    dispatch
  } = usePreferences();
  const workspacesList = useWorkspacesList();
  const hideGeneralSettings = (general == null ? void 0 : general.hideGeneralSettings) && workspace.base ? true : false;
  const selectedPanel = react.exports.useMemo(() => {
    switch (selectedOptionPanel) {
      case options.zeroFilling.id:
        return /* @__PURE__ */ jsx$1(ZeroFillingOptionsPanel, {});
      case options.phaseCorrection.id:
        return /* @__PURE__ */ jsx$1(ManualPhaseCorrectionPanel, {});
      case options.peakPicking.id:
        return /* @__PURE__ */ jsx$1(AutoPeakPickingOptionPanel, {});
      case options.rangesPicking.id:
        return /* @__PURE__ */ jsx$1(RangesPickingOptionPanel, {});
      case options.baseLineCorrection.id:
        return /* @__PURE__ */ jsx$1(BaseLineCorrectionPanel, {});
      case options.zone2D.id:
        return /* @__PURE__ */ jsx$1(Zones2DOptionPanel, {});
    }
  }, [selectedOptionPanel]);
  const openGeneralSettingsHandler = react.exports.useCallback(() => {
    modal.show(/* @__PURE__ */ jsx$1(GeneralSettings, {}), {
      position: positions.TOP_CENTER,
      enableResizing: true,
      width: 600,
      height: 400
    });
  }, [modal]);
  const openAboutUs = react.exports.useCallback(() => {
    modal.show(/* @__PURE__ */ jsx$1(AboutUsModal, {}), {
      isBackgroundBlur: false,
      position: positions.MIDDLE,
      width: 500,
      height: 480
    });
  }, [modal]);
  const changeWorkspaceHandler = react.exports.useCallback((option) => {
    dispatch({
      type: "SET_WORKSPACE",
      payload: {
        workspace: option.key
      }
    });
  }, [dispatch]);
  return /* @__PURE__ */ jsxs$1(Header, {
    children: [/* @__PURE__ */ jsxs$1("div", {
      style: {
        display: "flex",
        flexDirection: "row",
        alignItems: "center"
      },
      children: [/* @__PURE__ */ jsx$1("div", {
        children: /* @__PURE__ */ jsx$1(Toolbar, {
          orientation: "horizontal",
          children: /* @__PURE__ */ jsx$1(Toolbar.Item, {
            onClick: openAboutUs,
            titleOrientation: "horizontal",
            id: "logo",
            title: "About NMRium",
            children: /* @__PURE__ */ jsx$1("div", {
              style: {
                display: "flex",
                alignItems: "center",
                justifyContent: "center"
              },
              children: /* @__PURE__ */ jsx$1(SvgNmrium, {})
            })
          })
        })
      }), /* @__PURE__ */ jsx$1("div", {
        className: "toolOptionsPanel",
        children: selectedPanel
      })]
    }), /* @__PURE__ */ jsxs$1("div", {
      style: {
        display: "flex",
        flexDirection: "row",
        alignItems: "center"
      },
      children: [!hideGeneralSettings && /* @__PURE__ */ jsx$1(DropDownButton, {
        data: workspacesList,
        selectedKey: workspace.current,
        onSelect: changeWorkspaceHandler
      }), /* @__PURE__ */ jsx$1("div", {
        children: /* @__PURE__ */ jsxs$1(Toolbar, {
          orientation: "horizontal",
          children: [/* @__PURE__ */ jsx$1(Toolbar.Item, {
            id: "user-manual",
            title: "User manual",
            onClick: () => window.open(docsBaseUrl, "_blank"),
            children: /* @__PURE__ */ jsx$1(FaQuestionCircle, {})
          }), !hideGeneralSettings && /* @__PURE__ */ jsx$1(Toolbar.Item, {
            id: "general-settings",
            onClick: openGeneralSettingsHandler,
            title: "General settings",
            children: /* @__PURE__ */ jsx$1(FaWrench, {})
          }), !isFullscreen && /* @__PURE__ */ jsx$1(Toolbar.Item, {
            id: "full-screen",
            onClick: onMaximize,
            title: "Full Screen",
            className: "windowButton",
            children: /* @__PURE__ */ jsx$1(FaRegWindowMaximize, {})
          })]
        })
      })]
    })]
  });
}
const MemoizedHeader = react.exports.memo(HeaderInner);
function HeaderWrapper({
  isFullscreen,
  onMaximize
}) {
  const {
    toolOptions: {
      selectedOptionPanel
    }
  } = useChartData();
  return /* @__PURE__ */ jsx$1(MemoizedHeader, {
    selectedOptionPanel,
    isFullscreen,
    onMaximize
  });
}
const FILES_TYPES = {
  MOL: "mol",
  NMRIUM: "nmrium",
  JSON: "json",
  DX: "dx",
  JDX: "jdx",
  JDF: "jdf",
  ZIP: "zip",
  NMREDATA: "nmredata"
};
const FILES_SIGNATURES = {
  ZIP: "504b0304"
};
function getFileSignature(fileArrayBuffer) {
  return new Uint8Array(fileArrayBuffer).slice(0, 4).reduce((acc, byte) => acc += byte.toString(16).padStart(2, "0"), "");
}
async function loadFile(file, options2 = { asBuffer: false }) {
  const response = await fetch(file);
  checkStatus(response);
  const data = options2.asBuffer ? response.arrayBuffer() : response.text();
  return data;
}
function checkStatus(response) {
  if (!response.ok) {
    throw new Error(`HTTP ${response.status} - ${response.statusText}`);
  }
  return response;
}
function getFileExtension(name2) {
  return name2.replace(/^.*\./, "").toLowerCase();
}
function getFileName(name2) {
  return name2.substr(0, name2.lastIndexOf("."));
}
function extractFileMetaFromPath(path) {
  const meta = path.replace(/^.*[\\/]/, "").split(".");
  return { name: meta[0].toLowerCase(), extension: meta[1].toLowerCase() };
}
function loadFiles(acceptedFiles, options2 = {}) {
  return Promise.all([].map.call(acceptedFiles, (file) => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onabort = (e2) => reject(e2);
      reader.onerror = (e2) => reject(e2);
      reader.onload = () => {
        if (reader.result) {
          const binary = reader.result;
          const name2 = getFileName(file.name);
          const extension = getFileExtension(file.name);
          resolve({ binary, name: name2, extension });
        }
      };
      if (options2.asBuffer) {
        reader.readAsArrayBuffer(file);
      } else {
        reader.readAsBinaryString(file);
      }
    });
  }));
}
async function loadFilesFromZip(files, options2 = {}) {
  const result = [];
  for (const file of files) {
    try {
      const binary = await file.async(options2.asBuffer ? "uint8array" : "text");
      const name2 = getFileName(file.name);
      const extension = getFileExtension(file.name);
      result.push({ binary, name: name2, extension });
    } catch (e2) {
      console.error(e2);
    }
  }
  return result;
}
const style = css`
  height: 100%;
  background-color: #b5b5b599;
  position: absolute;
  display: flex;
  justify-content: center;
  align-items: center;
  flex-flow: column;
  z-index: 99999;

  p {
    color: white;
    background-color: rgb(104, 104, 104);
    padding: 1.5%;
    border-radius: 30px;
    margin: 0px;
  }

  svg {
    stroke-width: 0;
    font-size: 3rem !important;
    fill: white;
  }
`;
const containerStyle = css`
  border: 0.55px #e6e6e6 solid;
  display: flex;
  flex: 1;
  flex-direction: 'column';
  height: 100%;
`;
function DropZone(props) {
  const {
    width,
    height
  } = useChartData();
  const dispatch = useDispatch();
  const alert2 = useAlert();
  const loadSubFilesFromZip = react.exports.useCallback(async (extractedfiles, uniqueFileExtensions) => {
    for (let extension of uniqueFileExtensions) {
      const selectedFilesByExtensions = extractedfiles.filter((file) => getFileExtension(file.name) === extension);
      switch (extension) {
        case FILES_TYPES.MOL: {
          const files = await loadFilesFromZip(selectedFilesByExtensions);
          dispatch({
            type: LOAD_MOL_FILE,
            files
          });
          break;
        }
        case FILES_TYPES.NMRIUM:
        case FILES_TYPES.JSON: {
          const files = await loadFilesFromZip(selectedFilesByExtensions, {
            asBuffer: true
          });
          if (selectedFilesByExtensions.length === 1) {
            const decoder = new TextDecoder("utf8");
            files[0].binary = decoder.decode(files[0].binary);
            dispatch({
              type: LOAD_JSON_FILE,
              files
            });
          } else {
            throw new Error("You can add only one json file");
          }
          break;
        }
        case FILES_TYPES.JDX:
        case FILES_TYPES.DX: {
          const files = await loadFilesFromZip(selectedFilesByExtensions, {
            asBuffer: true
          });
          dispatch({
            type: LOAD_JCAMP_FILE,
            files
          });
          break;
        }
        case FILES_TYPES.JDF: {
          const files = await loadFilesFromZip(selectedFilesByExtensions, {
            asBuffer: true
          });
          dispatch({
            type: LOAD_JDF_FILE,
            files
          });
          break;
        }
      }
    }
  }, [dispatch]);
  const loadFilesHandler = react.exports.useCallback(async (files) => {
    const uniqueFileExtensions = [...new Set(files.map((file) => getFileExtension(file.name)))];
    for (let extension of uniqueFileExtensions) {
      const selectedFilesByExtensions = files.filter((file) => getFileExtension(file.name) === extension);
      try {
        switch (extension) {
          case FILES_TYPES.MOL: {
            const files2 = await loadFiles(selectedFilesByExtensions);
            dispatch({
              type: LOAD_MOL_FILE,
              files: files2
            });
            break;
          }
          case FILES_TYPES.NMRIUM:
          case FILES_TYPES.JSON:
            if (selectedFilesByExtensions.length === 1) {
              const files2 = await loadFiles(selectedFilesByExtensions, {
                asBuffer: true
              });
              const fileSignature = getFileSignature(files2[0].binary);
              if (fileSignature === FILES_SIGNATURES.ZIP) {
                const unzipResult = await Zip.loadAsync(files2[0].binary);
                await loadSubFilesFromZip(Object.values(unzipResult.files), [FILES_TYPES.NMRIUM]);
              } else {
                const decoder = new TextDecoder("utf8");
                files2[0].binary = decoder.decode(files2[0].binary);
                dispatch({
                  type: LOAD_JSON_FILE,
                  files: files2
                });
              }
            } else {
              throw new Error("You can add only one json file");
            }
            break;
          case FILES_TYPES.JDX:
          case FILES_TYPES.DX: {
            const files2 = await loadFiles(selectedFilesByExtensions, {
              asBuffer: true
            });
            dispatch({
              type: LOAD_JCAMP_FILE,
              files: files2
            });
            break;
          }
          case FILES_TYPES.JDF: {
            const files2 = await loadFiles(selectedFilesByExtensions, {
              asBuffer: true
            });
            dispatch({
              type: LOAD_JDF_FILE,
              files: files2
            });
            break;
          }
          case FILES_TYPES.ZIP: {
            const files2 = await loadFiles(selectedFilesByExtensions, {
              asBuffer: true
            });
            for (const zipFile of files2) {
              const unzipResult = await Zip.loadAsync(zipFile.binary);
              const uniqueFileExtensions2 = [...new Set(Object.values(unzipResult.files).map((file) => getFileExtension(file.name)))];
              const isNotZip = uniqueFileExtensions2.some((ex) => FILES_TYPES[ex.toUpperCase()] && ex !== FILES_TYPES.ZIP);
              if (isNotZip) {
                const hasBruker = Object.keys(unzipResult.files).some((path) => {
                  return ["2rr", "fid", "1r"].some((brukerFile) => path.endsWith(brukerFile));
                });
                if (hasBruker)
                  dispatch({
                    type: LOAD_ZIP_FILE,
                    files: files2
                  });
                await loadSubFilesFromZip(Object.values(unzipResult.files), uniqueFileExtensions2);
              } else {
                dispatch({
                  type: LOAD_ZIP_FILE,
                  files: files2
                });
              }
            }
            break;
          }
          case FILES_TYPES.NMREDATA:
            void loadFiles(selectedFilesByExtensions, {
              asBuffer: true
            }).then(async (files2) => {
              for (const zipFile of files2) {
                dispatch({
                  type: LOAD_NMREDATA_FILE,
                  file: zipFile
                });
              }
            });
            break;
          default:
            throw new Error("The file extension must be zip, dx, jdx, json, mol, nmredata or nmrium.");
        }
      } catch (e2) {
        dispatch({
          type: SET_LOADING_FLAG,
          isLoading: false
        });
        alert2.error(e2.message);
      }
    }
  }, [alert2, dispatch, loadSubFilesFromZip]);
  const onDrop = react.exports.useCallback((droppedFiles) => {
    dispatch({
      type: SET_LOADING_FLAG,
      isLoading: true
    });
    void loadFilesHandler(droppedFiles);
  }, [dispatch, loadFilesHandler]);
  const {
    getRootProps,
    getInputProps,
    isDragActive,
    open: openImportDialog
  } = useDropzone({
    onDrop,
    noClick: true,
    noKeyboard: true
  });
  const open = react.exports.useCallback(() => {
    openImportDialog();
  }, [openImportDialog]);
  return /* @__PURE__ */ jsx(LoaderProvider, {
    value: open,
    children: /* @__PURE__ */ jsxs("div", __spreadProps(__spreadValues({}, getRootProps()), {
      role: "none",
      css: containerStyle,
      children: [/* @__PURE__ */ jsx("input", __spreadValues({
        "data-test-id": "dropzone-input"
      }, getInputProps())), isDragActive && /* @__PURE__ */ jsxs("div", {
        css: style,
        style: {
          width: `${width}px`,
          height: `${height}px`,
          marginTop: "30px",
          marginLeft: "30px"
        },
        children: [/* @__PURE__ */ jsx(FaUpload, {}), /* @__PURE__ */ jsx("p", {
          children: "Drop your files here"
        })]
      }), props.children]
    }))
  });
}
const ignoreActions = [
  APPLY_KEY_PREFERENCES,
  BRUSH_END,
  RESET_DOMAIN,
  RESET_SELECTED_TOOL,
  SET_KEY_PREFERENCES,
  SET_LOADING_FLAG,
  SET_ORIGINAL_DOMAIN,
  SET_SELECTED_FILTER,
  SET_SELECTED_OPTIONS_PANEL,
  SET_SELECTED_TOOL,
  SET_SPECTRUMS_VERTICAL_ALIGN,
  SET_VERTICAL_INDICATOR_X_POSITION,
  SET_WIDTH,
  SET_DIMENSIONS,
  SET_X_DOMAIN,
  SET_Y_DOMAIN,
  SET_ZOOM,
  TOGGLE_REAL_IMAGINARY_VISIBILITY,
  CALCULATE_MANUAL_PHASE_CORRECTION_FILTER,
  CHANGE_SPECTRUM_DISPLAY_VIEW_MODE,
  FULL_ZOOM_OUT,
  SAVE_AS_SVG,
  SAVE_DATA_AS_JSON,
  SET_ACTIVE_TAB,
  CHANGE_VISIBILITY,
  CHANGE_PEAKS_MARKERS_VISIBILITY,
  CHANGE_ACTIVE_SPECTRUM,
  CHANGE_SPECTRUM_COLOR,
  SET_MOUSE_OVER_DISPLAYER
];
function checkActionType(type) {
  if (!ignoreActions.includes(type))
    return true;
  return false;
}
const menuStyles = css`
  .menu {
    box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5);
    padding: 0px;
    margin: 0px;
    border-radius: 5px;
    display: flex;
    flex-direction: column;
    position: absolute;
    z-index: 99999;
    padding: 2px;
    background-color: white;

    button:hover {
      background-color: #fafafa;
    }
  }

  .menu-cover {
    position: fixed;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    z-index: 1;
  }

  .menu-item {
    background-color: transparent;
    border: none;
    border-bottom: 0.55px solid whitesmoke;
    height: 35px;
    outline: outline;
    display: table-cell;
    vertical-align: middle;
    text-align: left;
    padding: 0 10px;

    svg {
      display: inline-block;
    }

    :focus {
      outline: none !important;
    }
    span {
      font-size: 10px;
      padding: 0px 10px;
    }
  }
`;
function MenuItem({
  icon,
  label,
  onClick
}) {
  return /* @__PURE__ */ jsxs("button", {
    type: "button",
    className: "menu-item",
    onClick,
    children: [icon, /* @__PURE__ */ jsx("span", {
      children: label
    })]
  });
}
function MenuList({
  items,
  boxBounding,
  onClick
}) {
  const listRef = react.exports.useRef();
  const [translate, setTranslate] = react.exports.useState({
    x: boxBounding.width,
    y: boxBounding.height
  });
  react.exports.useLayoutEffect(() => {
    const boxSize = listRef.current.getBoundingClientRect();
    setTranslate((oldTransform) => {
      let y = boxBounding.height;
      if (boxSize.bottom > window.innerHeight) {
        y = boxBounding.height * 2 + (boxSize.bottom - window.innerHeight);
      }
      return __spreadProps(__spreadValues({}, oldTransform), {
        y
      });
    });
  }, [boxBounding.height]);
  return /* @__PURE__ */ jsx("div", {
    ref: listRef,
    className: "menu",
    style: {
      transform: `translate(${translate.x}px, -${translate.y}px) `
    },
    children: items == null ? void 0 : items.map((item) => {
      return /* @__PURE__ */ jsx(MenuItem, __spreadProps(__spreadValues({}, item), {
        onClick: () => onClick(item)
      }), item.id);
    })
  });
}
function ToolbarMenu({
  component,
  toolTip = "",
  items = [],
  onClick = () => null
}) {
  const menuButtonRef = react.exports.useRef(null);
  const [isShown, showMenu] = react.exports.useState(false);
  const closeMenuButton = react.exports.useCallback(() => {
    showMenu(false);
  }, []);
  const handleClick = react.exports.useCallback(() => {
    showMenu((flag) => !flag);
  }, []);
  const clickHandler = react.exports.useCallback((e2) => {
    showMenu(false);
    onClick(e2);
  }, [onClick]);
  const boxBounding = react.exports.useCallback(() => {
    var _a;
    return (_a = menuButtonRef.current) == null ? void 0 : _a.getBoundingClientRect();
  }, []);
  return /* @__PURE__ */ jsxs("div", {
    style: {
      height: "auto"
    },
    css: menuStyles,
    children: [/* @__PURE__ */ jsx("div", {
      ref: menuButtonRef,
      children: /* @__PURE__ */ jsx(Toolbar.Item, {
        id: `menu-${toolTip}`,
        title: toolTip,
        active: isShown,
        onClick: handleClick,
        children: component
      })
    }), isShown && /* @__PURE__ */ jsx(MenuList, {
      items,
      boxBounding: boxBounding(),
      onClick: clickHandler
    }), isShown && /* @__PURE__ */ jsx("div", {
      className: "menu-cover",
      onClick: closeMenuButton
    })]
  });
}
const emptyData = { info: {}, datum: {}, ftCounter: 0, fidCounter: 0 };
function useDatumWithSpectraStatistics() {
  const { data, activeSpectrum, activeTab } = useChartData();
  return react.exports.useMemo(() => {
    if (data) {
      let info = {};
      let datum = {};
      let ftCounter = 0;
      let fidCounter = 0;
      for (const dataInfo of data) {
        const { isFid, isFt, nucleus } = dataInfo.info;
        if (activeTab === nucleusToString(nucleus)) {
          if (isFid) {
            fidCounter++;
          }
          if (isFt) {
            ftCounter++;
          }
          if (activeSpectrum && dataInfo.id === activeSpectrum.id) {
            info = dataInfo.info;
            datum = dataInfo.data;
          }
        }
      }
      return {
        info,
        datum,
        ftCounter,
        fidCounter
      };
    }
    return emptyData;
  }, [activeSpectrum, data, activeTab]);
}
function FormikTextarea(props) {
  const _a = props, {
    name: name2,
    style: style2 = {},
    onChange = () => null,
    className = "",
    value,
    placeholder = ""
  } = _a, resProps = __objRest(_a, [
    "name",
    "style",
    "onChange",
    "className",
    "value",
    "placeholder"
  ]);
  const {
    values,
    handleChange,
    setFieldValue,
    errors
  } = useFormikContext();
  const changeHandler = react.exports.useCallback((e2) => {
    onChange(e2);
    handleChange(e2);
  }, [handleChange, onChange]);
  react.exports.useEffect(() => {
    if (value) {
      setFieldValue(name2, value);
    }
  }, [name2, setFieldValue, value]);
  const isInvalid = react.exports.useMemo(() => {
    return get_1(errors, name2);
  }, [errors, name2]);
  return /* @__PURE__ */ jsx$1("textarea", __spreadValues({
    name: name2,
    className,
    placeholder,
    value: value ? value : get_1(values, name2),
    onChange: changeHandler,
    style: __spreadValues(__spreadValues({}, style2), isInvalid && {
      borderColor: "red",
      borderWidth: "1px",
      outline: "none"
    })
  }, resProps));
}
const styles$1 = css`
  width: 600px;
  height: 300px;

  .inner-content {
    flex: 1;
    border: none;
    overflow: hidden;
    padding: 0px;
  }

  .text-area {
    width: 100%;
    height: 100%;
    outline: none;
    resize: none;
    padding: 0 0 0 15px;
  }
`;
const validationSchema = create({
  publicationText: create$2().required()
});
function ImportPublicationStringModal({
  onClose
}) {
  const formRef = react.exports.useRef();
  const dispatch = useDispatch();
  const alert2 = useAlert();
  const publicationStringHandler = react.exports.useCallback((values) => {
    void (async () => {
      const hideLoading = await alert2.showLoading("Generate spectrum from publication string in progress");
      setTimeout(() => {
        dispatch({
          type: GENERATE_SPECTRUM_FROM_PUBLICATION_STRING,
          payload: values
        });
        hideLoading();
      });
      onClose();
    })();
  }, [alert2, dispatch, onClose]);
  return /* @__PURE__ */ jsxs("div", {
    css: [ModalStyles, styles$1],
    children: [/* @__PURE__ */ jsxs("div", {
      className: "header handle",
      children: [/* @__PURE__ */ jsx("span", {
        children: "Import from publication string"
      }), /* @__PURE__ */ jsx(CloseButton$1, {
        onClick: onClose,
        className: "close-bt"
      })]
    }), /* @__PURE__ */ jsx("div", {
      className: "inner-content",
      children: /* @__PURE__ */ jsx(FormikForm, {
        ref: formRef,
        initialValues: {
          publicationText: "1H NMR (CDCl3, 400MHz) \u03B4 10.58 (b, 1H), 7.40 (d, 1H, J = 8.0 Hz), 6.19 (d, 1H, J = 7.6 Hz), 4.88 (s, 1H), 2.17 (s, 3H), 1.02 (s, 9H), 1.01 (s, 9H), 0.89 (s, 9H)"
        },
        validationSchema,
        onSubmit: publicationStringHandler,
        children: /* @__PURE__ */ jsx(FormikTextarea, {
          name: "publicationText",
          className: "text-area",
          placeholder: "Enter publication string"
        })
      })
    }), /* @__PURE__ */ jsx("div", {
      className: "footer-container",
      children: /* @__PURE__ */ jsx(Button.Done, {
        onClick: () => formRef.current.submitForm(),
        children: "Import"
      })
    })]
  });
}
const styles = css`
  display: flex;
  flex-direction: column;
  width: 450px;
  padding: 5px;
  button:focus {
    outline: none;
  }
  .header {
    height: 24px;
    border-bottom: 1px solid #f0f0f0;
    display: flex;
    span {
      color: #464646;
      font-size: 15px;
      flex: 1;
    }

    button {
      background-color: transparent;
      border: none;
      svg {
        height: 16px;
      }
    }
  }
  .container {
    display: flex;
    margin: 30px 5px;
    align-items: center;
    height: 36px;

    input {
      padding: 5px;
      border: 1px solid gray;
      border-radius: 5px;
      margin: 2px;
    }
    input {
      flex: 10;
    }
    button {
      flex: 2;
      height: 100%;
    }
  }
`;
const allowedExtensions = ["dx", "jdx"];
function LoadJCAMPModal({
  onLoadClick,
  onClose,
  startLoading
}) {
  const pathReft = react.exports.useRef();
  const loadJCAMPHandler = react.exports.useCallback(() => {
    const path = pathReft.current.value;
    const {
      name: name2,
      extension
    } = extractFileMetaFromPath(path);
    if (allowedExtensions.includes(extension)) {
      startLoading == null ? void 0 : startLoading();
      void loadFile(path, {
        asBuffer: true
      }).then((data) => {
        const file = {
          binary: data,
          name: name2,
          extension,
          jcampURL: path
        };
        onLoadClick(file);
      });
    } else {
      onLoadClick(null);
    }
  }, [onLoadClick, startLoading]);
  return /* @__PURE__ */ jsxs("div", {
    css: styles,
    children: [/* @__PURE__ */ jsxs("div", {
      className: "header handle",
      children: [/* @__PURE__ */ jsx("span", {
        children: "Load JCAMP Dialog"
      }), /* @__PURE__ */ jsx(CloseButton$1, {
        onClick: onClose
      })]
    }), /* @__PURE__ */ jsxs("div", {
      className: "container",
      children: [/* @__PURE__ */ jsx("input", {
        ref: pathReft,
        type: "text",
        placeholder: "Enter URL to JCAMP-DX file"
      }), /* @__PURE__ */ jsx(Button.Done, {
        onClick: loadJCAMPHandler,
        children: "Load"
      })]
    })]
  });
}
const IMPORT_MENU = [{
  id: "importFile",
  icon: /* @__PURE__ */ jsx$1(FaFile, {}),
  label: "Import from file system (Press Ctrl + O)"
}, {
  id: "importJDX",
  icon: /* @__PURE__ */ jsx$1(FaFile, {}),
  label: "Add JCAMP-DX from URL"
}, {
  id: "importPublicationString",
  icon: /* @__PURE__ */ jsx$1(FaFile, {}),
  label: "Import from publication string"
}];
const EXPORT_MENU = [{
  id: "svg",
  icon: /* @__PURE__ */ jsx$1(FaDownload, {}),
  label: "Export as SVG"
}, {
  id: "png",
  icon: /* @__PURE__ */ jsx$1(FaFileImage, {}),
  label: "Export as PNG"
}, {
  id: "json",
  icon: /* @__PURE__ */ jsx$1(FaFileDownload, {}),
  label: "Save data ( Press Ctrl + S )"
}, {
  id: "advance_save",
  icon: /* @__PURE__ */ jsx$1(FaFileDownload, {}),
  label: "Save data as  ( Press Ctrl + Shift + S )"
}, {
  id: "nmre",
  icon: /* @__PURE__ */ jsx$1(FaFileDownload, {}),
  label: "Save NMRE data"
}, {
  id: "copy",
  icon: /* @__PURE__ */ jsx$1(FaCopy, {}),
  label: "Copy image to Clipboard ( Press Ctrl + C )"
}];
function BasicToolBarInner({
  info,
  verticalAlign,
  displayerMode,
  ftCounter,
  fidCounter,
  activeSpectrum
}) {
  const dispatch = useDispatch();
  const alert2 = useAlert();
  const modal = useModal();
  const openLoader = useLoader();
  const isExperimentalFeature = useCheckExperimentalFeature();
  const isButtonVisible = useCheckToolsVisibility();
  const importMenu = react.exports.useMemo(() => {
    return isExperimentalFeature ? IMPORT_MENU : IMPORT_MENU.filter((item) => item.id !== "importPublicationString");
  }, [isExperimentalFeature]);
  const {
    isRealSpectrumShown,
    changeSpectrumViewHandler,
    changeDisplayViewModeHandler,
    alignSpectrumsVerticallyHandler
  } = useToolsFunctions();
  const {
    saveAsSVGHandler,
    saveAsPNGHandler,
    saveAsJSONHandler,
    saveAsNMREHandler,
    saveToClipboardHandler,
    saveAsHandler
  } = useExport();
  const LoadJacmpHandler = react.exports.useCallback((file) => {
    if (file) {
      dispatch({
        type: LOAD_JCAMP_FILE,
        files: [file]
      });
      modal.close();
    } else {
      alert2.error("you file must be one of those extensions [ .jdx, dx ] ");
    }
  }, [alert2, dispatch, modal]);
  const startLoadingHandler = react.exports.useCallback(() => {
    modal.close();
    dispatch({
      type: SET_LOADING_FLAG,
      isLoading: true
    });
  }, [dispatch, modal]);
  const importJCAMPFile = react.exports.useCallback(() => {
    modal.show(/* @__PURE__ */ jsx$1(LoadJCAMPModal, {
      onLoadClick: LoadJacmpHandler,
      onClose: () => modal.close(),
      startLoading: startLoadingHandler
    }), {});
  }, [LoadJacmpHandler, modal, startLoadingHandler]);
  const openImportPublicationStringModal = react.exports.useCallback(() => {
    modal.show(/* @__PURE__ */ jsx$1(ImportPublicationStringModal, {
      onClose: () => modal.close()
    }), {});
  }, [modal]);
  const importHandler = react.exports.useCallback(({
    id: id2
  }) => {
    switch (id2) {
      case "importFile":
        openLoader();
        break;
      case "importJDX":
        importJCAMPFile();
        break;
      case "importPublicationString":
        openImportPublicationStringModal();
        break;
      default:
        return;
    }
  }, [openLoader, importJCAMPFile, openImportPublicationStringModal]);
  const exportHandler = react.exports.useCallback(({
    id: id2
  }) => {
    switch (id2) {
      case "svg":
        void saveAsSVGHandler();
        break;
      case "png":
        void saveAsPNGHandler();
        break;
      case "json":
        void saveAsJSONHandler();
        break;
      case "advance_save":
        void saveAsHandler();
        break;
      case "nmre":
        void saveAsNMREHandler();
        break;
      case "copy":
        void saveToClipboardHandler();
        break;
    }
  }, [saveAsSVGHandler, saveAsPNGHandler, saveAsJSONHandler, saveAsHandler, saveAsNMREHandler, saveToClipboardHandler]);
  return /* @__PURE__ */ jsxs$1(react.exports.Fragment, {
    children: [isButtonVisible("import") && /* @__PURE__ */ jsx$1(ToolbarMenu, {
      component: /* @__PURE__ */ jsx$1(FaFileImport, {}),
      toolTip: "Import",
      onClick: (element) => {
        importHandler(element);
        return null;
      },
      items: importMenu
    }), isButtonVisible("exportAs") && /* @__PURE__ */ jsx$1(ToolbarMenu, {
      component: /* @__PURE__ */ jsx$1(FaFileExport, {}),
      toolTip: "Export As",
      onClick: (element) => {
        exportHandler(element);
        return null;
      },
      items: EXPORT_MENU
    }), displayerMode === DISPLAYER_MODE.DM_1D && isButtonVisible("spectraStackAlignments") && ftCounter > 1 && ((info == null ? void 0 : info.isFt) || !activeSpectrum) && /* @__PURE__ */ jsx$1(Toolbar.Item, {
      id: "spectra-alignment",
      className: "cheminfo",
      title: "Spectra alignment ( Press s )",
      onClick: changeDisplayViewModeHandler,
      children: verticalAlign.align === "stack" ? /* @__PURE__ */ jsx$1(SvgOverlay3Aligned, {}) : /* @__PURE__ */ jsx$1(SvgOverlay3, {})
    }), displayerMode === DISPLAYER_MODE.DM_1D && isButtonVisible("realImaginary") && info.isComplex && /* @__PURE__ */ jsx$1(Toolbar.Item, {
      id: "display",
      title: isRealSpectrumShown ? "Display Real " : "Display Imaginary",
      onClick: changeSpectrumViewHandler,
      className: "cheminfo",
      children: /* @__PURE__ */ jsx$1(SvgRealImag, {})
    }), displayerMode === DISPLAYER_MODE.DM_1D && isButtonVisible("spectraCenterAlignments") && (ftCounter > 0 || fidCounter > 0) && /* @__PURE__ */ jsx$1(Toolbar.Item, {
      id: "baseline-position",
      title: verticalAlign.align === "bottom" ? "Baseline  Center ( Press c )" : "Baseline  Bottom ( Press c )",
      onClick: alignSpectrumsVerticallyHandler,
      className: "cheminfo",
      children: /* @__PURE__ */ jsx$1("div", {
        style: {
          fontSize: 24
        },
        children: verticalAlign.align === "bottom" ? /* @__PURE__ */ jsx$1(SvgAlignCenter, {}) : /* @__PURE__ */ jsx$1(SvgAlignBottom, {})
      })
    })]
  });
}
const MemoizedBasicToolBar = react.exports.memo(BasicToolBarInner);
function BasicToolBar() {
  const {
    activeSpectrum,
    verticalAlign,
    displayerMode,
    activeTab
  } = useChartData();
  const {
    info,
    fidCounter,
    ftCounter
  } = useDatumWithSpectraStatistics();
  return /* @__PURE__ */ jsx$1(MemoizedBasicToolBar, {
    info,
    fidCounter,
    ftCounter,
    activeSpectrum,
    verticalAlign,
    displayerMode,
    activeTab
  });
}
function ToggleButton(props) {
  const {
    children,
    value = null,
    isActive = false,
    onChange = () => null,
    isVisible = true,
    id: id2,
    title
  } = props;
  const [active, setActive] = react.exports.useState(props.isActive);
  const toggleButton = react.exports.useCallback(() => {
    const _isActive = !active;
    setActive(_isActive);
    if (_isActive) {
      onChange(value);
    } else {
      onChange(null);
    }
  }, [active, onChange, value]);
  react.exports.useEffect(() => {
    setActive(isActive);
  }, [isActive]);
  if (!isVisible) {
    return null;
  }
  return /* @__PURE__ */ jsx$1(Toolbar.Item, {
    onClick: toggleButton,
    title,
    id: id2,
    active,
    children
  });
}
function ToggleButtonGroup({
  children,
  value,
  onChange = () => null
}) {
  const [toggleButtons, setToggleButtons] = react.exports.useState([]);
  const handleOnChange = react.exports.useCallback((val) => {
    const _toggles = [...toggleButtons];
    const toggles = _toggles.map((toggle) => {
      return {
        value: toggle.value,
        isActive: toggle.value === val ? true : false
      };
    });
    setToggleButtons(toggles);
    onChange(val);
  }, [onChange, toggleButtons]);
  const mappedChildren = react.exports.useMemo(() => {
    let index2 = 0;
    return react.exports.Children.map(children, (child) => {
      var _a;
      if (child) {
        if (child.type === ToggleButton) {
          const _child = react.exports.cloneElement(child, {
            onChange: handleOnChange,
            isActive: (_a = toggleButtons[index2]) == null ? void 0 : _a.isActive,
            index: index2
          });
          index2++;
          return _child;
        } else {
          return react.exports.cloneElement(child);
        }
      }
    });
  }, [children, handleOnChange, toggleButtons]);
  react.exports.useEffect(() => {
    const val = react.exports.Children.map(children, (child) => {
      if (child && child.type === ToggleButton) {
        return {
          value: child.props.value,
          isActive: child.props.value === value ? true : false
        };
      }
    });
    setToggleButtons(val);
  }, [children, value]);
  return /* @__PURE__ */ jsx$1(Fragment$1, {
    children: mappedChildren
  });
}
function FunctionToolBarInner({
  defaultValue,
  activeSpectrum,
  info,
  datum,
  displayerMode,
  ftCounter,
  mode
}) {
  const [option, setOption] = react.exports.useState("");
  const isButtonVisible = useCheckToolsVisibility();
  const dispatch = useDispatch();
  const {
    handleChangeOption,
    handleFullZoomOut
  } = useToolsFunctions();
  const handleChange = react.exports.useCallback((selectedOption) => {
    setOption(selectedOption);
    handleChangeOption(selectedOption);
  }, [handleChangeOption]);
  react.exports.useEffect(() => {
    setOption(defaultValue);
  }, [defaultValue]);
  const handleOnFFTFilter = react.exports.useCallback(() => {
    dispatch({
      type: APPLY_FFT_FILTER,
      value: ""
    });
    dispatch({
      type: SET_SELECTED_FILTER,
      selectedFilter: null
    });
  }, [dispatch]);
  return /* @__PURE__ */ jsxs$1(Fragment$1, {
    children: [/* @__PURE__ */ jsxs$1(ToggleButtonGroup, {
      value: option,
      onChange: handleChange,
      children: [isButtonVisible("zoomTool") && /* @__PURE__ */ jsx$1(ToggleButton, {
        value: options.zoom.id,
        id: "zoomIn",
        title: `${options.zoom.label} ( Press z )`,
        children: /* @__PURE__ */ jsx$1("div", {
          style: {
            fontSize: 14
          },
          children: /* @__PURE__ */ jsx$1(FaSearchPlus, {})
        })
      }, options.zoom.id), isButtonVisible("zoomOutTool") && /* @__PURE__ */ jsx$1(Toolbar.Item, {
        id: "zoom-out",
        onClick: handleFullZoomOut,
        title: "Horizontal zoom out ( Press f ), Horizontal and Vertical zoom out, double click ( Press ff )",
        children: /* @__PURE__ */ jsx$1("div", {
          style: {
            fontSize: 14
          },
          children: /* @__PURE__ */ jsx$1(FaExpand, {})
        })
      }), displayerMode === DISPLAYER_MODE.DM_1D && isButtonVisible("peakTool") && /* @__PURE__ */ jsx$1(ToggleButton, {
        value: options.peakPicking.id,
        title: `${options.peakPicking.label} ( Press p )`,
        isVisible: activeSpectrum && !(info == null ? void 0 : info.isFid) ? true : false,
        id: "peakPicking",
        children: /* @__PURE__ */ jsx$1(SvgPeakPicking, {})
      }, options.peakPicking.id), displayerMode === DISPLAYER_MODE.DM_1D && isButtonVisible("integralTool") && /* @__PURE__ */ jsx$1(ToggleButton, {
        value: options.integral.id,
        isVisible: activeSpectrum && !(info == null ? void 0 : info.isFid) ? true : false,
        id: "integralPicking",
        title: `${options.integral.label} ( Press i )`,
        children: /* @__PURE__ */ jsx$1(SvgIntegrate, {})
      }, options.integral.id), displayerMode === DISPLAYER_MODE.DM_2D && isButtonVisible("zonePickingTool") && /* @__PURE__ */ jsx$1(ToggleButton, {
        value: options.zone2D.id,
        id: "zone2d",
        isVisible: activeSpectrum && !(info == null ? void 0 : info.isFid) ? true : false,
        title: `${options.zone2D.label} ( Press r )`,
        children: /* @__PURE__ */ jsx$1(FaDiceFour, {})
      }, options.zone2D.id), displayerMode === DISPLAYER_MODE.DM_2D && isButtonVisible("slicingTool") && /* @__PURE__ */ jsx$1(ToggleButton, {
        value: options.slicingTool.id,
        isVisible: activeSpectrum && !(info == null ? void 0 : info.isFid) ? true : false,
        id: "slic",
        title: `${options.slicingTool.label}`,
        children: /* @__PURE__ */ jsx$1("p", {
          children: "Slic"
        })
      }, options.slicingTool.id), displayerMode === DISPLAYER_MODE.DM_1D && isButtonVisible("autoRangesTool") && /* @__PURE__ */ jsx$1(ToggleButton, {
        value: options.rangesPicking.id,
        isVisible: activeSpectrum && !(info == null ? void 0 : info.isFid) ? true : false,
        title: `${options.rangesPicking.label} ( Press r )`,
        id: "ranges-pick",
        children: /* @__PURE__ */ jsx$1(SvgRangePicking, {})
      }, options.rangesPicking.id), displayerMode === DISPLAYER_MODE.DM_1D && isButtonVisible("multipleSpectraAnalysisTool") && ftCounter > 1 && mode === "RTL" && /* @__PURE__ */ jsx$1(ToggleButton, {
        value: options.multipleSpectraAnalysis.id,
        id: "multipleSpectraAnalysis",
        title: options.multipleSpectraAnalysis.label,
        children: /* @__PURE__ */ jsx$1(SvgMultipleAnalysis, {})
      }, options.multipleSpectraAnalysis.id), displayerMode === DISPLAYER_MODE.DM_1D && isButtonVisible("zeroFillingTool") && /* @__PURE__ */ jsx$1(ToggleButton, {
        value: options.zeroFilling.id,
        isVisible: isApplicable$2({
          info
        }),
        id: "zeroFilling",
        title: options.zeroFilling.label,
        children: /* @__PURE__ */ jsx$1(SvgZeroFilling, {})
      }, options.zeroFilling.id), displayerMode === DISPLAYER_MODE.DM_1D && isButtonVisible("phaseCorrectionTool") && /* @__PURE__ */ jsx$1(ToggleButton, {
        value: options.phaseCorrection.id,
        id: "phaseCorrection",
        title: `${options.phaseCorrection.label} ( Press a )`,
        isVisible: activeSpectrum && info && isApplicable$5({
          info
        }) && datum.im ? true : false,
        children: /* @__PURE__ */ jsx$1(SvgPhaseCorrection, {})
      }, options.phaseCorrection.id), displayerMode === DISPLAYER_MODE.DM_1D && isButtonVisible("baseLineCorrectionTool") && /* @__PURE__ */ jsx$1(ToggleButton, {
        value: options.baseLineCorrection.id,
        id: "baseLineCorrection",
        title: `${options.baseLineCorrection.label} ( Press b )`,
        isVisible: activeSpectrum && info && isApplicable$e({
          info
        }) ? true : false,
        children: /* @__PURE__ */ jsx$1(SvgBaselineCorrection, {})
      }, options.baseLineCorrection.id), displayerMode === DISPLAYER_MODE.DM_1D && isButtonVisible("exclusionZonesTool") && !(info == null ? void 0 : info.isFid) && ftCounter > 0 && /* @__PURE__ */ jsx$1(ToggleButton, {
        value: options.exclusionZones.id,
        title: `${options.exclusionZones.label} ( Press e )`,
        id: "exclusionZones",
        children: /* @__PURE__ */ jsx$1("div", {
          style: {
            fontSize: 18
          },
          children: /* @__PURE__ */ jsx$1(SvgMultipleAnalysis, {})
        })
      }, options.exclusionZones.id)]
    }), displayerMode === DISPLAYER_MODE.DM_1D && isButtonVisible("FFTTool") && info && isApplicable$9({
      info
    }) && /* @__PURE__ */ jsx$1(Toolbar.Item, {
      id: "fft-filter",
      className: "cheminfo",
      title: "FFT Filter",
      onClick: handleOnFFTFilter,
      children: /* @__PURE__ */ jsx$1(SvgFourierTransform, {})
    })]
  });
}
const MemoizedFunctionToolBar = react.exports.memo(FunctionToolBarInner);
function FunctionToolBar({
  defaultValue = options.zoom.id
}) {
  const {
    activeSpectrum,
    displayerMode,
    activeTab,
    mode
  } = useChartData();
  const data = useDatumWithSpectraStatistics();
  return /* @__PURE__ */ jsx$1(MemoizedFunctionToolBar, __spreadProps(__spreadValues({}, data), {
    activeSpectrum,
    displayerMode,
    activeTab,
    defaultValue,
    mode
  }));
}
function ToolBarInner({
  selectedTool
}) {
  return /* @__PURE__ */ jsx$1("div", {
    style: {
      fontSize: 18
    },
    children: /* @__PURE__ */ jsxs$1(Toolbar, {
      orientation: "vertical",
      children: [/* @__PURE__ */ jsx$1(FunctionToolBar, {
        defaultValue: selectedTool
      }), /* @__PURE__ */ jsx$1(BasicToolBar, {})]
    })
  });
}
const MemoizedToolBar = react.exports.memo(ToolBarInner);
function ToolBar() {
  const {
    toolOptions: {
      selectedTool
    }
  } = useChartData();
  return /* @__PURE__ */ jsx$1(MemoizedToolBar, {
    selectedTool
  });
}
const viewerContainerStyle = css`
  border: 0.55px #e6e6e6 solid;
  display: flex;
  flex: 1;
  flex-direction: 'column';
  height: 100%;
  margin-left: -1px;
`;
const containerStyles = css`
  background-color: white;
  width: 100%;
  display: block;
  height: 100%;
  font-size: 14px;

  div:focus {
    outline: none !important;
  }

  button {
    cursor: pointer;
    &:disabled {
      cursor: default;
    }
  }

  button:active,
  button:hover,
  button:focus,
  [type='button']:focus,
  button {
    outline: none !important;
  }
  * {
    -webkit-user-drag: none;
    -moz-user-drag: none;
    -o-user-drag: none;
    user-drag: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }

  .SplitPane {
    height: 100%;
  }
`;
const defaultPreferences = {};
const defaultData = {
  spectra: []
};
function NMRium(props) {
  return /* @__PURE__ */ jsx(RootLayout, {
    style: {
      width: "100%"
    },
    children: /* @__PURE__ */ jsx(ErrorBoundary, {
      FallbackComponent: ErrorOverlay,
      children: /* @__PURE__ */ jsx(InnerNMRium, __spreadValues({}, props))
    })
  });
}
function InnerNMRium({
  data: dataProp = defaultData,
  workspace,
  preferences = defaultPreferences,
  getSpinner = defaultGetSpinner,
  onDataChange,
  emptyText
}) {
  const rootRef = react.exports.useRef(null);
  const elementsWrapperRef = react.exports.useRef(null);
  const viewerRef = react.exports.useRef(null);
  const [show, toggle] = useToggle(false);
  const isFullscreen = useFullscreen(rootRef, show, {
    onClose: () => {
      toggle(false);
    }
  });
  const [state, dispatch] = react.exports.useReducer(spectrumReducer, initialState, initState);
  const [preferencesState, dispatchPreferences] = react.exports.useReducer(preferencesReducer, preferencesInitialState, initPreferencesState);
  const {
    displayerMode,
    data: spectraData
  } = state;
  react.exports.useEffect(() => {
    if (checkActionType(state.actionType)) {
      onDataChange == null ? void 0 : onDataChange(state);
    }
  }, [onDataChange, state]);
  const dispatchMiddleWare = react.exports.useMemo(() => {
    return dispatchMiddleware(dispatch);
  }, []);
  react.exports.useEffect(() => {
    var _a;
    (_a = rootRef.current) == null ? void 0 : _a.focus();
  }, [isFullscreen]);
  react.exports.useEffect(() => {
    dispatchPreferences({
      type: "INIT_PREFERENCES",
      payload: {
        display: preferences,
        workspace,
        dispatch: dispatchPreferences
      }
    });
  }, [preferences, workspace]);
  react.exports.useEffect(() => {
    dispatchMiddleWare({
      type: SET_LOADING_FLAG,
      isLoading: true
    });
    if (dataProp) {
      dispatchMiddleWare({
        type: INITIATE,
        payload: dataProp
      });
    }
  }, [dataProp, dispatchMiddleWare]);
  const preventContextMenuHandler = react.exports.useCallback((e2) => {
    if (!checkModifierKeyActivated(e2)) {
      e2.preventDefault();
    }
  }, []);
  const mainDivRef = react.exports.useRef(null);
  react.exports.useEffect(() => {
    const div = mainDivRef.current;
    if (!div) {
      return;
    }
    function mouseEnterHandler() {
      dispatchMiddleWare({
        type: SET_MOUSE_OVER_DISPLAYER,
        payload: true
      });
    }
    function mouseLeaveHandler() {
      dispatchMiddleWare({
        type: SET_MOUSE_OVER_DISPLAYER,
        payload: false
      });
    }
    div.addEventListener("mouseenter", mouseEnterHandler);
    div.addEventListener("mouseleave", mouseLeaveHandler);
    return () => {
      div.removeEventListener("mouseenter", mouseEnterHandler);
      div.removeEventListener("mouseleave", mouseLeaveHandler);
    };
  }, [dispatchMiddleWare]);
  return /* @__PURE__ */ jsx(GlobalProvider, {
    value: {
      rootRef: rootRef.current,
      elementsWrapperRef: elementsWrapperRef.current,
      viewerRef: viewerRef.current
    },
    children: /* @__PURE__ */ jsx(PreferencesProvider, {
      value: preferencesState,
      children: /* @__PURE__ */ jsx("div", {
        ref: mainDivRef,
        style: {
          height: "100%",
          position: "relative"
        },
        children: /* @__PURE__ */ jsx(AlertProvider, {
          wrapperRef: elementsWrapperRef.current,
          children: /* @__PURE__ */ jsx(DispatchProvider, {
            value: dispatchMiddleWare,
            children: /* @__PURE__ */ jsx(ChartDataProvider, {
              value: state,
              children: /* @__PURE__ */ jsx(Provider, {
                wrapperRef: elementsWrapperRef.current,
                children: /* @__PURE__ */ jsx(HighlightProvider, {
                  children: /* @__PURE__ */ jsx(AssignmentProvider, {
                    spectraData,
                    children: /* @__PURE__ */ jsx(SpinnerProvider, {
                      value: getSpinner,
                      children: /* @__PURE__ */ jsx("div", {
                        className: "nmrium-container",
                        ref: rootRef,
                        css: containerStyles,
                        onContextMenu: preventContextMenuHandler,
                        style: {
                          height: "100%",
                          width: "100%"
                        },
                        children: /* @__PURE__ */ jsx(DropZone, {
                          children: /* @__PURE__ */ jsxs("div", {
                            style: {
                              display: "flex",
                              flexDirection: "column",
                              backgroundColor: "white",
                              width: "100%"
                            },
                            children: [/* @__PURE__ */ jsx(HeaderWrapper, {
                              isFullscreen,
                              onMaximize: toggle
                            }), /* @__PURE__ */ jsxs("div", {
                              style: {
                                display: "flex",
                                flexDirection: "row",
                                height: "100%"
                              },
                              children: [/* @__PURE__ */ jsx(ToolBar, {}), /* @__PURE__ */ jsxs(SplitPaneWrapper, {
                                children: [/* @__PURE__ */ jsxs("div", {
                                  css: viewerContainerStyle,
                                  children: [/* @__PURE__ */ jsx(KeysListenerTracker, {}), /* @__PURE__ */ jsx("div", {
                                    "data-test-id": "viewer",
                                    ref: viewerRef,
                                    style: {
                                      width: "100%",
                                      height: "100%"
                                    },
                                    children: displayerMode === DISPLAYER_MODE.DM_1D ? /* @__PURE__ */ jsx(Viewer1D, {
                                      emptyText
                                    }) : /* @__PURE__ */ jsx(Viewer2D, {
                                      emptyText
                                    })
                                  })]
                                }), /* @__PURE__ */ jsx(Panels, {})]
                              }), /* @__PURE__ */ jsx("div", {
                                ref: elementsWrapperRef,
                                id: "main-wrapper",
                                style: {
                                  position: "absolute",
                                  pointerEvents: "none",
                                  zIndex: 0,
                                  left: 0,
                                  right: 0,
                                  top: 0,
                                  bottom: 0
                                }
                              }, String(isFullscreen))]
                            })]
                          })
                        })
                      })
                    })
                  })
                })
              })
            })
          })
        })
      })
    })
  });
}
var NMRium$1 = react.exports.memo(NMRium);
function searchDeep(obj, searchKey) {
  let result = [];
  function objectHelper(obj2) {
    Object.keys(obj2).forEach((key) => {
      if (searchKey === key) {
        result.push({
          [key]: obj2[key]
        });
      }
      if (Array.isArray(obj2[key])) {
        obj2[key].forEach((object) => {
          objectHelper(object);
        });
      } else if (typeof obj2[key] === "object" && obj2[key] !== null) {
        objectHelper(obj2[key]);
      }
    });
  }
  objectHelper(obj);
  return result;
}
function Inspector(data) {
  const [filteredData, seData] = react.exports.useState();
  const [key, setKey] = react.exports.useState("");
  react.exports.useEffect(() => {
    const result = searchDeep(data, key);
    seData(key ? result : data);
  }, [data, key]);
  const handleSearch = react.exports.useCallback(debounce_1((e2) => {
    const key2 = e2.target.value;
    setKey(key2);
  }, 500), [data]);
  return /* @__PURE__ */ jsxs$1("div", {
    style: {
      display: "flex",
      flexDirection: "column",
      paddingTop: "10px"
    },
    children: [/* @__PURE__ */ jsx$1("input", {
      style: {
        border: "1px solid gray",
        padding: "5px"
      },
      type: "text",
      placeholder: "Search for key...",
      onChange: handleSearch
    }), /* @__PURE__ */ jsx$1(ObjectInspector$1, {
      data: filteredData
    }), ";"]
  });
}
function Test() {
  const [data, setData2] = react.exports.useState();
  const [callBackData, setCallBackData] = react.exports.useState({});
  const dropFileHandler = react.exports.useCallback((dropfiles) => {
    void (async () => {
      try {
        const files = await loadFiles(dropfiles, {
          asBuffer: true
        });
        const decoder = new TextDecoder("utf8");
        const data2 = JSON.parse(decoder.decode(files[0].binary));
        setData2(data2);
      } catch (e2) {
        alert("Invalid JSON file");
      }
    })();
  }, []);
  const dataChangeHandler = react.exports.useCallback((data2) => {
    setCallBackData(data2);
  }, []);
  return /* @__PURE__ */ jsxs$1("div", {
    style: {
      display: "flex",
      height: "100vh",
      padding: "20px"
    },
    children: [/* @__PURE__ */ jsx$1("div", {
      style: {
        flex: 9
      },
      children: /* @__PURE__ */ jsx$1(NMRium$1, {
        data,
        onDataChange: dataChangeHandler
      })
    }), /* @__PURE__ */ jsxs$1("div", {
      style: {
        display: "flex",
        flexDirection: "column",
        padding: "10px",
        flex: 3
      },
      children: [/* @__PURE__ */ jsx$1("div", {
        style: {
          flex: 3
        },
        children: /* @__PURE__ */ jsx$1(DropZone$1, {
          onDrop: dropFileHandler,
          color: "gray"
        })
      }), /* @__PURE__ */ jsx$1("div", {
        style: {
          flex: 9
        },
        children: /* @__PURE__ */ jsx$1(Inspector, {
          data: callBackData
        })
      })]
    })]
  });
}
var Test$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": Test
}, Symbol.toStringTag, { value: "Module" }));
const TestHighlight = react.exports.lazy(() => __vitePreload(() => import("./TestHighlight.ee2ed568.js"), true ? ["assets/TestHighlight.ee2ed568.js","assets/vendor.1a8b6e6b.js"] : void 0));
function TestRoutes() {
  return /* @__PURE__ */ jsx$1(react.exports.Suspense, {
    fallback: null,
    children: /* @__PURE__ */ jsxs$1(Switch, {
      children: [/* @__PURE__ */ jsx$1(Route, {
        path: "/test/highlight",
        component: TestHighlight
      }), /* @__PURE__ */ jsx$1(Route, {
        path: "/",
        component: Test
      }), /* @__PURE__ */ jsx$1(Route, {
        render: () => /* @__PURE__ */ jsx$1("div", {
          children: "Page not found"
        })
      })]
    })
  });
}
var modernNormalize = "";
var preflight = "";
var index = "";
const rootElement = document.getElementById("root");
if (!rootElement) {
  throw new Error("#root element not found");
}
const root = profiling.exports.createRoot(rootElement);
root.render(/* @__PURE__ */ jsx$1(HashRouter, {
  children: /* @__PURE__ */ jsxs$1(Switch, {
    children: [/* @__PURE__ */ jsx$1(Route, {
      path: "/test",
      component: TestRoutes
    }), /* @__PURE__ */ jsx$1(Route, {
      path: "/",
      render: (props) => /* @__PURE__ */ jsx$1(Main, __spreadValues({}, props))
    })]
  })
}));
export { HighlightProvider as H, NMRium$1 as N, copyTextToClipboard as c, useHighlight as u };
//# sourceMappingURL=index.d5ef5b83.js.map
